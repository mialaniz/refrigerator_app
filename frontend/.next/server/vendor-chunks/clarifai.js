"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/clarifai";
exports.ids = ["vendor-chunks/clarifai"];
exports.modules = {

/***/ "(rsc)/./node_modules/clarifai/dist/App.js":
/*!*******************************************!*\
  !*** ./node_modules/clarifai/dist/App.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar axios = __webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\");\n\nvar _require = __webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/clarifai/dist/helpers.js\"),\n    checkType = _require.checkType;\n\nvar Models = __webpack_require__(/*! ./Models */ \"(rsc)/./node_modules/clarifai/dist/Models.js\");\nvar Inputs = __webpack_require__(/*! ./Inputs */ \"(rsc)/./node_modules/clarifai/dist/Inputs.js\");\nvar Concepts = __webpack_require__(/*! ./Concepts */ \"(rsc)/./node_modules/clarifai/dist/Concepts.js\");\nvar Workflow = __webpack_require__(/*! ./Workflow */ \"(rsc)/./node_modules/clarifai/dist/Workflow.js\");\nvar Workflows = __webpack_require__(/*! ./Workflows */ \"(rsc)/./node_modules/clarifai/dist/Workflows.js\");\nvar Solutions = __webpack_require__(/*! ./solutions/Solutions */ \"(rsc)/./node_modules/clarifai/dist/solutions/Solutions.js\");\n\nvar _require2 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/clarifai/dist/constants.js\"),\n    API = _require2.API,\n    ERRORS = _require2.ERRORS,\n    getBasePath = _require2.getBasePath;\n\nvar TOKEN_PATH = API.TOKEN_PATH;\n\n\nif (typeof window !== 'undefined' && !('Promise' in window)) {\n  window.Promise = __webpack_require__(/*! promise */ \"(rsc)/./node_modules/promise/index.js\");\n}\n\nif (typeof global !== 'undefined' && !('Promise' in global)) {\n  global.Promise = __webpack_require__(/*! promise */ \"(rsc)/./node_modules/promise/index.js\");\n}\n\n/**\n * top-level class that allows access to models, inputs and concepts\n * @class\n */\n\nvar App = function () {\n  function App(arg1, arg2, arg3) {\n    _classCallCheck(this, App);\n\n    var optionsObj = arg1;\n    if ((typeof arg1 === 'undefined' ? 'undefined' : _typeof(arg1)) !== 'object' || arg1 === null) {\n      optionsObj = arg3 || {};\n      optionsObj.clientId = arg1;\n      optionsObj.clientSecret = arg2;\n    }\n    this._validate(optionsObj);\n    this._init(optionsObj);\n  }\n\n  /**\n   * Gets a token from the API using client credentials\n   * @return {Promise(token, error)} A Promise that is fulfilled with the token string or rejected with an error\n   *\n   * @deprecated Please switch to using the API key.\n   */\n\n\n  _createClass(App, [{\n    key: 'getToken',\n    value: function getToken() {\n      return this._config.token();\n    }\n\n    /**\n     * Sets the token to use for the API\n     * @param {String}         _token    The token you are setting\n     * @return {Boolean}                 true if token has valid fields, false if not\n     *\n     * @deprecated Please switch to using the API key.\n     */\n\n  }, {\n    key: 'setToken',\n    value: function setToken(_token) {\n      var token = _token;\n      var now = new Date().getTime();\n      if (typeof _token === 'string') {\n        token = {\n          accessToken: _token,\n          expiresIn: 176400\n        };\n      } else {\n        token = {\n          accessToken: _token.access_token || _token.accessToken,\n          expiresIn: _token.expires_in || _token.expiresIn\n        };\n      }\n      if (token.accessToken && token.expiresIn || token.access_token && token.expires_in) {\n        if (!token.expireTime) {\n          token.expireTime = now + token.expiresIn * 1000;\n        }\n        this._config._token = token;\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: '_validate',\n    value: function _validate(_ref) {\n      var clientId = _ref.clientId,\n          clientSecret = _ref.clientSecret,\n          token = _ref.token,\n          apiKey = _ref.apiKey,\n          sessionToken = _ref.sessionToken;\n\n      if (clientId || clientSecret) {\n        console.warn('Client ID/secret has been deprecated. Please switch to using the API key. See here how to do ' + 'the switch: https://blog.clarifai.com/introducing-api-keys-a-safer-way-to-authenticate-your-applications');\n      }\n      if ((!clientId || !clientSecret) && !token && !apiKey && !sessionToken) {\n        throw ERRORS.paramsRequired(['apiKey']);\n      }\n    }\n  }, {\n    key: '_init',\n    value: function _init(options) {\n      var _this = this;\n\n      var apiEndpoint = options.apiEndpoint || process && process.env && process.env.API_ENDPOINT || 'https://api.clarifai.com';\n      this._config = {\n        apiEndpoint: apiEndpoint,\n        clientId: options.clientId,\n        clientSecret: options.clientSecret,\n        apiKey: options.apiKey,\n        sessionToken: options.sessionToken,\n        basePath: getBasePath(apiEndpoint, options.userId, options.appId),\n        token: function token() {\n          return new Promise(function (resolve, reject) {\n            var now = new Date().getTime();\n            if (checkType(/Object/, _this._config._token) && _this._config._token.expireTime > now) {\n              resolve(_this._config._token);\n            } else {\n              _this._getToken(resolve, reject);\n            }\n          });\n        }\n      };\n      if (options.token) {\n        this.setToken(options.token);\n      }\n      this.models = new Models(this._config);\n      this.inputs = new Inputs(this._config);\n      this.concepts = new Concepts(this._config);\n      this.workflow = new Workflow(this._config);\n      this.workflows = new Workflows(this._config);\n      this.solutions = new Solutions(this._config);\n    }\n\n    /**\n     * @deprecated Please switch to using the API key.\n     */\n\n  }, {\n    key: '_getToken',\n    value: function _getToken(resolve, reject) {\n      var _this2 = this;\n\n      this._requestToken().then(function (response) {\n        if (response.status === 200) {\n          _this2.setToken(response.data);\n          resolve(_this2._config._token);\n        } else {\n          reject(response);\n        }\n      }, reject);\n    }\n\n    /**\n     * @deprecated Please switch to using the API key.\n     */\n\n  }, {\n    key: '_requestToken',\n    value: function _requestToken() {\n      var url = '' + this._config.basePath + TOKEN_PATH;\n      var clientId = this._config.clientId;\n      var clientSecret = this._config.clientSecret;\n      return axios({\n        'url': url,\n        'method': 'POST',\n        'auth': {\n          'username': clientId,\n          'password': clientSecret\n        }\n      });\n    }\n  }]);\n\n  return App;\n}();\n\nmodule.exports = App;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2xhcmlmYWkvZGlzdC9BcHAuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIscUdBQXFHLHFCQUFxQixtQkFBbUI7O0FBRTdJLGlDQUFpQywyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwrREFBK0QseURBQXlELHFFQUFxRSw2REFBNkQsd0JBQXdCOztBQUVqakIsa0RBQWtELDBDQUEwQzs7QUFFNUYsWUFBWSxtQkFBTyxDQUFDLDZEQUFPOztBQUUzQixlQUFlLG1CQUFPLENBQUMsZ0VBQVc7QUFDbEM7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLDhEQUFVO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyw4REFBVTtBQUMvQixlQUFlLG1CQUFPLENBQUMsa0VBQVk7QUFDbkMsZUFBZSxtQkFBTyxDQUFDLGtFQUFZO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLG9FQUFhO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLHdGQUF1Qjs7QUFFL0MsZ0JBQWdCLG1CQUFPLENBQUMsb0VBQWE7QUFDckM7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLHNEQUFTO0FBQ3BDOztBQUVBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsc0RBQVM7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZnJpZ2VyYXRvcl9hcHAvLi9ub2RlX21vZHVsZXMvY2xhcmlmYWkvZGlzdC9BcHAuanM/OTlkMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIGF4aW9zID0gcmVxdWlyZSgnYXhpb3MnKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9oZWxwZXJzJyksXG4gICAgY2hlY2tUeXBlID0gX3JlcXVpcmUuY2hlY2tUeXBlO1xuXG52YXIgTW9kZWxzID0gcmVxdWlyZSgnLi9Nb2RlbHMnKTtcbnZhciBJbnB1dHMgPSByZXF1aXJlKCcuL0lucHV0cycpO1xudmFyIENvbmNlcHRzID0gcmVxdWlyZSgnLi9Db25jZXB0cycpO1xudmFyIFdvcmtmbG93ID0gcmVxdWlyZSgnLi9Xb3JrZmxvdycpO1xudmFyIFdvcmtmbG93cyA9IHJlcXVpcmUoJy4vV29ya2Zsb3dzJyk7XG52YXIgU29sdXRpb25zID0gcmVxdWlyZSgnLi9zb2x1dGlvbnMvU29sdXRpb25zJyk7XG5cbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpLFxuICAgIEFQSSA9IF9yZXF1aXJlMi5BUEksXG4gICAgRVJST1JTID0gX3JlcXVpcmUyLkVSUk9SUyxcbiAgICBnZXRCYXNlUGF0aCA9IF9yZXF1aXJlMi5nZXRCYXNlUGF0aDtcblxudmFyIFRPS0VOX1BBVEggPSBBUEkuVE9LRU5fUEFUSDtcblxuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgISgnUHJvbWlzZScgaW4gd2luZG93KSkge1xuICB3aW5kb3cuUHJvbWlzZSA9IHJlcXVpcmUoJ3Byb21pc2UnKTtcbn1cblxuaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmICEoJ1Byb21pc2UnIGluIGdsb2JhbCkpIHtcbiAgZ2xvYmFsLlByb21pc2UgPSByZXF1aXJlKCdwcm9taXNlJyk7XG59XG5cbi8qKlxuICogdG9wLWxldmVsIGNsYXNzIHRoYXQgYWxsb3dzIGFjY2VzcyB0byBtb2RlbHMsIGlucHV0cyBhbmQgY29uY2VwdHNcbiAqIEBjbGFzc1xuICovXG5cbnZhciBBcHAgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFwcChhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFwcCk7XG5cbiAgICB2YXIgb3B0aW9uc09iaiA9IGFyZzE7XG4gICAgaWYgKCh0eXBlb2YgYXJnMSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYXJnMSkpICE9PSAnb2JqZWN0JyB8fCBhcmcxID09PSBudWxsKSB7XG4gICAgICBvcHRpb25zT2JqID0gYXJnMyB8fCB7fTtcbiAgICAgIG9wdGlvbnNPYmouY2xpZW50SWQgPSBhcmcxO1xuICAgICAgb3B0aW9uc09iai5jbGllbnRTZWNyZXQgPSBhcmcyO1xuICAgIH1cbiAgICB0aGlzLl92YWxpZGF0ZShvcHRpb25zT2JqKTtcbiAgICB0aGlzLl9pbml0KG9wdGlvbnNPYmopO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYSB0b2tlbiBmcm9tIHRoZSBBUEkgdXNpbmcgY2xpZW50IGNyZWRlbnRpYWxzXG4gICAqIEByZXR1cm4ge1Byb21pc2UodG9rZW4sIGVycm9yKX0gQSBQcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdpdGggdGhlIHRva2VuIHN0cmluZyBvciByZWplY3RlZCB3aXRoIGFuIGVycm9yXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFBsZWFzZSBzd2l0Y2ggdG8gdXNpbmcgdGhlIEFQSSBrZXkuXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEFwcCwgW3tcbiAgICBrZXk6ICdnZXRUb2tlbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRva2VuKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZy50b2tlbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHRva2VuIHRvIHVzZSBmb3IgdGhlIEFQSVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICAgIF90b2tlbiAgICBUaGUgdG9rZW4geW91IGFyZSBzZXR0aW5nXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICAgICAgIHRydWUgaWYgdG9rZW4gaGFzIHZhbGlkIGZpZWxkcywgZmFsc2UgaWYgbm90XG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBQbGVhc2Ugc3dpdGNoIHRvIHVzaW5nIHRoZSBBUEkga2V5LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRUb2tlbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFRva2VuKF90b2tlbikge1xuICAgICAgdmFyIHRva2VuID0gX3Rva2VuO1xuICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgaWYgKHR5cGVvZiBfdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRva2VuID0ge1xuICAgICAgICAgIGFjY2Vzc1Rva2VuOiBfdG9rZW4sXG4gICAgICAgICAgZXhwaXJlc0luOiAxNzY0MDBcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRva2VuID0ge1xuICAgICAgICAgIGFjY2Vzc1Rva2VuOiBfdG9rZW4uYWNjZXNzX3Rva2VuIHx8IF90b2tlbi5hY2Nlc3NUb2tlbixcbiAgICAgICAgICBleHBpcmVzSW46IF90b2tlbi5leHBpcmVzX2luIHx8IF90b2tlbi5leHBpcmVzSW5cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbi5hY2Nlc3NUb2tlbiAmJiB0b2tlbi5leHBpcmVzSW4gfHwgdG9rZW4uYWNjZXNzX3Rva2VuICYmIHRva2VuLmV4cGlyZXNfaW4pIHtcbiAgICAgICAgaWYgKCF0b2tlbi5leHBpcmVUaW1lKSB7XG4gICAgICAgICAgdG9rZW4uZXhwaXJlVGltZSA9IG5vdyArIHRva2VuLmV4cGlyZXNJbiAqIDEwMDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29uZmlnLl90b2tlbiA9IHRva2VuO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfdmFsaWRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdmFsaWRhdGUoX3JlZikge1xuICAgICAgdmFyIGNsaWVudElkID0gX3JlZi5jbGllbnRJZCxcbiAgICAgICAgICBjbGllbnRTZWNyZXQgPSBfcmVmLmNsaWVudFNlY3JldCxcbiAgICAgICAgICB0b2tlbiA9IF9yZWYudG9rZW4sXG4gICAgICAgICAgYXBpS2V5ID0gX3JlZi5hcGlLZXksXG4gICAgICAgICAgc2Vzc2lvblRva2VuID0gX3JlZi5zZXNzaW9uVG9rZW47XG5cbiAgICAgIGlmIChjbGllbnRJZCB8fCBjbGllbnRTZWNyZXQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdDbGllbnQgSUQvc2VjcmV0IGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFBsZWFzZSBzd2l0Y2ggdG8gdXNpbmcgdGhlIEFQSSBrZXkuIFNlZSBoZXJlIGhvdyB0byBkbyAnICsgJ3RoZSBzd2l0Y2g6IGh0dHBzOi8vYmxvZy5jbGFyaWZhaS5jb20vaW50cm9kdWNpbmctYXBpLWtleXMtYS1zYWZlci13YXktdG8tYXV0aGVudGljYXRlLXlvdXItYXBwbGljYXRpb25zJyk7XG4gICAgICB9XG4gICAgICBpZiAoKCFjbGllbnRJZCB8fCAhY2xpZW50U2VjcmV0KSAmJiAhdG9rZW4gJiYgIWFwaUtleSAmJiAhc2Vzc2lvblRva2VuKSB7XG4gICAgICAgIHRocm93IEVSUk9SUy5wYXJhbXNSZXF1aXJlZChbJ2FwaUtleSddKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfaW5pdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KG9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBhcGlFbmRwb2ludCA9IG9wdGlvbnMuYXBpRW5kcG9pbnQgfHwgcHJvY2VzcyAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5BUElfRU5EUE9JTlQgfHwgJ2h0dHBzOi8vYXBpLmNsYXJpZmFpLmNvbSc7XG4gICAgICB0aGlzLl9jb25maWcgPSB7XG4gICAgICAgIGFwaUVuZHBvaW50OiBhcGlFbmRwb2ludCxcbiAgICAgICAgY2xpZW50SWQ6IG9wdGlvbnMuY2xpZW50SWQsXG4gICAgICAgIGNsaWVudFNlY3JldDogb3B0aW9ucy5jbGllbnRTZWNyZXQsXG4gICAgICAgIGFwaUtleTogb3B0aW9ucy5hcGlLZXksXG4gICAgICAgIHNlc3Npb25Ub2tlbjogb3B0aW9ucy5zZXNzaW9uVG9rZW4sXG4gICAgICAgIGJhc2VQYXRoOiBnZXRCYXNlUGF0aChhcGlFbmRwb2ludCwgb3B0aW9ucy51c2VySWQsIG9wdGlvbnMuYXBwSWQpLFxuICAgICAgICB0b2tlbjogZnVuY3Rpb24gdG9rZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIGlmIChjaGVja1R5cGUoL09iamVjdC8sIF90aGlzLl9jb25maWcuX3Rva2VuKSAmJiBfdGhpcy5fY29uZmlnLl90b2tlbi5leHBpcmVUaW1lID4gbm93KSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoX3RoaXMuX2NvbmZpZy5fdG9rZW4pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX3RoaXMuX2dldFRva2VuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAob3B0aW9ucy50b2tlbikge1xuICAgICAgICB0aGlzLnNldFRva2VuKG9wdGlvbnMudG9rZW4pO1xuICAgICAgfVxuICAgICAgdGhpcy5tb2RlbHMgPSBuZXcgTW9kZWxzKHRoaXMuX2NvbmZpZyk7XG4gICAgICB0aGlzLmlucHV0cyA9IG5ldyBJbnB1dHModGhpcy5fY29uZmlnKTtcbiAgICAgIHRoaXMuY29uY2VwdHMgPSBuZXcgQ29uY2VwdHModGhpcy5fY29uZmlnKTtcbiAgICAgIHRoaXMud29ya2Zsb3cgPSBuZXcgV29ya2Zsb3codGhpcy5fY29uZmlnKTtcbiAgICAgIHRoaXMud29ya2Zsb3dzID0gbmV3IFdvcmtmbG93cyh0aGlzLl9jb25maWcpO1xuICAgICAgdGhpcy5zb2x1dGlvbnMgPSBuZXcgU29sdXRpb25zKHRoaXMuX2NvbmZpZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgUGxlYXNlIHN3aXRjaCB0byB1c2luZyB0aGUgQVBJIGtleS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2dldFRva2VuJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFRva2VuKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX3JlcXVlc3RUb2tlbigpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgIF90aGlzMi5zZXRUb2tlbihyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICByZXNvbHZlKF90aGlzMi5fY29uZmlnLl90b2tlbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgfSwgcmVqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBQbGVhc2Ugc3dpdGNoIHRvIHVzaW5nIHRoZSBBUEkga2V5LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfcmVxdWVzdFRva2VuJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlcXVlc3RUb2tlbigpIHtcbiAgICAgIHZhciB1cmwgPSAnJyArIHRoaXMuX2NvbmZpZy5iYXNlUGF0aCArIFRPS0VOX1BBVEg7XG4gICAgICB2YXIgY2xpZW50SWQgPSB0aGlzLl9jb25maWcuY2xpZW50SWQ7XG4gICAgICB2YXIgY2xpZW50U2VjcmV0ID0gdGhpcy5fY29uZmlnLmNsaWVudFNlY3JldDtcbiAgICAgIHJldHVybiBheGlvcyh7XG4gICAgICAgICd1cmwnOiB1cmwsXG4gICAgICAgICdtZXRob2QnOiAnUE9TVCcsXG4gICAgICAgICdhdXRoJzoge1xuICAgICAgICAgICd1c2VybmFtZSc6IGNsaWVudElkLFxuICAgICAgICAgICdwYXNzd29yZCc6IGNsaWVudFNlY3JldFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQXBwO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFwcDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/clarifai/dist/App.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/clarifai/dist/Concept.js":
/*!***********************************************!*\
  !*** ./node_modules/clarifai/dist/Concept.js ***!
  \***********************************************/
/***/ ((module) => {

eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * class representing a concept and its info\n * @class\n */\nvar Concept = function Concept(_config, data) {\n  _classCallCheck(this, Concept);\n\n  this.id = data.id;\n  this.name = data.name;\n  this.createdAt = data.created_at || data.createdAt;\n  this.appId = data.app_id || data.appId;\n  this.value = data.value || null;\n  this._config = _config;\n  this.rawData = data;\n};\n\n;\n\nmodule.exports = Concept;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2xhcmlmYWkvZGlzdC9Db25jZXB0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGtEQUFrRCwwQ0FBMEM7O0FBRTVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVmcmlnZXJhdG9yX2FwcC8uL25vZGVfbW9kdWxlcy9jbGFyaWZhaS9kaXN0L0NvbmNlcHQuanM/YWQ4YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBjbGFzcyByZXByZXNlbnRpbmcgYSBjb25jZXB0IGFuZCBpdHMgaW5mb1xuICogQGNsYXNzXG4gKi9cbnZhciBDb25jZXB0ID0gZnVuY3Rpb24gQ29uY2VwdChfY29uZmlnLCBkYXRhKSB7XG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb25jZXB0KTtcblxuICB0aGlzLmlkID0gZGF0YS5pZDtcbiAgdGhpcy5uYW1lID0gZGF0YS5uYW1lO1xuICB0aGlzLmNyZWF0ZWRBdCA9IGRhdGEuY3JlYXRlZF9hdCB8fCBkYXRhLmNyZWF0ZWRBdDtcbiAgdGhpcy5hcHBJZCA9IGRhdGEuYXBwX2lkIHx8IGRhdGEuYXBwSWQ7XG4gIHRoaXMudmFsdWUgPSBkYXRhLnZhbHVlIHx8IG51bGw7XG4gIHRoaXMuX2NvbmZpZyA9IF9jb25maWc7XG4gIHRoaXMucmF3RGF0YSA9IGRhdGE7XG59O1xuXG47XG5cbm1vZHVsZS5leHBvcnRzID0gQ29uY2VwdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/clarifai/dist/Concept.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/clarifai/dist/Concepts.js":
/*!************************************************!*\
  !*** ./node_modules/clarifai/dist/Concepts.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar axios = __webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\");\nvar Concept = __webpack_require__(/*! ./Concept */ \"(rsc)/./node_modules/clarifai/dist/Concept.js\");\n\nvar _require = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/clarifai/dist/constants.js\"),\n    API = _require.API,\n    replaceVars = _require.replaceVars;\n\nvar CONCEPTS_PATH = API.CONCEPTS_PATH,\n    CONCEPT_PATH = API.CONCEPT_PATH,\n    CONCEPT_SEARCH_PATH = API.CONCEPT_SEARCH_PATH;\n\nvar _require2 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/clarifai/dist/utils.js\"),\n    wrapToken = _require2.wrapToken,\n    formatConcept = _require2.formatConcept;\n\nvar _require3 = __webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/clarifai/dist/helpers.js\"),\n    isSuccess = _require3.isSuccess,\n    checkType = _require3.checkType;\n\n/**\n * class representing a collection of concepts\n * @class\n */\n\n\nvar Concepts = function () {\n  function Concepts(_config) {\n    var _this = this;\n\n    var rawData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    _classCallCheck(this, Concepts);\n\n    this._config = _config;\n    this.rawData = rawData;\n    rawData.forEach(function (conceptData, index) {\n      _this[index] = new Concept(_this._config, conceptData);\n    });\n    this.length = rawData.length;\n  }\n\n  /**\n   * List all the concepts\n   * @param {object}     options     Object with keys explained below: (optional)\n   *    @param {number}    options.page        The page number (optional, default: 1)\n   *    @param {number}    options.perPage     Number of images to return per page (optional, default: 20)\n   * @return {Promise(Concepts, error)} A Promise that is fulfilled with a Concepts instance or rejected with an error\n   */\n\n\n  _createClass(Concepts, [{\n    key: 'list',\n    value: function list() {\n      var _this2 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { page: 1, perPage: 20 };\n\n      var url = '' + this._config.basePath + CONCEPTS_PATH;\n      return wrapToken(this._config, function (headers) {\n        return new Promise(function (resolve, reject) {\n          axios.get(url, {\n            headers: headers,\n            params: {\n              'page': options.page,\n              'per_page': options.perPage\n            }\n          }).then(function (response) {\n            if (isSuccess(response)) {\n              resolve(new Concepts(_this2._config, response.data.concepts));\n            } else {\n              reject(response);\n            }\n          }, reject);\n        });\n      });\n    }\n\n    /**\n     * List a single concept given an id\n     * @param {String}     id          The concept's id\n     * @return {Promise(Concept, error)} A Promise that is fulfilled with a Concept instance or rejected with an error\n     */\n\n  }, {\n    key: 'get',\n    value: function get(id) {\n      var _this3 = this;\n\n      var url = '' + this._config.basePath + replaceVars(CONCEPT_PATH, [id]);\n      return wrapToken(this._config, function (headers) {\n        return new Promise(function (resolve, reject) {\n          axios.get(url, { headers: headers }).then(function (response) {\n            if (isSuccess(response)) {\n              resolve(new Concept(_this3._config, response.data.concept));\n            } else {\n              reject(response);\n            }\n          }, reject);\n        });\n      });\n    }\n\n    /**\n     * Add a list of concepts given an id and name\n     * @param {object|object[]}   concepts       Can be a single media object or an array of media objects\n     *   @param  {object|string}    concepts[].concept         If string, this is assumed to be the concept id. Otherwise, an object with the following attributes\n     *     @param  {object}           concepts[].concept.id      The new concept's id (Required)\n     *     @param  {object}           concepts[].concept.name    The new concept's name\n     * @return {Promise(Concepts, error)}             A Promise that is fulfilled with a Concepts instance or rejected with an error\n     */\n\n  }, {\n    key: 'create',\n    value: function create() {\n      var _this4 = this;\n\n      var concepts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (checkType(/(Object|String)/, concepts)) {\n        concepts = [concepts];\n      }\n      var data = {\n        'concepts': concepts.map(formatConcept)\n      };\n      var url = '' + this._config.basePath + CONCEPTS_PATH;\n      return wrapToken(this._config, function (headers) {\n        return new Promise(function (resolve, reject) {\n          axios.post(url, data, { headers: headers }).then(function (response) {\n            if (isSuccess(response)) {\n              resolve(new Concepts(_this4._config, response.data.concepts));\n            } else {\n              reject(response);\n            }\n          }, reject);\n        });\n      });\n    }\n\n    /**\n     * Search for a concept given a name. A wildcard can be given (example: The name \"bo*\" will match with \"boat\" and \"bow\" given those concepts exist\n     * @param  {string}   name  The name of the concept to search for\n     * @return {Promise(Concepts, error)} A Promise that is fulfilled with a Concepts instance or rejected with an error\n     */\n\n  }, {\n    key: 'search',\n    value: function search(name) {\n      var _this5 = this;\n\n      var language = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      var url = '' + this._config.basePath + CONCEPT_SEARCH_PATH;\n      return wrapToken(this._config, function (headers) {\n        var params = {\n          'concept_query': { name: name, language: language }\n        };\n        return new Promise(function (resolve, reject) {\n          axios.post(url, params, { headers: headers }).then(function (response) {\n            if (isSuccess(response)) {\n              resolve(new Concepts(_this5._config, response.data.concepts));\n            } else {\n              reject(response);\n            }\n          }, reject);\n        });\n      });\n    }\n\n    /**\n     * Update a concepts\n     * @param {object|object[]}   concepts       Can be a single concept object or an array of concept objects\n     *   @param  {object}           concepts[].concept         A concept object with the following attributes\n     *     @param  {object}           concepts[].concept.id      The concept's id (Required)\n     *     @param  {object}           concepts[].concept.name    The concept's new name\n     * @param {string}            [action=overwrite]  The action to use for the PATCH\n     * @return {Promise(Concepts, error)}             A Promise that is fulfilled with a Concepts instance or rejected with an error\n     */\n\n  }, {\n    key: 'update',\n    value: function update() {\n      var _this6 = this;\n\n      var concepts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'overwrite';\n\n      if (!checkType(/Array/, concepts)) {\n        concepts = [concepts];\n      }\n      var data = {\n        concepts: concepts,\n        action: action\n      };\n      var url = '' + this._config.basePath + CONCEPTS_PATH;\n      return wrapToken(this._config, function (headers) {\n        return new Promise(function (resolve, reject) {\n          axios.patch(url, data, { headers: headers }).then(function (response) {\n            if (isSuccess(response)) {\n              resolve(new Concepts(_this6._config, response.data.concepts));\n            } else {\n              reject(response);\n            }\n          }, reject);\n        });\n      });\n    }\n  }]);\n\n  return Concepts;\n}();\n\n;\n\nmodule.exports = Concepts;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2xhcmlmYWkvZGlzdC9Db25jZXB0cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixpQ0FBaUMsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsK0RBQStELHlEQUF5RCxxRUFBcUUsNkRBQTZELHdCQUF3Qjs7QUFFampCLGtEQUFrRCwwQ0FBMEM7O0FBRTVGLFlBQVksbUJBQU8sQ0FBQyw2REFBTztBQUMzQixjQUFjLG1CQUFPLENBQUMsZ0VBQVc7O0FBRWpDLGVBQWUsbUJBQU8sQ0FBQyxvRUFBYTtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsbUJBQU8sQ0FBQyw0REFBUztBQUNqQztBQUNBOztBQUVBLGdCQUFnQixtQkFBTyxDQUFDLGdFQUFXO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsZ0JBQWdCLFdBQVc7QUFDM0IsZ0JBQWdCLFdBQVc7QUFDM0IsY0FBYywwQkFBMEI7QUFDeEM7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBGQUEwRjs7QUFFMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZ0JBQWdCLHlCQUF5QjtBQUN6Qzs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDLGtCQUFrQixrQkFBa0I7QUFDcEMsb0JBQW9CLGtCQUFrQjtBQUN0QyxvQkFBb0Isa0JBQWtCO0FBQ3RDLGdCQUFnQixzQ0FBc0M7QUFDdEQ7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msa0JBQWtCO0FBQ3BEO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQixnQkFBZ0IsMEJBQTBCO0FBQzFDOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxvQ0FBb0Msa0JBQWtCO0FBQ3REO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQyxrQkFBa0Isa0JBQWtCO0FBQ3BDLG9CQUFvQixrQkFBa0I7QUFDdEMsb0JBQW9CLGtCQUFrQjtBQUN0QyxlQUFlLG1CQUFtQjtBQUNsQyxnQkFBZ0Isc0NBQXNDO0FBQ3REOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrQkFBa0I7QUFDckQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZnJpZ2VyYXRvcl9hcHAvLi9ub2RlX21vZHVsZXMvY2xhcmlmYWkvZGlzdC9Db25jZXB0cy5qcz8wY2Q2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIGF4aW9zID0gcmVxdWlyZSgnYXhpb3MnKTtcbnZhciBDb25jZXB0ID0gcmVxdWlyZSgnLi9Db25jZXB0Jyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyksXG4gICAgQVBJID0gX3JlcXVpcmUuQVBJLFxuICAgIHJlcGxhY2VWYXJzID0gX3JlcXVpcmUucmVwbGFjZVZhcnM7XG5cbnZhciBDT05DRVBUU19QQVRIID0gQVBJLkNPTkNFUFRTX1BBVEgsXG4gICAgQ09OQ0VQVF9QQVRIID0gQVBJLkNPTkNFUFRfUEFUSCxcbiAgICBDT05DRVBUX1NFQVJDSF9QQVRIID0gQVBJLkNPTkNFUFRfU0VBUkNIX1BBVEg7XG5cbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKCcuL3V0aWxzJyksXG4gICAgd3JhcFRva2VuID0gX3JlcXVpcmUyLndyYXBUb2tlbixcbiAgICBmb3JtYXRDb25jZXB0ID0gX3JlcXVpcmUyLmZvcm1hdENvbmNlcHQ7XG5cbnZhciBfcmVxdWlyZTMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKSxcbiAgICBpc1N1Y2Nlc3MgPSBfcmVxdWlyZTMuaXNTdWNjZXNzLFxuICAgIGNoZWNrVHlwZSA9IF9yZXF1aXJlMy5jaGVja1R5cGU7XG5cbi8qKlxuICogY2xhc3MgcmVwcmVzZW50aW5nIGEgY29sbGVjdGlvbiBvZiBjb25jZXB0c1xuICogQGNsYXNzXG4gKi9cblxuXG52YXIgQ29uY2VwdHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvbmNlcHRzKF9jb25maWcpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHJhd0RhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbmNlcHRzKTtcblxuICAgIHRoaXMuX2NvbmZpZyA9IF9jb25maWc7XG4gICAgdGhpcy5yYXdEYXRhID0gcmF3RGF0YTtcbiAgICByYXdEYXRhLmZvckVhY2goZnVuY3Rpb24gKGNvbmNlcHREYXRhLCBpbmRleCkge1xuICAgICAgX3RoaXNbaW5kZXhdID0gbmV3IENvbmNlcHQoX3RoaXMuX2NvbmZpZywgY29uY2VwdERhdGEpO1xuICAgIH0pO1xuICAgIHRoaXMubGVuZ3RoID0gcmF3RGF0YS5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogTGlzdCBhbGwgdGhlIGNvbmNlcHRzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgb3B0aW9ucyAgICAgT2JqZWN0IHdpdGgga2V5cyBleHBsYWluZWQgYmVsb3c6IChvcHRpb25hbClcbiAgICogICAgQHBhcmFtIHtudW1iZXJ9ICAgIG9wdGlvbnMucGFnZSAgICAgICAgVGhlIHBhZ2UgbnVtYmVyIChvcHRpb25hbCwgZGVmYXVsdDogMSlcbiAgICogICAgQHBhcmFtIHtudW1iZXJ9ICAgIG9wdGlvbnMucGVyUGFnZSAgICAgTnVtYmVyIG9mIGltYWdlcyB0byByZXR1cm4gcGVyIHBhZ2UgKG9wdGlvbmFsLCBkZWZhdWx0OiAyMClcbiAgICogQHJldHVybiB7UHJvbWlzZShDb25jZXB0cywgZXJyb3IpfSBBIFByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2l0aCBhIENvbmNlcHRzIGluc3RhbmNlIG9yIHJlamVjdGVkIHdpdGggYW4gZXJyb3JcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoQ29uY2VwdHMsIFt7XG4gICAga2V5OiAnbGlzdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpc3QoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHsgcGFnZTogMSwgcGVyUGFnZTogMjAgfTtcblxuICAgICAgdmFyIHVybCA9ICcnICsgdGhpcy5fY29uZmlnLmJhc2VQYXRoICsgQ09OQ0VQVFNfUEFUSDtcbiAgICAgIHJldHVybiB3cmFwVG9rZW4odGhpcy5fY29uZmlnLCBmdW5jdGlvbiAoaGVhZGVycykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGF4aW9zLmdldCh1cmwsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgJ3BhZ2UnOiBvcHRpb25zLnBhZ2UsXG4gICAgICAgICAgICAgICdwZXJfcGFnZSc6IG9wdGlvbnMucGVyUGFnZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAoaXNTdWNjZXNzKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICByZXNvbHZlKG5ldyBDb25jZXB0cyhfdGhpczIuX2NvbmZpZywgcmVzcG9uc2UuZGF0YS5jb25jZXB0cykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVqZWN0KHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3QgYSBzaW5nbGUgY29uY2VwdCBnaXZlbiBhbiBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgaWQgICAgICAgICAgVGhlIGNvbmNlcHQncyBpZFxuICAgICAqIEByZXR1cm4ge1Byb21pc2UoQ29uY2VwdCwgZXJyb3IpfSBBIFByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2l0aCBhIENvbmNlcHQgaW5zdGFuY2Ugb3IgcmVqZWN0ZWQgd2l0aCBhbiBlcnJvclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoaWQpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgdXJsID0gJycgKyB0aGlzLl9jb25maWcuYmFzZVBhdGggKyByZXBsYWNlVmFycyhDT05DRVBUX1BBVEgsIFtpZF0pO1xuICAgICAgcmV0dXJuIHdyYXBUb2tlbih0aGlzLl9jb25maWcsIGZ1bmN0aW9uIChoZWFkZXJzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgYXhpb3MuZ2V0KHVybCwgeyBoZWFkZXJzOiBoZWFkZXJzIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAoaXNTdWNjZXNzKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICByZXNvbHZlKG5ldyBDb25jZXB0KF90aGlzMy5fY29uZmlnLCByZXNwb25zZS5kYXRhLmNvbmNlcHQpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlamVjdChyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBsaXN0IG9mIGNvbmNlcHRzIGdpdmVuIGFuIGlkIGFuZCBuYW1lXG4gICAgICogQHBhcmFtIHtvYmplY3R8b2JqZWN0W119ICAgY29uY2VwdHMgICAgICAgQ2FuIGJlIGEgc2luZ2xlIG1lZGlhIG9iamVjdCBvciBhbiBhcnJheSBvZiBtZWRpYSBvYmplY3RzXG4gICAgICogICBAcGFyYW0gIHtvYmplY3R8c3RyaW5nfSAgICBjb25jZXB0c1tdLmNvbmNlcHQgICAgICAgICBJZiBzdHJpbmcsIHRoaXMgaXMgYXNzdW1lZCB0byBiZSB0aGUgY29uY2VwdCBpZC4gT3RoZXJ3aXNlLCBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIGF0dHJpYnV0ZXNcbiAgICAgKiAgICAgQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgY29uY2VwdHNbXS5jb25jZXB0LmlkICAgICAgVGhlIG5ldyBjb25jZXB0J3MgaWQgKFJlcXVpcmVkKVxuICAgICAqICAgICBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICBjb25jZXB0c1tdLmNvbmNlcHQubmFtZSAgICBUaGUgbmV3IGNvbmNlcHQncyBuYW1lXG4gICAgICogQHJldHVybiB7UHJvbWlzZShDb25jZXB0cywgZXJyb3IpfSAgICAgICAgICAgICBBIFByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2l0aCBhIENvbmNlcHRzIGluc3RhbmNlIG9yIHJlamVjdGVkIHdpdGggYW4gZXJyb3JcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY3JlYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciBjb25jZXB0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG5cbiAgICAgIGlmIChjaGVja1R5cGUoLyhPYmplY3R8U3RyaW5nKS8sIGNvbmNlcHRzKSkge1xuICAgICAgICBjb25jZXB0cyA9IFtjb25jZXB0c107XG4gICAgICB9XG4gICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgJ2NvbmNlcHRzJzogY29uY2VwdHMubWFwKGZvcm1hdENvbmNlcHQpXG4gICAgICB9O1xuICAgICAgdmFyIHVybCA9ICcnICsgdGhpcy5fY29uZmlnLmJhc2VQYXRoICsgQ09OQ0VQVFNfUEFUSDtcbiAgICAgIHJldHVybiB3cmFwVG9rZW4odGhpcy5fY29uZmlnLCBmdW5jdGlvbiAoaGVhZGVycykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGF4aW9zLnBvc3QodXJsLCBkYXRhLCB7IGhlYWRlcnM6IGhlYWRlcnMgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChpc1N1Y2Nlc3MocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUobmV3IENvbmNlcHRzKF90aGlzNC5fY29uZmlnLCByZXNwb25zZS5kYXRhLmNvbmNlcHRzKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWplY3QocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VhcmNoIGZvciBhIGNvbmNlcHQgZ2l2ZW4gYSBuYW1lLiBBIHdpbGRjYXJkIGNhbiBiZSBnaXZlbiAoZXhhbXBsZTogVGhlIG5hbWUgXCJibypcIiB3aWxsIG1hdGNoIHdpdGggXCJib2F0XCIgYW5kIFwiYm93XCIgZ2l2ZW4gdGhvc2UgY29uY2VwdHMgZXhpc3RcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgbmFtZSAgVGhlIG5hbWUgb2YgdGhlIGNvbmNlcHQgdG8gc2VhcmNoIGZvclxuICAgICAqIEByZXR1cm4ge1Byb21pc2UoQ29uY2VwdHMsIGVycm9yKX0gQSBQcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdpdGggYSBDb25jZXB0cyBpbnN0YW5jZSBvciByZWplY3RlZCB3aXRoIGFuIGVycm9yXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NlYXJjaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlYXJjaChuYW1lKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgdmFyIGxhbmd1YWdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuXG4gICAgICB2YXIgdXJsID0gJycgKyB0aGlzLl9jb25maWcuYmFzZVBhdGggKyBDT05DRVBUX1NFQVJDSF9QQVRIO1xuICAgICAgcmV0dXJuIHdyYXBUb2tlbih0aGlzLl9jb25maWcsIGZ1bmN0aW9uIChoZWFkZXJzKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgJ2NvbmNlcHRfcXVlcnknOiB7IG5hbWU6IG5hbWUsIGxhbmd1YWdlOiBsYW5ndWFnZSB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgYXhpb3MucG9zdCh1cmwsIHBhcmFtcywgeyBoZWFkZXJzOiBoZWFkZXJzIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAoaXNTdWNjZXNzKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICByZXNvbHZlKG5ldyBDb25jZXB0cyhfdGhpczUuX2NvbmZpZywgcmVzcG9uc2UuZGF0YS5jb25jZXB0cykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVqZWN0KHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBhIGNvbmNlcHRzXG4gICAgICogQHBhcmFtIHtvYmplY3R8b2JqZWN0W119ICAgY29uY2VwdHMgICAgICAgQ2FuIGJlIGEgc2luZ2xlIGNvbmNlcHQgb2JqZWN0IG9yIGFuIGFycmF5IG9mIGNvbmNlcHQgb2JqZWN0c1xuICAgICAqICAgQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgY29uY2VwdHNbXS5jb25jZXB0ICAgICAgICAgQSBjb25jZXB0IG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlc1xuICAgICAqICAgICBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICBjb25jZXB0c1tdLmNvbmNlcHQuaWQgICAgICBUaGUgY29uY2VwdCdzIGlkIChSZXF1aXJlZClcbiAgICAgKiAgICAgQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgY29uY2VwdHNbXS5jb25jZXB0Lm5hbWUgICAgVGhlIGNvbmNlcHQncyBuZXcgbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgIFthY3Rpb249b3ZlcndyaXRlXSAgVGhlIGFjdGlvbiB0byB1c2UgZm9yIHRoZSBQQVRDSFxuICAgICAqIEByZXR1cm4ge1Byb21pc2UoQ29uY2VwdHMsIGVycm9yKX0gICAgICAgICAgICAgQSBQcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdpdGggYSBDb25jZXB0cyBpbnN0YW5jZSBvciByZWplY3RlZCB3aXRoIGFuIGVycm9yXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICB2YXIgY29uY2VwdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgICAgdmFyIGFjdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ292ZXJ3cml0ZSc7XG5cbiAgICAgIGlmICghY2hlY2tUeXBlKC9BcnJheS8sIGNvbmNlcHRzKSkge1xuICAgICAgICBjb25jZXB0cyA9IFtjb25jZXB0c107XG4gICAgICB9XG4gICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgY29uY2VwdHM6IGNvbmNlcHRzLFxuICAgICAgICBhY3Rpb246IGFjdGlvblxuICAgICAgfTtcbiAgICAgIHZhciB1cmwgPSAnJyArIHRoaXMuX2NvbmZpZy5iYXNlUGF0aCArIENPTkNFUFRTX1BBVEg7XG4gICAgICByZXR1cm4gd3JhcFRva2VuKHRoaXMuX2NvbmZpZywgZnVuY3Rpb24gKGhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBheGlvcy5wYXRjaCh1cmwsIGRhdGEsIHsgaGVhZGVyczogaGVhZGVycyB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKGlzU3VjY2VzcyhyZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShuZXcgQ29uY2VwdHMoX3RoaXM2Ll9jb25maWcsIHJlc3BvbnNlLmRhdGEuY29uY2VwdHMpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlamVjdChyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29uY2VwdHM7XG59KCk7XG5cbjtcblxubW9kdWxlLmV4cG9ydHMgPSBDb25jZXB0czsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/clarifai/dist/Concepts.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/clarifai/dist/Input.js":
/*!*********************************************!*\
  !*** ./node_modules/clarifai/dist/Input.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar axios = __webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\");\nvar Concepts = __webpack_require__(/*! ./Concepts */ \"(rsc)/./node_modules/clarifai/dist/Concepts.js\");\nvar Regions = __webpack_require__(/*! ./Regions */ \"(rsc)/./node_modules/clarifai/dist/Regions.js\");\n\nvar _require = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/clarifai/dist/constants.js\"),\n    API = _require.API;\n\nvar INPUTS_PATH = API.INPUTS_PATH;\n\n/**\n * class representing an input\n * @class\n */\n\nvar Input = function () {\n  function Input(_config, data) {\n    _classCallCheck(this, Input);\n\n    this.id = data.id;\n    this.createdAt = data.created_at || data.createdAt;\n    this.imageUrl = data.data.image.url;\n    this.concepts = new Concepts(_config, data.data.concepts);\n    this.regions = new Regions(_config, data.data.regions || []);\n    this.score = data.score;\n    this.metadata = data.data.metadata;\n    if (data.data.geo && data.data.geo['geo_point']) {\n      this.geo = { geoPoint: data.data.geo['geo_point'] };\n    }\n    this.rawData = data;\n    this._config = _config;\n  }\n\n  /**\n   * Merge concepts to an input\n   * @param {object[]}         concepts    Object with keys explained below:\n   *   @param {object}           concepts[].concept\n   *     @param {string}           concepts[].concept.id        The concept id (required)\n   *     @param {boolean}          concepts[].concept.value     Whether or not the input is a positive (true) or negative (false) example of the concept (default: true)\n   * @param {object}           metadata                      Object with key values to attach to the input (optional)\n   * @return {Promise(Input, error)} A Promise that is fulfilled with an instance of Input or rejected with an error\n   */\n\n\n  _createClass(Input, [{\n    key: 'mergeConcepts',\n    value: function mergeConcepts(concepts, metadata) {\n      return this._update('merge', concepts, metadata);\n    }\n\n    /**\n     * Delete concept from an input\n     * @param {object[]}         concepts    Object with keys explained below:\n     *   @param {object}           concepts[].concept\n     *     @param {string}           concepts[].concept.id        The concept id (required)\n     *     @param {boolean}          concepts[].concept.value     Whether or not the input is a positive (true) or negative (false) example of the concept (default: true)\n     * @param {object}           metadata                      Object with key values to attach to the input (optional)\n     * @return {Promise(Input, error)} A Promise that is fulfilled with an instance of Input or rejected with an error\n     */\n\n  }, {\n    key: 'deleteConcepts',\n    value: function deleteConcepts(concepts, metadata) {\n      return this._update('remove', concepts, metadata);\n    }\n\n    /**\n     * Overwrite inputs\n     * @param {object[]}         concepts                      Array of object with keys explained below:\n     *   @param {object}           concepts[].concept\n     *     @param {string}           concepts[].concept.id         The concept id (required)\n     *     @param {boolean}          concepts[].concept.value      Whether or not the input is a positive (true) or negative (false) example of the concept (default: true)\n     * @param {object}           metadata                      Object with key values to attach to the input (optional)\n     * @return {Promise(Input, error)} A Promise that is fulfilled with an instance of Input or rejected with an error\n     */\n\n  }, {\n    key: 'overwriteConcepts',\n    value: function overwriteConcepts(concepts, metadata) {\n      return this._update('overwrite', concepts, metadata);\n    }\n  }, {\n    key: '_update',\n    value: function _update(action) {\n      var concepts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var metadata = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n      var url = '' + this._config.basePath + INPUTS_PATH;\n      var inputData = {};\n      if (concepts.length) {\n        inputData.concepts = concepts;\n      }\n      if (metadata !== null) {\n        inputData.metadata = metadata;\n      }\n      var data = {\n        action: action,\n        inputs: [{\n          id: this.id,\n          data: inputData\n        }]\n      };\n      return wrapToken(this._config, function (headers) {\n        return new Promise(function (resolve, reject) {\n          return axios.patch(url, data, { headers: headers }).then(function (response) {\n            if (isSuccess(response)) {\n              resolve(new Input(response.data.input));\n            } else {\n              reject(response);\n            }\n          }, reject);\n        });\n      });\n    }\n  }]);\n\n  return Input;\n}();\n\n;\n\nmodule.exports = Input;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2xhcmlmYWkvZGlzdC9JbnB1dC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixpQ0FBaUMsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsK0RBQStELHlEQUF5RCxxRUFBcUUsNkRBQTZELHdCQUF3Qjs7QUFFampCLGtEQUFrRCwwQ0FBMEM7O0FBRTVGLFlBQVksbUJBQU8sQ0FBQyw2REFBTztBQUMzQixlQUFlLG1CQUFPLENBQUMsa0VBQVk7QUFDbkMsY0FBYyxtQkFBTyxDQUFDLGdFQUFXOztBQUVqQyxlQUFlLG1CQUFPLENBQUMsb0VBQWE7QUFDcEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CLGVBQWUsa0JBQWtCO0FBQ2pDLGlCQUFpQixrQkFBa0I7QUFDbkMsaUJBQWlCLGtCQUFrQjtBQUNuQyxhQUFhLGtCQUFrQjtBQUMvQixjQUFjLHVCQUF1QjtBQUNyQzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakMsaUJBQWlCLGtCQUFrQjtBQUNuQyxtQkFBbUIsa0JBQWtCO0FBQ3JDLG1CQUFtQixrQkFBa0I7QUFDckMsZUFBZSxrQkFBa0I7QUFDakMsZ0JBQWdCLHVCQUF1QjtBQUN2Qzs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDLGlCQUFpQixrQkFBa0I7QUFDbkMsbUJBQW1CLGtCQUFrQjtBQUNyQyxtQkFBbUIsa0JBQWtCO0FBQ3JDLGVBQWUsa0JBQWtCO0FBQ2pDLGdCQUFnQix1QkFBdUI7QUFDdkM7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxrQkFBa0I7QUFDNUQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZnJpZ2VyYXRvcl9hcHAvLi9ub2RlX21vZHVsZXMvY2xhcmlmYWkvZGlzdC9JbnB1dC5qcz82NGQyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIGF4aW9zID0gcmVxdWlyZSgnYXhpb3MnKTtcbnZhciBDb25jZXB0cyA9IHJlcXVpcmUoJy4vQ29uY2VwdHMnKTtcbnZhciBSZWdpb25zID0gcmVxdWlyZSgnLi9SZWdpb25zJyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyksXG4gICAgQVBJID0gX3JlcXVpcmUuQVBJO1xuXG52YXIgSU5QVVRTX1BBVEggPSBBUEkuSU5QVVRTX1BBVEg7XG5cbi8qKlxuICogY2xhc3MgcmVwcmVzZW50aW5nIGFuIGlucHV0XG4gKiBAY2xhc3NcbiAqL1xuXG52YXIgSW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIElucHV0KF9jb25maWcsIGRhdGEpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5wdXQpO1xuXG4gICAgdGhpcy5pZCA9IGRhdGEuaWQ7XG4gICAgdGhpcy5jcmVhdGVkQXQgPSBkYXRhLmNyZWF0ZWRfYXQgfHwgZGF0YS5jcmVhdGVkQXQ7XG4gICAgdGhpcy5pbWFnZVVybCA9IGRhdGEuZGF0YS5pbWFnZS51cmw7XG4gICAgdGhpcy5jb25jZXB0cyA9IG5ldyBDb25jZXB0cyhfY29uZmlnLCBkYXRhLmRhdGEuY29uY2VwdHMpO1xuICAgIHRoaXMucmVnaW9ucyA9IG5ldyBSZWdpb25zKF9jb25maWcsIGRhdGEuZGF0YS5yZWdpb25zIHx8IFtdKTtcbiAgICB0aGlzLnNjb3JlID0gZGF0YS5zY29yZTtcbiAgICB0aGlzLm1ldGFkYXRhID0gZGF0YS5kYXRhLm1ldGFkYXRhO1xuICAgIGlmIChkYXRhLmRhdGEuZ2VvICYmIGRhdGEuZGF0YS5nZW9bJ2dlb19wb2ludCddKSB7XG4gICAgICB0aGlzLmdlbyA9IHsgZ2VvUG9pbnQ6IGRhdGEuZGF0YS5nZW9bJ2dlb19wb2ludCddIH07XG4gICAgfVxuICAgIHRoaXMucmF3RGF0YSA9IGRhdGE7XG4gICAgdGhpcy5fY29uZmlnID0gX2NvbmZpZztcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZSBjb25jZXB0cyB0byBhbiBpbnB1dFxuICAgKiBAcGFyYW0ge29iamVjdFtdfSAgICAgICAgIGNvbmNlcHRzICAgIE9iamVjdCB3aXRoIGtleXMgZXhwbGFpbmVkIGJlbG93OlxuICAgKiAgIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICAgY29uY2VwdHNbXS5jb25jZXB0XG4gICAqICAgICBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgIGNvbmNlcHRzW10uY29uY2VwdC5pZCAgICAgICAgVGhlIGNvbmNlcHQgaWQgKHJlcXVpcmVkKVxuICAgKiAgICAgQHBhcmFtIHtib29sZWFufSAgICAgICAgICBjb25jZXB0c1tdLmNvbmNlcHQudmFsdWUgICAgIFdoZXRoZXIgb3Igbm90IHRoZSBpbnB1dCBpcyBhIHBvc2l0aXZlICh0cnVlKSBvciBuZWdhdGl2ZSAoZmFsc2UpIGV4YW1wbGUgb2YgdGhlIGNvbmNlcHQgKGRlZmF1bHQ6IHRydWUpXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICAgbWV0YWRhdGEgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0IHdpdGgga2V5IHZhbHVlcyB0byBhdHRhY2ggdG8gdGhlIGlucHV0IChvcHRpb25hbClcbiAgICogQHJldHVybiB7UHJvbWlzZShJbnB1dCwgZXJyb3IpfSBBIFByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2l0aCBhbiBpbnN0YW5jZSBvZiBJbnB1dCBvciByZWplY3RlZCB3aXRoIGFuIGVycm9yXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKElucHV0LCBbe1xuICAgIGtleTogJ21lcmdlQ29uY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtZXJnZUNvbmNlcHRzKGNvbmNlcHRzLCBtZXRhZGF0YSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZSgnbWVyZ2UnLCBjb25jZXB0cywgbWV0YWRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBjb25jZXB0IGZyb20gYW4gaW5wdXRcbiAgICAgKiBAcGFyYW0ge29iamVjdFtdfSAgICAgICAgIGNvbmNlcHRzICAgIE9iamVjdCB3aXRoIGtleXMgZXhwbGFpbmVkIGJlbG93OlxuICAgICAqICAgQHBhcmFtIHtvYmplY3R9ICAgICAgICAgICBjb25jZXB0c1tdLmNvbmNlcHRcbiAgICAgKiAgICAgQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICBjb25jZXB0c1tdLmNvbmNlcHQuaWQgICAgICAgIFRoZSBjb25jZXB0IGlkIChyZXF1aXJlZClcbiAgICAgKiAgICAgQHBhcmFtIHtib29sZWFufSAgICAgICAgICBjb25jZXB0c1tdLmNvbmNlcHQudmFsdWUgICAgIFdoZXRoZXIgb3Igbm90IHRoZSBpbnB1dCBpcyBhIHBvc2l0aXZlICh0cnVlKSBvciBuZWdhdGl2ZSAoZmFsc2UpIGV4YW1wbGUgb2YgdGhlIGNvbmNlcHQgKGRlZmF1bHQ6IHRydWUpXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICAgICBtZXRhZGF0YSAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qgd2l0aCBrZXkgdmFsdWVzIHRvIGF0dGFjaCB0byB0aGUgaW5wdXQgKG9wdGlvbmFsKVxuICAgICAqIEByZXR1cm4ge1Byb21pc2UoSW5wdXQsIGVycm9yKX0gQSBQcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdpdGggYW4gaW5zdGFuY2Ugb2YgSW5wdXQgb3IgcmVqZWN0ZWQgd2l0aCBhbiBlcnJvclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkZWxldGVDb25jZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZUNvbmNlcHRzKGNvbmNlcHRzLCBtZXRhZGF0YSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZSgncmVtb3ZlJywgY29uY2VwdHMsIG1ldGFkYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVyd3JpdGUgaW5wdXRzXG4gICAgICogQHBhcmFtIHtvYmplY3RbXX0gICAgICAgICBjb25jZXB0cyAgICAgICAgICAgICAgICAgICAgICBBcnJheSBvZiBvYmplY3Qgd2l0aCBrZXlzIGV4cGxhaW5lZCBiZWxvdzpcbiAgICAgKiAgIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICAgY29uY2VwdHNbXS5jb25jZXB0XG4gICAgICogICAgIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgY29uY2VwdHNbXS5jb25jZXB0LmlkICAgICAgICAgVGhlIGNvbmNlcHQgaWQgKHJlcXVpcmVkKVxuICAgICAqICAgICBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgIGNvbmNlcHRzW10uY29uY2VwdC52YWx1ZSAgICAgIFdoZXRoZXIgb3Igbm90IHRoZSBpbnB1dCBpcyBhIHBvc2l0aXZlICh0cnVlKSBvciBuZWdhdGl2ZSAoZmFsc2UpIGV4YW1wbGUgb2YgdGhlIGNvbmNlcHQgKGRlZmF1bHQ6IHRydWUpXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICAgICBtZXRhZGF0YSAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qgd2l0aCBrZXkgdmFsdWVzIHRvIGF0dGFjaCB0byB0aGUgaW5wdXQgKG9wdGlvbmFsKVxuICAgICAqIEByZXR1cm4ge1Byb21pc2UoSW5wdXQsIGVycm9yKX0gQSBQcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdpdGggYW4gaW5zdGFuY2Ugb2YgSW5wdXQgb3IgcmVqZWN0ZWQgd2l0aCBhbiBlcnJvclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdvdmVyd3JpdGVDb25jZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG92ZXJ3cml0ZUNvbmNlcHRzKGNvbmNlcHRzLCBtZXRhZGF0YSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZSgnb3ZlcndyaXRlJywgY29uY2VwdHMsIG1ldGFkYXRhKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfdXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZShhY3Rpb24pIHtcbiAgICAgIHZhciBjb25jZXB0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gICAgICB2YXIgbWV0YWRhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG5cbiAgICAgIHZhciB1cmwgPSAnJyArIHRoaXMuX2NvbmZpZy5iYXNlUGF0aCArIElOUFVUU19QQVRIO1xuICAgICAgdmFyIGlucHV0RGF0YSA9IHt9O1xuICAgICAgaWYgKGNvbmNlcHRzLmxlbmd0aCkge1xuICAgICAgICBpbnB1dERhdGEuY29uY2VwdHMgPSBjb25jZXB0cztcbiAgICAgIH1cbiAgICAgIGlmIChtZXRhZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICBpbnB1dERhdGEubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgIH1cbiAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgaW5wdXRzOiBbe1xuICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgIGRhdGE6IGlucHV0RGF0YVxuICAgICAgICB9XVxuICAgICAgfTtcbiAgICAgIHJldHVybiB3cmFwVG9rZW4odGhpcy5fY29uZmlnLCBmdW5jdGlvbiAoaGVhZGVycykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHJldHVybiBheGlvcy5wYXRjaCh1cmwsIGRhdGEsIHsgaGVhZGVyczogaGVhZGVycyB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKGlzU3VjY2VzcyhyZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShuZXcgSW5wdXQocmVzcG9uc2UuZGF0YS5pbnB1dCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVqZWN0KHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJbnB1dDtcbn0oKTtcblxuO1xuXG5tb2R1bGUuZXhwb3J0cyA9IElucHV0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/clarifai/dist/Input.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/clarifai/dist/Inputs.js":
/*!**********************************************!*\
  !*** ./node_modules/clarifai/dist/Inputs.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar axios = __webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\");\nvar Input = __webpack_require__(/*! ./Input */ \"(rsc)/./node_modules/clarifai/dist/Input.js\");\n\nvar _require = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/clarifai/dist/constants.js\"),\n    API = _require.API,\n    ERRORS = _require.ERRORS,\n    MAX_BATCH_SIZE = _require.MAX_BATCH_SIZE,\n    replaceVars = _require.replaceVars;\n\nvar INPUT_PATH = API.INPUT_PATH,\n    INPUTS_PATH = API.INPUTS_PATH,\n    INPUTS_STATUS_PATH = API.INPUTS_STATUS_PATH,\n    SEARCH_PATH = API.SEARCH_PATH,\n    SEARCH_FEEDBACK_PATH = API.SEARCH_FEEDBACK_PATH;\n\nvar _require2 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/clarifai/dist/utils.js\"),\n    wrapToken = _require2.wrapToken,\n    formatInput = _require2.formatInput,\n    formatImagesSearch = _require2.formatImagesSearch,\n    formatConceptsSearch = _require2.formatConceptsSearch;\n\nvar _require3 = __webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/clarifai/dist/helpers.js\"),\n    isSuccess = _require3.isSuccess,\n    checkType = _require3.checkType,\n    clone = _require3.clone;\n\n/**\n * class representing a collection of inputs\n * @class\n */\n\n\nvar Inputs = function () {\n  function Inputs(_config) {\n    var _this = this;\n\n    var rawData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    _classCallCheck(this, Inputs);\n\n    this.rawData = rawData;\n    rawData.forEach(function (inputData, index) {\n      if (inputData.input && inputData.score) {\n        inputData.input.score = inputData.score;\n        inputData = inputData.input;\n      }\n      _this[index] = new Input(_this._config, inputData);\n    });\n    this.length = rawData.length;\n    this._config = _config;\n  }\n\n  /**\n   * Get all inputs in app\n   * @param {Object}    options  Object with keys explained below: (optional)\n   *   @param {Number}    options.page  The page number (optional, default: 1)\n   *   @param {Number}    options.perPage  Number of images to return per page (optional, default: 20)\n   * @return {Promise(Inputs, error)} A Promise that is fulfilled with an instance of Inputs or rejected with an error\n   */\n\n\n  _createClass(Inputs, [{\n    key: 'list',\n    value: function list() {\n      var _this2 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { page: 1, perPage: 20 };\n\n      var url = '' + this._config.basePath + INPUTS_PATH;\n      return wrapToken(this._config, function (headers) {\n        return new Promise(function (resolve, reject) {\n          axios.get(url, {\n            headers: headers,\n            params: {\n              page: options.page,\n              per_page: options.perPage\n            }\n          }).then(function (response) {\n            if (isSuccess(response)) {\n              resolve(new Inputs(_this2._config, response.data.inputs));\n            } else {\n              reject(response);\n            }\n          }, reject);\n        });\n      });\n    }\n\n    /**\n     * Adds an input or multiple inputs\n     * @param {object|object[]}        inputs                                Can be a single media object or an array of media objects (max of 128 inputs/call; passing > 128 will throw an exception)\n     *   @param {object|string}          inputs[].input                        If string, is given, this is assumed to be an image url\n     *     @param {string}                 inputs[].input.(url|base64)           Can be a publicly accessibly url or base64 string representing image bytes (required)\n     *     @param {string}                 inputs[].input.id                     ID of input (optional)\n     *     @param {number[]}               inputs[].input.crop                   An array containing the percent to be cropped from top, left, bottom and right (optional)\n     *     @param {boolean}               inputs[].input.allowDuplicateUrl       Whether to allow duplicate URL\n     *     @param {object[]}               inputs[].input.metadata               Object with key and values pair (value can be string, array or other objects) to attach to the input (optional)\n     *     @param {object}                 inputs[].input.geo                    Object with latitude and longitude coordinates to associate with an input. Can be used in search query as the proximity of an input to a reference point (optional)\n     *       @param {number}                 inputs[].input.geo.latitude           +/- latitude val of geodata\n     *       @param {number}                 inputs[].input.geo.longitude          +/- longitude val of geodata\n     *     @param {object[]}               inputs[].input.concepts               An array of concepts to attach to media object (optional)\n     *       @param {object|string}          inputs[].input.concepts[].concept     If string, is given, this is assumed to be concept id with value equals true\n     *         @param {string}                 inputs[].input.concepts[].concept.id          The concept id (required)\n     *         @param {boolean}                inputs[].input.concepts[].concept.value       Whether or not the input is a positive (true) or negative (false) example of the concept (default: true)\n     * @return {Promise(Inputs, error)} A Promise that is fulfilled with an instance of Inputs or rejected with an error\n     */\n\n  }, {\n    key: 'create',\n    value: function create(inputs) {\n      var _this3 = this;\n\n      if (checkType(/(String|Object)/, inputs)) {\n        inputs = [inputs];\n      }\n      var url = '' + this._config.basePath + INPUTS_PATH;\n      if (inputs.length > MAX_BATCH_SIZE) {\n        throw ERRORS.MAX_INPUTS;\n      }\n      return wrapToken(this._config, function (headers) {\n        var data = {\n          inputs: inputs.map(formatInput)\n        };\n        return new Promise(function (resolve, reject) {\n          axios.post(url, data, { headers: headers }).then(function (response) {\n            if (isSuccess(response)) {\n              resolve(new Inputs(_this3._config, response.data.inputs));\n            } else {\n              reject(response);\n            }\n          }, reject);\n        });\n      });\n    }\n\n    /**\n     * Get input by id\n     * @param {String}    id  The input id\n     * @return {Promise(Input, error)} A Promise that is fulfilled with an instance of Input or rejected with an error\n     */\n\n  }, {\n    key: 'get',\n    value: function get(id) {\n      var _this4 = this;\n\n      var url = '' + this._config.basePath + replaceVars(INPUT_PATH, [id]);\n      return wrapToken(this._config, function (headers) {\n        return new Promise(function (resolve, reject) {\n          axios.get(url, { headers: headers }).then(function (response) {\n            if (isSuccess(response)) {\n              resolve(new Input(_this4._config, response.data.input));\n            } else {\n              reject(response);\n            }\n          }, reject);\n        });\n      });\n    }\n\n    /**\n     * Delete an input or a list of inputs by id or all inputs if no id is passed\n     * @param {string|string[]}    id           The id of input to delete (optional)\n     * @return {Promise(response, error)} A Promise that is fulfilled with the API response or rejected with an error\n     */\n\n  }, {\n    key: 'delete',\n    value: function _delete() {\n      var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      var val = void 0;\n      // delete an input\n      if (checkType(/String/, id)) {\n        var url = '' + this._config.basePath + replaceVars(INPUT_PATH, [id]);\n        val = wrapToken(this._config, function (headers) {\n          return axios.delete(url, { headers: headers });\n        });\n      } else {\n        val = this._deleteInputs(id);\n      }\n      return val;\n    }\n  }, {\n    key: '_deleteInputs',\n    value: function _deleteInputs() {\n      var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      var url = '' + this._config.basePath + INPUTS_PATH;\n      return wrapToken(this._config, function (headers) {\n        var data = id === null ? { delete_all: true } : { ids: id };\n        return axios({\n          url: url,\n          method: 'delete',\n          headers: headers,\n          data: data\n        });\n      });\n    }\n\n    /**\n     * Merge concepts to inputs in bulk\n     * @param {object[]}         inputs    List of concepts to update (max of 128 inputs/call; passing > 128 will throw an exception)\n     *   @param {object}           inputs[].input\n     *     @param {string}           inputs[].input.id        The id of the input to update\n     *     @param {string}           inputs[].input.concepts  Object with keys explained below:\n     *       @param {object}           inputs[].input.concepts[].concept\n     *         @param {string}           inputs[].input.concepts[].concept.id        The concept id (required)\n     *         @param {boolean}          inputs[].input.concepts[].concept.value     Whether or not the input is a positive (true) or negative (false) example of the concept (default: true)\n     * @return {Promise(Inputs, error)} A Promise that is fulfilled with an instance of Inputs or rejected with an error\n     */\n\n  }, {\n    key: 'mergeConcepts',\n    value: function mergeConcepts(inputs) {\n      inputs.action = 'merge';\n      return this.update(inputs);\n    }\n\n    /**\n     * Delete concepts to inputs in bulk\n     * @param {object[]}         inputs    List of concepts to update (max of 128 inputs/call; passing > 128 will throw an exception)\n     *   @param {object}           inputs[].input\n     *     @param {string}           inputs[].input.id                           The id of the input to update\n     *     @param {string}           inputs[].input.concepts                     Object with keys explained below:\n     *       @param {object}           inputs[].input.concepts[].concept\n     *         @param {string}           inputs[].input.concepts[].concept.id        The concept id (required)\n     *         @param {boolean}          inputs[].input.concepts[].concept.value     Whether or not the input is a positive (true) or negative (false) example of the concept (default: true)\n     * @return {Promise(Inputs, error)} A Promise that is fulfilled with an instance of Inputs or rejected with an error\n     */\n\n  }, {\n    key: 'deleteConcepts',\n    value: function deleteConcepts(inputs) {\n      inputs.action = 'remove';\n      return this.update(inputs);\n    }\n\n    /**\n     * Overwrite inputs in bulk\n     * @param {object[]}         inputs    List of concepts to update (max of 128 inputs/call; passing > 128 will throw an exception)\n     *   @param {object}           inputs[].input\n     *     @param {string}           inputs[].input.id                           The id of the input to update\n     *     @param {string}           inputs[].input.concepts                     Object with keys explained below:\n     *       @param {object}           inputs[].input.concepts[].concept\n     *         @param {string}           inputs[].input.concepts[].concept.id        The concept id (required)\n     *         @param {boolean}          inputs[].input.concepts[].concept.value     Whether or not the input is a positive (true) or negative (false) example of the concept (default: true)\n     * @return {Promise(Inputs, error)} A Promise that is fulfilled with an instance of Inputs or rejected with an error\n     */\n\n  }, {\n    key: 'overwriteConcepts',\n    value: function overwriteConcepts(inputs) {\n      inputs.action = 'overwrite';\n      return this.update(inputs);\n    }\n\n    /**\n     * @param {object[]}         inputs    List of inputs to update (max of 128 inputs/call; passing > 128 will throw an exception)\n     *   @param {object}           inputs[].input\n     *     @param {string}           inputs[].input.id                           The id of the input to update\n     *     @param {object}           inputs[].input.metadata                     Object with key values to attach to the input (optional)\n     *     @param {object}           inputs[].input.geo                          Object with latitude and longitude coordinates to associate with an input. Can be used in search query as the proximity of an input to a reference point (optional)\n     *       @param {number}           inputs[].input.geo.latitude                 +/- latitude val of geodata\n     *       @param {number}           inputs[].input.geo.longitude                +/- longitude val of geodata\n     *     @param {string}           inputs[].input.concepts                     Object with keys explained below (optional):\n     *       @param {object}           inputs[].input.concepts[].concept\n     *         @param {string}           inputs[].input.concepts[].concept.id        The concept id (required)\n     *         @param {boolean}          inputs[].input.concepts[].concept.value     Whether or not the input is a positive (true) or negative (false) example of the concept (default: true)\n     * @return {Promise(Inputs, error)} A Promise that is fulfilled with an instance of Inputs or rejected with an error\n     */\n\n  }, {\n    key: 'update',\n    value: function update(inputs) {\n      var _this5 = this;\n\n      var url = '' + this._config.basePath + INPUTS_PATH;\n      var inputsList = Array.isArray(inputs) ? inputs : [inputs];\n      if (inputsList.length > MAX_BATCH_SIZE) {\n        throw ERRORS.MAX_INPUTS;\n      }\n      var data = {\n        action: inputs.action,\n        inputs: inputsList.map(function (input) {\n          return formatInput(input, false);\n        })\n      };\n      return wrapToken(this._config, function (headers) {\n        return new Promise(function (resolve, reject) {\n          axios.patch(url, data, { headers: headers }).then(function (response) {\n            if (isSuccess(response)) {\n              resolve(new Inputs(_this5._config, response.data.inputs));\n            } else {\n              reject(response);\n            }\n          }, reject);\n        });\n      });\n    }\n\n    /**\n     * Search for inputs or outputs based on concepts or images\n     *   @param {object[]}               queries          List of all predictions to match with\n     *     @param {object}                 queries[].concept            An object with the following keys:\n     *       @param {string}                 queries[].concept.id          The concept id\n     *       @param {string}                 queries[].concept.type        Search over 'input' to get input matches to criteria or 'output' to get inputs that are visually similar to the criteria (default: 'output')\n     *       @param {string}                 queries[].concept.name        The concept name\n     *       @param {boolean}                queries[].concept.value       Indicates whether or not the term should match with the prediction returned (default: true)\n     *     @param {object}                 queries[].input              An image object that contains the following keys:\n     *       @param {string}                 queries[].input.id            The input id\n     *       @param {string}                 queries[].input.type          Search over 'input' to get input matches to criteria or 'output' to get inputs that are visually similar to the criteria (default: 'output')\n     *       @param {string}                 queries[].input.(base64|url)  Can be a publicly accessibly url or base64 string representing image bytes (required)\n     *       @param {number[]}               queries[].input.crop          An array containing the percent to be cropped from top, left, bottom and right (optional)\n     *       @param {object}                 queries[].input.metadata      An object with key and value specified by user to refine search with (optional)\n     * @param {Object}                   options       Object with keys explained below: (optional)\n     *    @param {Number}                  options.page          The page number (optional, default: 1)\n     *    @param {Number}                  options.perPage       Number of images to return per page (optional, default: 20)\n     * @return {Promise(response, error)} A Promise that is fulfilled with the API response or rejected with an error\n     */\n\n  }, {\n    key: 'search',\n    value: function search() {\n      var queries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { page: 1, perPage: 20 };\n\n      var formattedAnds = [];\n      var url = '' + this._config.basePath + SEARCH_PATH;\n      var data = {\n        query: {\n          ands: []\n        },\n        pagination: {\n          page: options.page,\n          per_page: options.perPage\n        }\n      };\n\n      if (!Array.isArray(queries)) {\n        queries = [queries];\n      }\n      if (queries.length > 0) {\n        queries.forEach(function (query) {\n          if (query.input) {\n            formattedAnds = formattedAnds.concat(formatImagesSearch(query.input));\n          } else if (query.concept) {\n            formattedAnds = formattedAnds.concat(formatConceptsSearch(query.concept));\n          }\n        });\n        data.query.ands = formattedAnds;\n      }\n      return wrapToken(this._config, function (headers) {\n        return new Promise(function (resolve, reject) {\n          axios.post(url, data, { headers: headers }).then(function (response) {\n            if (isSuccess(response)) {\n              var _data = clone(response.data);\n              _data.rawData = clone(response.data);\n              resolve(_data);\n            } else {\n              reject(response);\n            }\n          }, reject);\n        });\n      });\n    }\n  }, {\n    key: 'searchFeedback',\n    value: function searchFeedback(inputID, searchID, endUserID, sessionID) {\n      var url = '' + this._config.basePath + SEARCH_FEEDBACK_PATH;\n      var body = {\n        input: {\n          id: inputID,\n          feedback_info: {\n            event_type: 'search_click',\n            search_id: searchID,\n            end_user_id: endUserID,\n            session_id: sessionID\n          }\n        }\n      };\n      return wrapToken(this._config, function (headers) {\n        return new Promise(function (resolve, reject) {\n          axios.post(url, body, {\n            headers: headers\n          }).then(function (_ref) {\n            var data = _ref.data;\n\n            var d = clone(data);\n            d.rawData = clone(data);\n            resolve(d);\n          }, reject);\n        });\n      });\n    }\n\n    /**\n     * Get inputs status (number of uploaded, in process or failed inputs)\n     * @return {Promise(response, error)} A Promise that is fulfilled with the API response or rejected with an error\n     */\n\n  }, {\n    key: 'getStatus',\n    value: function getStatus() {\n      var url = '' + this._config.basePath + INPUTS_STATUS_PATH;\n      return wrapToken(this._config, function (headers) {\n        return new Promise(function (resolve, reject) {\n          axios.get(url, { headers: headers }).then(function (response) {\n            if (isSuccess(response)) {\n              var data = clone(response.data);\n              data.rawData = clone(response.data);\n              resolve(data);\n            } else {\n              reject(response);\n            }\n          }, reject);\n        });\n      });\n    }\n  }]);\n\n  return Inputs;\n}();\n\n;\n\nmodule.exports = Inputs;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2xhcmlmYWkvZGlzdC9JbnB1dHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsaUNBQWlDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELCtEQUErRCx5REFBeUQscUVBQXFFLDZEQUE2RCx3QkFBd0I7O0FBRWpqQixrREFBa0QsMENBQTBDOztBQUU1RixZQUFZLG1CQUFPLENBQUMsNkRBQU87QUFDM0IsWUFBWSxtQkFBTyxDQUFDLDREQUFTOztBQUU3QixlQUFlLG1CQUFPLENBQUMsb0VBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsbUJBQU8sQ0FBQyw0REFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsbUJBQU8sQ0FBQyxnRUFBVztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QixlQUFlLFdBQVc7QUFDMUIsZUFBZSxXQUFXO0FBQzFCLGNBQWMsd0JBQXdCO0FBQ3RDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwRkFBMEY7O0FBRTFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSx3QkFBd0IseUhBQXlIO0FBQ2hLLGlCQUFpQix3QkFBd0I7QUFDekMsbUJBQW1CLHdCQUF3QjtBQUMzQyxtQkFBbUIsd0JBQXdCO0FBQzNDLG1CQUFtQix3QkFBd0I7QUFDM0MsbUJBQW1CLHVCQUF1QjtBQUMxQyxtQkFBbUIsd0JBQXdCO0FBQzNDLG1CQUFtQix3QkFBd0I7QUFDM0MscUJBQXFCLHdCQUF3QjtBQUM3QyxxQkFBcUIsd0JBQXdCO0FBQzdDLG1CQUFtQix3QkFBd0I7QUFDM0MscUJBQXFCLHdCQUF3QjtBQUM3Qyx1QkFBdUIsd0JBQXdCO0FBQy9DLHVCQUF1Qix3QkFBd0I7QUFDL0MsZ0JBQWdCLHdCQUF3QjtBQUN4Qzs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrQkFBa0I7QUFDcEQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixnQkFBZ0IsdUJBQXVCO0FBQ3ZDOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZ0JBQWdCLDBCQUEwQjtBQUMxQzs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCO0FBQ3ZELFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsbUJBQW1CLElBQUk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLGVBQWUsa0JBQWtCLDhEQUE4RDtBQUMvRixpQkFBaUIsa0JBQWtCO0FBQ25DLG1CQUFtQixrQkFBa0I7QUFDckMsbUJBQW1CLGtCQUFrQjtBQUNyQyxxQkFBcUIsa0JBQWtCO0FBQ3ZDLHVCQUF1QixrQkFBa0I7QUFDekMsdUJBQXVCLGtCQUFrQjtBQUN6QyxnQkFBZ0Isd0JBQXdCO0FBQ3hDOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQiw4REFBOEQ7QUFDL0YsaUJBQWlCLGtCQUFrQjtBQUNuQyxtQkFBbUIsa0JBQWtCO0FBQ3JDLG1CQUFtQixrQkFBa0I7QUFDckMscUJBQXFCLGtCQUFrQjtBQUN2Qyx1QkFBdUIsa0JBQWtCO0FBQ3pDLHVCQUF1QixrQkFBa0I7QUFDekMsZ0JBQWdCLHdCQUF3QjtBQUN4Qzs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0IsOERBQThEO0FBQy9GLGlCQUFpQixrQkFBa0I7QUFDbkMsbUJBQW1CLGtCQUFrQjtBQUNyQyxtQkFBbUIsa0JBQWtCO0FBQ3JDLHFCQUFxQixrQkFBa0I7QUFDdkMsdUJBQXVCLGtCQUFrQjtBQUN6Qyx1QkFBdUIsa0JBQWtCO0FBQ3pDLGdCQUFnQix3QkFBd0I7QUFDeEM7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGtCQUFrQiw0REFBNEQ7QUFDN0YsaUJBQWlCLGtCQUFrQjtBQUNuQyxtQkFBbUIsa0JBQWtCO0FBQ3JDLG1CQUFtQixrQkFBa0I7QUFDckMsbUJBQW1CLGtCQUFrQjtBQUNyQyxxQkFBcUIsa0JBQWtCO0FBQ3ZDLHFCQUFxQixrQkFBa0I7QUFDdkMsbUJBQW1CLGtCQUFrQjtBQUNyQyxxQkFBcUIsa0JBQWtCO0FBQ3ZDLHVCQUF1QixrQkFBa0I7QUFDekMsdUJBQXVCLGtCQUFrQjtBQUN6QyxnQkFBZ0Isd0JBQXdCO0FBQ3hDOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrQkFBa0I7QUFDckQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQix3QkFBd0I7QUFDekMsbUJBQW1CLHdCQUF3QjtBQUMzQyxxQkFBcUIsd0JBQXdCO0FBQzdDLHFCQUFxQix3QkFBd0I7QUFDN0MscUJBQXFCLHdCQUF3QjtBQUM3QyxxQkFBcUIsd0JBQXdCO0FBQzdDLG1CQUFtQix3QkFBd0I7QUFDM0MscUJBQXFCLHdCQUF3QjtBQUM3QyxxQkFBcUIsd0JBQXdCO0FBQzdDLHFCQUFxQix3QkFBd0I7QUFDN0MscUJBQXFCLHdCQUF3QjtBQUM3QyxxQkFBcUIsd0JBQXdCO0FBQzdDLGVBQWUsMEJBQTBCO0FBQ3pDLGtCQUFrQix5QkFBeUI7QUFDM0Msa0JBQWtCLHlCQUF5QjtBQUMzQyxnQkFBZ0IsMEJBQTBCO0FBQzFDOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSwwRkFBMEY7O0FBRTFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtCQUFrQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBCO0FBQzFDOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZnJpZ2VyYXRvcl9hcHAvLi9ub2RlX21vZHVsZXMvY2xhcmlmYWkvZGlzdC9JbnB1dHMuanM/NmE0YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBheGlvcyA9IHJlcXVpcmUoJ2F4aW9zJyk7XG52YXIgSW5wdXQgPSByZXF1aXJlKCcuL0lucHV0Jyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyksXG4gICAgQVBJID0gX3JlcXVpcmUuQVBJLFxuICAgIEVSUk9SUyA9IF9yZXF1aXJlLkVSUk9SUyxcbiAgICBNQVhfQkFUQ0hfU0laRSA9IF9yZXF1aXJlLk1BWF9CQVRDSF9TSVpFLFxuICAgIHJlcGxhY2VWYXJzID0gX3JlcXVpcmUucmVwbGFjZVZhcnM7XG5cbnZhciBJTlBVVF9QQVRIID0gQVBJLklOUFVUX1BBVEgsXG4gICAgSU5QVVRTX1BBVEggPSBBUEkuSU5QVVRTX1BBVEgsXG4gICAgSU5QVVRTX1NUQVRVU19QQVRIID0gQVBJLklOUFVUU19TVEFUVVNfUEFUSCxcbiAgICBTRUFSQ0hfUEFUSCA9IEFQSS5TRUFSQ0hfUEFUSCxcbiAgICBTRUFSQ0hfRkVFREJBQ0tfUEFUSCA9IEFQSS5TRUFSQ0hfRkVFREJBQ0tfUEFUSDtcblxudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoJy4vdXRpbHMnKSxcbiAgICB3cmFwVG9rZW4gPSBfcmVxdWlyZTIud3JhcFRva2VuLFxuICAgIGZvcm1hdElucHV0ID0gX3JlcXVpcmUyLmZvcm1hdElucHV0LFxuICAgIGZvcm1hdEltYWdlc1NlYXJjaCA9IF9yZXF1aXJlMi5mb3JtYXRJbWFnZXNTZWFyY2gsXG4gICAgZm9ybWF0Q29uY2VwdHNTZWFyY2ggPSBfcmVxdWlyZTIuZm9ybWF0Q29uY2VwdHNTZWFyY2g7XG5cbnZhciBfcmVxdWlyZTMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKSxcbiAgICBpc1N1Y2Nlc3MgPSBfcmVxdWlyZTMuaXNTdWNjZXNzLFxuICAgIGNoZWNrVHlwZSA9IF9yZXF1aXJlMy5jaGVja1R5cGUsXG4gICAgY2xvbmUgPSBfcmVxdWlyZTMuY2xvbmU7XG5cbi8qKlxuICogY2xhc3MgcmVwcmVzZW50aW5nIGEgY29sbGVjdGlvbiBvZiBpbnB1dHNcbiAqIEBjbGFzc1xuICovXG5cblxudmFyIElucHV0cyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSW5wdXRzKF9jb25maWcpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHJhd0RhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIElucHV0cyk7XG5cbiAgICB0aGlzLnJhd0RhdGEgPSByYXdEYXRhO1xuICAgIHJhd0RhdGEuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXREYXRhLCBpbmRleCkge1xuICAgICAgaWYgKGlucHV0RGF0YS5pbnB1dCAmJiBpbnB1dERhdGEuc2NvcmUpIHtcbiAgICAgICAgaW5wdXREYXRhLmlucHV0LnNjb3JlID0gaW5wdXREYXRhLnNjb3JlO1xuICAgICAgICBpbnB1dERhdGEgPSBpbnB1dERhdGEuaW5wdXQ7XG4gICAgICB9XG4gICAgICBfdGhpc1tpbmRleF0gPSBuZXcgSW5wdXQoX3RoaXMuX2NvbmZpZywgaW5wdXREYXRhKTtcbiAgICB9KTtcbiAgICB0aGlzLmxlbmd0aCA9IHJhd0RhdGEubGVuZ3RoO1xuICAgIHRoaXMuX2NvbmZpZyA9IF9jb25maWc7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBpbnB1dHMgaW4gYXBwXG4gICAqIEBwYXJhbSB7T2JqZWN0fSAgICBvcHRpb25zICBPYmplY3Qgd2l0aCBrZXlzIGV4cGxhaW5lZCBiZWxvdzogKG9wdGlvbmFsKVxuICAgKiAgIEBwYXJhbSB7TnVtYmVyfSAgICBvcHRpb25zLnBhZ2UgIFRoZSBwYWdlIG51bWJlciAob3B0aW9uYWwsIGRlZmF1bHQ6IDEpXG4gICAqICAgQHBhcmFtIHtOdW1iZXJ9ICAgIG9wdGlvbnMucGVyUGFnZSAgTnVtYmVyIG9mIGltYWdlcyB0byByZXR1cm4gcGVyIHBhZ2UgKG9wdGlvbmFsLCBkZWZhdWx0OiAyMClcbiAgICogQHJldHVybiB7UHJvbWlzZShJbnB1dHMsIGVycm9yKX0gQSBQcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdpdGggYW4gaW5zdGFuY2Ugb2YgSW5wdXRzIG9yIHJlamVjdGVkIHdpdGggYW4gZXJyb3JcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoSW5wdXRzLCBbe1xuICAgIGtleTogJ2xpc3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaXN0KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7IHBhZ2U6IDEsIHBlclBhZ2U6IDIwIH07XG5cbiAgICAgIHZhciB1cmwgPSAnJyArIHRoaXMuX2NvbmZpZy5iYXNlUGF0aCArIElOUFVUU19QQVRIO1xuICAgICAgcmV0dXJuIHdyYXBUb2tlbih0aGlzLl9jb25maWcsIGZ1bmN0aW9uIChoZWFkZXJzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgYXhpb3MuZ2V0KHVybCwge1xuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICBwYWdlOiBvcHRpb25zLnBhZ2UsXG4gICAgICAgICAgICAgIHBlcl9wYWdlOiBvcHRpb25zLnBlclBhZ2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKGlzU3VjY2VzcyhyZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShuZXcgSW5wdXRzKF90aGlzMi5fY29uZmlnLCByZXNwb25zZS5kYXRhLmlucHV0cykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVqZWN0KHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gaW5wdXQgb3IgbXVsdGlwbGUgaW5wdXRzXG4gICAgICogQHBhcmFtIHtvYmplY3R8b2JqZWN0W119ICAgICAgICBpbnB1dHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENhbiBiZSBhIHNpbmdsZSBtZWRpYSBvYmplY3Qgb3IgYW4gYXJyYXkgb2YgbWVkaWEgb2JqZWN0cyAobWF4IG9mIDEyOCBpbnB1dHMvY2FsbDsgcGFzc2luZyA+IDEyOCB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbilcbiAgICAgKiAgIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gICAgICAgICAgaW5wdXRzW10uaW5wdXQgICAgICAgICAgICAgICAgICAgICAgICBJZiBzdHJpbmcsIGlzIGdpdmVuLCB0aGlzIGlzIGFzc3VtZWQgdG8gYmUgYW4gaW1hZ2UgdXJsXG4gICAgICogICAgIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgaW5wdXRzW10uaW5wdXQuKHVybHxiYXNlNjQpICAgICAgICAgICBDYW4gYmUgYSBwdWJsaWNseSBhY2Nlc3NpYmx5IHVybCBvciBiYXNlNjQgc3RyaW5nIHJlcHJlc2VudGluZyBpbWFnZSBieXRlcyAocmVxdWlyZWQpXG4gICAgICogICAgIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgaW5wdXRzW10uaW5wdXQuaWQgICAgICAgICAgICAgICAgICAgICBJRCBvZiBpbnB1dCAob3B0aW9uYWwpXG4gICAgICogICAgIEBwYXJhbSB7bnVtYmVyW119ICAgICAgICAgICAgICAgaW5wdXRzW10uaW5wdXQuY3JvcCAgICAgICAgICAgICAgICAgICBBbiBhcnJheSBjb250YWluaW5nIHRoZSBwZXJjZW50IHRvIGJlIGNyb3BwZWQgZnJvbSB0b3AsIGxlZnQsIGJvdHRvbSBhbmQgcmlnaHQgKG9wdGlvbmFsKVxuICAgICAqICAgICBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgICAgICAgaW5wdXRzW10uaW5wdXQuYWxsb3dEdXBsaWNhdGVVcmwgICAgICAgV2hldGhlciB0byBhbGxvdyBkdXBsaWNhdGUgVVJMXG4gICAgICogICAgIEBwYXJhbSB7b2JqZWN0W119ICAgICAgICAgICAgICAgaW5wdXRzW10uaW5wdXQubWV0YWRhdGEgICAgICAgICAgICAgICBPYmplY3Qgd2l0aCBrZXkgYW5kIHZhbHVlcyBwYWlyICh2YWx1ZSBjYW4gYmUgc3RyaW5nLCBhcnJheSBvciBvdGhlciBvYmplY3RzKSB0byBhdHRhY2ggdG8gdGhlIGlucHV0IChvcHRpb25hbClcbiAgICAgKiAgICAgQHBhcmFtIHtvYmplY3R9ICAgICAgICAgICAgICAgICBpbnB1dHNbXS5pbnB1dC5nZW8gICAgICAgICAgICAgICAgICAgIE9iamVjdCB3aXRoIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUgY29vcmRpbmF0ZXMgdG8gYXNzb2NpYXRlIHdpdGggYW4gaW5wdXQuIENhbiBiZSB1c2VkIGluIHNlYXJjaCBxdWVyeSBhcyB0aGUgcHJveGltaXR5IG9mIGFuIGlucHV0IHRvIGEgcmVmZXJlbmNlIHBvaW50IChvcHRpb25hbClcbiAgICAgKiAgICAgICBAcGFyYW0ge251bWJlcn0gICAgICAgICAgICAgICAgIGlucHV0c1tdLmlucHV0Lmdlby5sYXRpdHVkZSAgICAgICAgICAgKy8tIGxhdGl0dWRlIHZhbCBvZiBnZW9kYXRhXG4gICAgICogICAgICAgQHBhcmFtIHtudW1iZXJ9ICAgICAgICAgICAgICAgICBpbnB1dHNbXS5pbnB1dC5nZW8ubG9uZ2l0dWRlICAgICAgICAgICsvLSBsb25naXR1ZGUgdmFsIG9mIGdlb2RhdGFcbiAgICAgKiAgICAgQHBhcmFtIHtvYmplY3RbXX0gICAgICAgICAgICAgICBpbnB1dHNbXS5pbnB1dC5jb25jZXB0cyAgICAgICAgICAgICAgIEFuIGFycmF5IG9mIGNvbmNlcHRzIHRvIGF0dGFjaCB0byBtZWRpYSBvYmplY3QgKG9wdGlvbmFsKVxuICAgICAqICAgICAgIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gICAgICAgICAgaW5wdXRzW10uaW5wdXQuY29uY2VwdHNbXS5jb25jZXB0ICAgICBJZiBzdHJpbmcsIGlzIGdpdmVuLCB0aGlzIGlzIGFzc3VtZWQgdG8gYmUgY29uY2VwdCBpZCB3aXRoIHZhbHVlIGVxdWFscyB0cnVlXG4gICAgICogICAgICAgICBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgIGlucHV0c1tdLmlucHV0LmNvbmNlcHRzW10uY29uY2VwdC5pZCAgICAgICAgICBUaGUgY29uY2VwdCBpZCAocmVxdWlyZWQpXG4gICAgICogICAgICAgICBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgICAgICAgIGlucHV0c1tdLmlucHV0LmNvbmNlcHRzW10uY29uY2VwdC52YWx1ZSAgICAgICBXaGV0aGVyIG9yIG5vdCB0aGUgaW5wdXQgaXMgYSBwb3NpdGl2ZSAodHJ1ZSkgb3IgbmVnYXRpdmUgKGZhbHNlKSBleGFtcGxlIG9mIHRoZSBjb25jZXB0IChkZWZhdWx0OiB0cnVlKVxuICAgICAqIEByZXR1cm4ge1Byb21pc2UoSW5wdXRzLCBlcnJvcil9IEEgUHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aXRoIGFuIGluc3RhbmNlIG9mIElucHV0cyBvciByZWplY3RlZCB3aXRoIGFuIGVycm9yXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NyZWF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZShpbnB1dHMpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBpZiAoY2hlY2tUeXBlKC8oU3RyaW5nfE9iamVjdCkvLCBpbnB1dHMpKSB7XG4gICAgICAgIGlucHV0cyA9IFtpbnB1dHNdO1xuICAgICAgfVxuICAgICAgdmFyIHVybCA9ICcnICsgdGhpcy5fY29uZmlnLmJhc2VQYXRoICsgSU5QVVRTX1BBVEg7XG4gICAgICBpZiAoaW5wdXRzLmxlbmd0aCA+IE1BWF9CQVRDSF9TSVpFKSB7XG4gICAgICAgIHRocm93IEVSUk9SUy5NQVhfSU5QVVRTO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBUb2tlbih0aGlzLl9jb25maWcsIGZ1bmN0aW9uIChoZWFkZXJzKSB7XG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgIGlucHV0czogaW5wdXRzLm1hcChmb3JtYXRJbnB1dClcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBheGlvcy5wb3N0KHVybCwgZGF0YSwgeyBoZWFkZXJzOiBoZWFkZXJzIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAoaXNTdWNjZXNzKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICByZXNvbHZlKG5ldyBJbnB1dHMoX3RoaXMzLl9jb25maWcsIHJlc3BvbnNlLmRhdGEuaW5wdXRzKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWplY3QocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGlucHV0IGJ5IGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgIGlkICBUaGUgaW5wdXQgaWRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlKElucHV0LCBlcnJvcil9IEEgUHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aXRoIGFuIGluc3RhbmNlIG9mIElucHV0IG9yIHJlamVjdGVkIHdpdGggYW4gZXJyb3JcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KGlkKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIHVybCA9ICcnICsgdGhpcy5fY29uZmlnLmJhc2VQYXRoICsgcmVwbGFjZVZhcnMoSU5QVVRfUEFUSCwgW2lkXSk7XG4gICAgICByZXR1cm4gd3JhcFRva2VuKHRoaXMuX2NvbmZpZywgZnVuY3Rpb24gKGhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBheGlvcy5nZXQodXJsLCB7IGhlYWRlcnM6IGhlYWRlcnMgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChpc1N1Y2Nlc3MocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUobmV3IElucHV0KF90aGlzNC5fY29uZmlnLCByZXNwb25zZS5kYXRhLmlucHV0KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWplY3QocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIGFuIGlucHV0IG9yIGEgbGlzdCBvZiBpbnB1dHMgYnkgaWQgb3IgYWxsIGlucHV0cyBpZiBubyBpZCBpcyBwYXNzZWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gICAgaWQgICAgICAgICAgIFRoZSBpZCBvZiBpbnB1dCB0byBkZWxldGUgKG9wdGlvbmFsKVxuICAgICAqIEByZXR1cm4ge1Byb21pc2UocmVzcG9uc2UsIGVycm9yKX0gQSBQcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdpdGggdGhlIEFQSSByZXNwb25zZSBvciByZWplY3RlZCB3aXRoIGFuIGVycm9yXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RlbGV0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWxldGUoKSB7XG4gICAgICB2YXIgaWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG5cbiAgICAgIHZhciB2YWwgPSB2b2lkIDA7XG4gICAgICAvLyBkZWxldGUgYW4gaW5wdXRcbiAgICAgIGlmIChjaGVja1R5cGUoL1N0cmluZy8sIGlkKSkge1xuICAgICAgICB2YXIgdXJsID0gJycgKyB0aGlzLl9jb25maWcuYmFzZVBhdGggKyByZXBsYWNlVmFycyhJTlBVVF9QQVRILCBbaWRdKTtcbiAgICAgICAgdmFsID0gd3JhcFRva2VuKHRoaXMuX2NvbmZpZywgZnVuY3Rpb24gKGhlYWRlcnMpIHtcbiAgICAgICAgICByZXR1cm4gYXhpb3MuZGVsZXRlKHVybCwgeyBoZWFkZXJzOiBoZWFkZXJzIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IHRoaXMuX2RlbGV0ZUlucHV0cyhpZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19kZWxldGVJbnB1dHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVsZXRlSW5wdXRzKCkge1xuICAgICAgdmFyIGlkID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuXG4gICAgICB2YXIgdXJsID0gJycgKyB0aGlzLl9jb25maWcuYmFzZVBhdGggKyBJTlBVVFNfUEFUSDtcbiAgICAgIHJldHVybiB3cmFwVG9rZW4odGhpcy5fY29uZmlnLCBmdW5jdGlvbiAoaGVhZGVycykge1xuICAgICAgICB2YXIgZGF0YSA9IGlkID09PSBudWxsID8geyBkZWxldGVfYWxsOiB0cnVlIH0gOiB7IGlkczogaWQgfTtcbiAgICAgICAgcmV0dXJuIGF4aW9zKHtcbiAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICBtZXRob2Q6ICdkZWxldGUnLFxuICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1lcmdlIGNvbmNlcHRzIHRvIGlucHV0cyBpbiBidWxrXG4gICAgICogQHBhcmFtIHtvYmplY3RbXX0gICAgICAgICBpbnB1dHMgICAgTGlzdCBvZiBjb25jZXB0cyB0byB1cGRhdGUgKG1heCBvZiAxMjggaW5wdXRzL2NhbGw7IHBhc3NpbmcgPiAxMjggd2lsbCB0aHJvdyBhbiBleGNlcHRpb24pXG4gICAgICogICBAcGFyYW0ge29iamVjdH0gICAgICAgICAgIGlucHV0c1tdLmlucHV0XG4gICAgICogICAgIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgaW5wdXRzW10uaW5wdXQuaWQgICAgICAgIFRoZSBpZCBvZiB0aGUgaW5wdXQgdG8gdXBkYXRlXG4gICAgICogICAgIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgaW5wdXRzW10uaW5wdXQuY29uY2VwdHMgIE9iamVjdCB3aXRoIGtleXMgZXhwbGFpbmVkIGJlbG93OlxuICAgICAqICAgICAgIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICAgaW5wdXRzW10uaW5wdXQuY29uY2VwdHNbXS5jb25jZXB0XG4gICAgICogICAgICAgICBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgIGlucHV0c1tdLmlucHV0LmNvbmNlcHRzW10uY29uY2VwdC5pZCAgICAgICAgVGhlIGNvbmNlcHQgaWQgKHJlcXVpcmVkKVxuICAgICAqICAgICAgICAgQHBhcmFtIHtib29sZWFufSAgICAgICAgICBpbnB1dHNbXS5pbnB1dC5jb25jZXB0c1tdLmNvbmNlcHQudmFsdWUgICAgIFdoZXRoZXIgb3Igbm90IHRoZSBpbnB1dCBpcyBhIHBvc2l0aXZlICh0cnVlKSBvciBuZWdhdGl2ZSAoZmFsc2UpIGV4YW1wbGUgb2YgdGhlIGNvbmNlcHQgKGRlZmF1bHQ6IHRydWUpXG4gICAgICogQHJldHVybiB7UHJvbWlzZShJbnB1dHMsIGVycm9yKX0gQSBQcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdpdGggYW4gaW5zdGFuY2Ugb2YgSW5wdXRzIG9yIHJlamVjdGVkIHdpdGggYW4gZXJyb3JcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbWVyZ2VDb25jZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1lcmdlQ29uY2VwdHMoaW5wdXRzKSB7XG4gICAgICBpbnB1dHMuYWN0aW9uID0gJ21lcmdlJztcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShpbnB1dHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBjb25jZXB0cyB0byBpbnB1dHMgaW4gYnVsa1xuICAgICAqIEBwYXJhbSB7b2JqZWN0W119ICAgICAgICAgaW5wdXRzICAgIExpc3Qgb2YgY29uY2VwdHMgdG8gdXBkYXRlIChtYXggb2YgMTI4IGlucHV0cy9jYWxsOyBwYXNzaW5nID4gMTI4IHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uKVxuICAgICAqICAgQHBhcmFtIHtvYmplY3R9ICAgICAgICAgICBpbnB1dHNbXS5pbnB1dFxuICAgICAqICAgICBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgIGlucHV0c1tdLmlucHV0LmlkICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGlkIG9mIHRoZSBpbnB1dCB0byB1cGRhdGVcbiAgICAgKiAgICAgQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICBpbnB1dHNbXS5pbnB1dC5jb25jZXB0cyAgICAgICAgICAgICAgICAgICAgIE9iamVjdCB3aXRoIGtleXMgZXhwbGFpbmVkIGJlbG93OlxuICAgICAqICAgICAgIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICAgaW5wdXRzW10uaW5wdXQuY29uY2VwdHNbXS5jb25jZXB0XG4gICAgICogICAgICAgICBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgIGlucHV0c1tdLmlucHV0LmNvbmNlcHRzW10uY29uY2VwdC5pZCAgICAgICAgVGhlIGNvbmNlcHQgaWQgKHJlcXVpcmVkKVxuICAgICAqICAgICAgICAgQHBhcmFtIHtib29sZWFufSAgICAgICAgICBpbnB1dHNbXS5pbnB1dC5jb25jZXB0c1tdLmNvbmNlcHQudmFsdWUgICAgIFdoZXRoZXIgb3Igbm90IHRoZSBpbnB1dCBpcyBhIHBvc2l0aXZlICh0cnVlKSBvciBuZWdhdGl2ZSAoZmFsc2UpIGV4YW1wbGUgb2YgdGhlIGNvbmNlcHQgKGRlZmF1bHQ6IHRydWUpXG4gICAgICogQHJldHVybiB7UHJvbWlzZShJbnB1dHMsIGVycm9yKX0gQSBQcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdpdGggYW4gaW5zdGFuY2Ugb2YgSW5wdXRzIG9yIHJlamVjdGVkIHdpdGggYW4gZXJyb3JcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGVsZXRlQ29uY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVDb25jZXB0cyhpbnB1dHMpIHtcbiAgICAgIGlucHV0cy5hY3Rpb24gPSAncmVtb3ZlJztcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShpbnB1dHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJ3cml0ZSBpbnB1dHMgaW4gYnVsa1xuICAgICAqIEBwYXJhbSB7b2JqZWN0W119ICAgICAgICAgaW5wdXRzICAgIExpc3Qgb2YgY29uY2VwdHMgdG8gdXBkYXRlIChtYXggb2YgMTI4IGlucHV0cy9jYWxsOyBwYXNzaW5nID4gMTI4IHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uKVxuICAgICAqICAgQHBhcmFtIHtvYmplY3R9ICAgICAgICAgICBpbnB1dHNbXS5pbnB1dFxuICAgICAqICAgICBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgIGlucHV0c1tdLmlucHV0LmlkICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGlkIG9mIHRoZSBpbnB1dCB0byB1cGRhdGVcbiAgICAgKiAgICAgQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICBpbnB1dHNbXS5pbnB1dC5jb25jZXB0cyAgICAgICAgICAgICAgICAgICAgIE9iamVjdCB3aXRoIGtleXMgZXhwbGFpbmVkIGJlbG93OlxuICAgICAqICAgICAgIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICAgaW5wdXRzW10uaW5wdXQuY29uY2VwdHNbXS5jb25jZXB0XG4gICAgICogICAgICAgICBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgIGlucHV0c1tdLmlucHV0LmNvbmNlcHRzW10uY29uY2VwdC5pZCAgICAgICAgVGhlIGNvbmNlcHQgaWQgKHJlcXVpcmVkKVxuICAgICAqICAgICAgICAgQHBhcmFtIHtib29sZWFufSAgICAgICAgICBpbnB1dHNbXS5pbnB1dC5jb25jZXB0c1tdLmNvbmNlcHQudmFsdWUgICAgIFdoZXRoZXIgb3Igbm90IHRoZSBpbnB1dCBpcyBhIHBvc2l0aXZlICh0cnVlKSBvciBuZWdhdGl2ZSAoZmFsc2UpIGV4YW1wbGUgb2YgdGhlIGNvbmNlcHQgKGRlZmF1bHQ6IHRydWUpXG4gICAgICogQHJldHVybiB7UHJvbWlzZShJbnB1dHMsIGVycm9yKX0gQSBQcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdpdGggYW4gaW5zdGFuY2Ugb2YgSW5wdXRzIG9yIHJlamVjdGVkIHdpdGggYW4gZXJyb3JcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnb3ZlcndyaXRlQ29uY2VwdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvdmVyd3JpdGVDb25jZXB0cyhpbnB1dHMpIHtcbiAgICAgIGlucHV0cy5hY3Rpb24gPSAnb3ZlcndyaXRlJztcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShpbnB1dHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0W119ICAgICAgICAgaW5wdXRzICAgIExpc3Qgb2YgaW5wdXRzIHRvIHVwZGF0ZSAobWF4IG9mIDEyOCBpbnB1dHMvY2FsbDsgcGFzc2luZyA+IDEyOCB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbilcbiAgICAgKiAgIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICAgaW5wdXRzW10uaW5wdXRcbiAgICAgKiAgICAgQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICBpbnB1dHNbXS5pbnB1dC5pZCAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBpZCBvZiB0aGUgaW5wdXQgdG8gdXBkYXRlXG4gICAgICogICAgIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICAgaW5wdXRzW10uaW5wdXQubWV0YWRhdGEgICAgICAgICAgICAgICAgICAgICBPYmplY3Qgd2l0aCBrZXkgdmFsdWVzIHRvIGF0dGFjaCB0byB0aGUgaW5wdXQgKG9wdGlvbmFsKVxuICAgICAqICAgICBAcGFyYW0ge29iamVjdH0gICAgICAgICAgIGlucHV0c1tdLmlucHV0LmdlbyAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0IHdpdGggbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSBjb29yZGluYXRlcyB0byBhc3NvY2lhdGUgd2l0aCBhbiBpbnB1dC4gQ2FuIGJlIHVzZWQgaW4gc2VhcmNoIHF1ZXJ5IGFzIHRoZSBwcm94aW1pdHkgb2YgYW4gaW5wdXQgdG8gYSByZWZlcmVuY2UgcG9pbnQgKG9wdGlvbmFsKVxuICAgICAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSAgICAgICAgICAgaW5wdXRzW10uaW5wdXQuZ2VvLmxhdGl0dWRlICAgICAgICAgICAgICAgICArLy0gbGF0aXR1ZGUgdmFsIG9mIGdlb2RhdGFcbiAgICAgKiAgICAgICBAcGFyYW0ge251bWJlcn0gICAgICAgICAgIGlucHV0c1tdLmlucHV0Lmdlby5sb25naXR1ZGUgICAgICAgICAgICAgICAgKy8tIGxvbmdpdHVkZSB2YWwgb2YgZ2VvZGF0YVxuICAgICAqICAgICBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgIGlucHV0c1tdLmlucHV0LmNvbmNlcHRzICAgICAgICAgICAgICAgICAgICAgT2JqZWN0IHdpdGgga2V5cyBleHBsYWluZWQgYmVsb3cgKG9wdGlvbmFsKTpcbiAgICAgKiAgICAgICBAcGFyYW0ge29iamVjdH0gICAgICAgICAgIGlucHV0c1tdLmlucHV0LmNvbmNlcHRzW10uY29uY2VwdFxuICAgICAqICAgICAgICAgQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICBpbnB1dHNbXS5pbnB1dC5jb25jZXB0c1tdLmNvbmNlcHQuaWQgICAgICAgIFRoZSBjb25jZXB0IGlkIChyZXF1aXJlZClcbiAgICAgKiAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICAgaW5wdXRzW10uaW5wdXQuY29uY2VwdHNbXS5jb25jZXB0LnZhbHVlICAgICBXaGV0aGVyIG9yIG5vdCB0aGUgaW5wdXQgaXMgYSBwb3NpdGl2ZSAodHJ1ZSkgb3IgbmVnYXRpdmUgKGZhbHNlKSBleGFtcGxlIG9mIHRoZSBjb25jZXB0IChkZWZhdWx0OiB0cnVlKVxuICAgICAqIEByZXR1cm4ge1Byb21pc2UoSW5wdXRzLCBlcnJvcil9IEEgUHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aXRoIGFuIGluc3RhbmNlIG9mIElucHV0cyBvciByZWplY3RlZCB3aXRoIGFuIGVycm9yXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShpbnB1dHMpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICB2YXIgdXJsID0gJycgKyB0aGlzLl9jb25maWcuYmFzZVBhdGggKyBJTlBVVFNfUEFUSDtcbiAgICAgIHZhciBpbnB1dHNMaXN0ID0gQXJyYXkuaXNBcnJheShpbnB1dHMpID8gaW5wdXRzIDogW2lucHV0c107XG4gICAgICBpZiAoaW5wdXRzTGlzdC5sZW5ndGggPiBNQVhfQkFUQ0hfU0laRSkge1xuICAgICAgICB0aHJvdyBFUlJPUlMuTUFYX0lOUFVUUztcbiAgICAgIH1cbiAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICBhY3Rpb246IGlucHV0cy5hY3Rpb24sXG4gICAgICAgIGlucHV0czogaW5wdXRzTGlzdC5tYXAoZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgcmV0dXJuIGZvcm1hdElucHV0KGlucHV0LCBmYWxzZSk7XG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHdyYXBUb2tlbih0aGlzLl9jb25maWcsIGZ1bmN0aW9uIChoZWFkZXJzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgYXhpb3MucGF0Y2godXJsLCBkYXRhLCB7IGhlYWRlcnM6IGhlYWRlcnMgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChpc1N1Y2Nlc3MocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUobmV3IElucHV0cyhfdGhpczUuX2NvbmZpZywgcmVzcG9uc2UuZGF0YS5pbnB1dHMpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlamVjdChyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWFyY2ggZm9yIGlucHV0cyBvciBvdXRwdXRzIGJhc2VkIG9uIGNvbmNlcHRzIG9yIGltYWdlc1xuICAgICAqICAgQHBhcmFtIHtvYmplY3RbXX0gICAgICAgICAgICAgICBxdWVyaWVzICAgICAgICAgIExpc3Qgb2YgYWxsIHByZWRpY3Rpb25zIHRvIG1hdGNoIHdpdGhcbiAgICAgKiAgICAgQHBhcmFtIHtvYmplY3R9ICAgICAgICAgICAgICAgICBxdWVyaWVzW10uY29uY2VwdCAgICAgICAgICAgIEFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcga2V5czpcbiAgICAgKiAgICAgICBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgIHF1ZXJpZXNbXS5jb25jZXB0LmlkICAgICAgICAgIFRoZSBjb25jZXB0IGlkXG4gICAgICogICAgICAgQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICBxdWVyaWVzW10uY29uY2VwdC50eXBlICAgICAgICBTZWFyY2ggb3ZlciAnaW5wdXQnIHRvIGdldCBpbnB1dCBtYXRjaGVzIHRvIGNyaXRlcmlhIG9yICdvdXRwdXQnIHRvIGdldCBpbnB1dHMgdGhhdCBhcmUgdmlzdWFsbHkgc2ltaWxhciB0byB0aGUgY3JpdGVyaWEgKGRlZmF1bHQ6ICdvdXRwdXQnKVxuICAgICAqICAgICAgIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgcXVlcmllc1tdLmNvbmNlcHQubmFtZSAgICAgICAgVGhlIGNvbmNlcHQgbmFtZVxuICAgICAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICAgICAgICAgcXVlcmllc1tdLmNvbmNlcHQudmFsdWUgICAgICAgSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRoZSB0ZXJtIHNob3VsZCBtYXRjaCB3aXRoIHRoZSBwcmVkaWN0aW9uIHJldHVybmVkIChkZWZhdWx0OiB0cnVlKVxuICAgICAqICAgICBAcGFyYW0ge29iamVjdH0gICAgICAgICAgICAgICAgIHF1ZXJpZXNbXS5pbnB1dCAgICAgICAgICAgICAgQW4gaW1hZ2Ugb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIGZvbGxvd2luZyBrZXlzOlxuICAgICAqICAgICAgIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgcXVlcmllc1tdLmlucHV0LmlkICAgICAgICAgICAgVGhlIGlucHV0IGlkXG4gICAgICogICAgICAgQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICBxdWVyaWVzW10uaW5wdXQudHlwZSAgICAgICAgICBTZWFyY2ggb3ZlciAnaW5wdXQnIHRvIGdldCBpbnB1dCBtYXRjaGVzIHRvIGNyaXRlcmlhIG9yICdvdXRwdXQnIHRvIGdldCBpbnB1dHMgdGhhdCBhcmUgdmlzdWFsbHkgc2ltaWxhciB0byB0aGUgY3JpdGVyaWEgKGRlZmF1bHQ6ICdvdXRwdXQnKVxuICAgICAqICAgICAgIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgcXVlcmllc1tdLmlucHV0LihiYXNlNjR8dXJsKSAgQ2FuIGJlIGEgcHVibGljbHkgYWNjZXNzaWJseSB1cmwgb3IgYmFzZTY0IHN0cmluZyByZXByZXNlbnRpbmcgaW1hZ2UgYnl0ZXMgKHJlcXVpcmVkKVxuICAgICAqICAgICAgIEBwYXJhbSB7bnVtYmVyW119ICAgICAgICAgICAgICAgcXVlcmllc1tdLmlucHV0LmNyb3AgICAgICAgICAgQW4gYXJyYXkgY29udGFpbmluZyB0aGUgcGVyY2VudCB0byBiZSBjcm9wcGVkIGZyb20gdG9wLCBsZWZ0LCBib3R0b20gYW5kIHJpZ2h0IChvcHRpb25hbClcbiAgICAgKiAgICAgICBAcGFyYW0ge29iamVjdH0gICAgICAgICAgICAgICAgIHF1ZXJpZXNbXS5pbnB1dC5tZXRhZGF0YSAgICAgIEFuIG9iamVjdCB3aXRoIGtleSBhbmQgdmFsdWUgc3BlY2lmaWVkIGJ5IHVzZXIgdG8gcmVmaW5lIHNlYXJjaCB3aXRoIChvcHRpb25hbClcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgICAgICAgICAgb3B0aW9ucyAgICAgICBPYmplY3Qgd2l0aCBrZXlzIGV4cGxhaW5lZCBiZWxvdzogKG9wdGlvbmFsKVxuICAgICAqICAgIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGFnZSAgICAgICAgICBUaGUgcGFnZSBudW1iZXIgKG9wdGlvbmFsLCBkZWZhdWx0OiAxKVxuICAgICAqICAgIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGVyUGFnZSAgICAgICBOdW1iZXIgb2YgaW1hZ2VzIHRvIHJldHVybiBwZXIgcGFnZSAob3B0aW9uYWwsIGRlZmF1bHQ6IDIwKVxuICAgICAqIEByZXR1cm4ge1Byb21pc2UocmVzcG9uc2UsIGVycm9yKX0gQSBQcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdpdGggdGhlIEFQSSByZXNwb25zZSBvciByZWplY3RlZCB3aXRoIGFuIGVycm9yXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NlYXJjaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlYXJjaCgpIHtcbiAgICAgIHZhciBxdWVyaWVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7IHBhZ2U6IDEsIHBlclBhZ2U6IDIwIH07XG5cbiAgICAgIHZhciBmb3JtYXR0ZWRBbmRzID0gW107XG4gICAgICB2YXIgdXJsID0gJycgKyB0aGlzLl9jb25maWcuYmFzZVBhdGggKyBTRUFSQ0hfUEFUSDtcbiAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICBxdWVyeToge1xuICAgICAgICAgIGFuZHM6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIHBhZ2luYXRpb246IHtcbiAgICAgICAgICBwYWdlOiBvcHRpb25zLnBhZ2UsXG4gICAgICAgICAgcGVyX3BhZ2U6IG9wdGlvbnMucGVyUGFnZVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocXVlcmllcykpIHtcbiAgICAgICAgcXVlcmllcyA9IFtxdWVyaWVzXTtcbiAgICAgIH1cbiAgICAgIGlmIChxdWVyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcXVlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeSkge1xuICAgICAgICAgIGlmIChxdWVyeS5pbnB1dCkge1xuICAgICAgICAgICAgZm9ybWF0dGVkQW5kcyA9IGZvcm1hdHRlZEFuZHMuY29uY2F0KGZvcm1hdEltYWdlc1NlYXJjaChxdWVyeS5pbnB1dCkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocXVlcnkuY29uY2VwdCkge1xuICAgICAgICAgICAgZm9ybWF0dGVkQW5kcyA9IGZvcm1hdHRlZEFuZHMuY29uY2F0KGZvcm1hdENvbmNlcHRzU2VhcmNoKHF1ZXJ5LmNvbmNlcHQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBkYXRhLnF1ZXJ5LmFuZHMgPSBmb3JtYXR0ZWRBbmRzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBUb2tlbih0aGlzLl9jb25maWcsIGZ1bmN0aW9uIChoZWFkZXJzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgYXhpb3MucG9zdCh1cmwsIGRhdGEsIHsgaGVhZGVyczogaGVhZGVycyB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKGlzU3VjY2VzcyhyZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgdmFyIF9kYXRhID0gY2xvbmUocmVzcG9uc2UuZGF0YSk7XG4gICAgICAgICAgICAgIF9kYXRhLnJhd0RhdGEgPSBjbG9uZShyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShfZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWplY3QocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2VhcmNoRmVlZGJhY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWFyY2hGZWVkYmFjayhpbnB1dElELCBzZWFyY2hJRCwgZW5kVXNlcklELCBzZXNzaW9uSUQpIHtcbiAgICAgIHZhciB1cmwgPSAnJyArIHRoaXMuX2NvbmZpZy5iYXNlUGF0aCArIFNFQVJDSF9GRUVEQkFDS19QQVRIO1xuICAgICAgdmFyIGJvZHkgPSB7XG4gICAgICAgIGlucHV0OiB7XG4gICAgICAgICAgaWQ6IGlucHV0SUQsXG4gICAgICAgICAgZmVlZGJhY2tfaW5mbzoge1xuICAgICAgICAgICAgZXZlbnRfdHlwZTogJ3NlYXJjaF9jbGljaycsXG4gICAgICAgICAgICBzZWFyY2hfaWQ6IHNlYXJjaElELFxuICAgICAgICAgICAgZW5kX3VzZXJfaWQ6IGVuZFVzZXJJRCxcbiAgICAgICAgICAgIHNlc3Npb25faWQ6IHNlc3Npb25JRFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiB3cmFwVG9rZW4odGhpcy5fY29uZmlnLCBmdW5jdGlvbiAoaGVhZGVycykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGF4aW9zLnBvc3QodXJsLCBib2R5LCB7XG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzXG4gICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBfcmVmLmRhdGE7XG5cbiAgICAgICAgICAgIHZhciBkID0gY2xvbmUoZGF0YSk7XG4gICAgICAgICAgICBkLnJhd0RhdGEgPSBjbG9uZShkYXRhKTtcbiAgICAgICAgICAgIHJlc29sdmUoZCk7XG4gICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgaW5wdXRzIHN0YXR1cyAobnVtYmVyIG9mIHVwbG9hZGVkLCBpbiBwcm9jZXNzIG9yIGZhaWxlZCBpbnB1dHMpXG4gICAgICogQHJldHVybiB7UHJvbWlzZShyZXNwb25zZSwgZXJyb3IpfSBBIFByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2l0aCB0aGUgQVBJIHJlc3BvbnNlIG9yIHJlamVjdGVkIHdpdGggYW4gZXJyb3JcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0U3RhdHVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3RhdHVzKCkge1xuICAgICAgdmFyIHVybCA9ICcnICsgdGhpcy5fY29uZmlnLmJhc2VQYXRoICsgSU5QVVRTX1NUQVRVU19QQVRIO1xuICAgICAgcmV0dXJuIHdyYXBUb2tlbih0aGlzLl9jb25maWcsIGZ1bmN0aW9uIChoZWFkZXJzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgYXhpb3MuZ2V0KHVybCwgeyBoZWFkZXJzOiBoZWFkZXJzIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAoaXNTdWNjZXNzKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICB2YXIgZGF0YSA9IGNsb25lKHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICAgICAgICBkYXRhLnJhd0RhdGEgPSBjbG9uZShyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlamVjdChyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSW5wdXRzO1xufSgpO1xuXG47XG5cbm1vZHVsZS5leHBvcnRzID0gSW5wdXRzOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/clarifai/dist/Inputs.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/clarifai/dist/Model.js":
/*!*********************************************!*\
  !*** ./node_modules/clarifai/dist/Model.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar axios = __webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\");\nvar ModelVersion = __webpack_require__(/*! ./ModelVersion */ \"(rsc)/./node_modules/clarifai/dist/ModelVersion.js\");\n\nvar _require = __webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/clarifai/dist/helpers.js\"),\n    isSuccess = _require.isSuccess,\n    checkType = _require.checkType,\n    clone = _require.clone;\n\nvar _require2 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/clarifai/dist/constants.js\"),\n    API = _require2.API,\n    SYNC_TIMEOUT = _require2.SYNC_TIMEOUT,\n    replaceVars = _require2.replaceVars,\n    STATUS = _require2.STATUS,\n    POLLTIME = _require2.POLLTIME;\n\nvar MODEL_QUEUED_FOR_TRAINING = STATUS.MODEL_QUEUED_FOR_TRAINING,\n    MODEL_TRAINING = STATUS.MODEL_TRAINING;\n\nvar _require3 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/clarifai/dist/utils.js\"),\n    wrapToken = _require3.wrapToken,\n    formatMediaPredict = _require3.formatMediaPredict,\n    formatModel = _require3.formatModel,\n    formatObjectForSnakeCase = _require3.formatObjectForSnakeCase;\n\nvar MODEL_VERSIONS_PATH = API.MODEL_VERSIONS_PATH,\n    MODEL_VERSION_PATH = API.MODEL_VERSION_PATH,\n    MODELS_PATH = API.MODELS_PATH,\n    MODEL_FEEDBACK_PATH = API.MODEL_FEEDBACK_PATH,\n    MODEL_VERSION_FEEDBACK_PATH = API.MODEL_VERSION_FEEDBACK_PATH,\n    PREDICT_PATH = API.PREDICT_PATH,\n    VERSION_PREDICT_PATH = API.VERSION_PREDICT_PATH,\n    MODEL_INPUTS_PATH = API.MODEL_INPUTS_PATH,\n    MODEL_VERSION_OUTPUT_PATH = API.MODEL_VERSION_OUTPUT_PATH,\n    MODEL_OUTPUT_PATH = API.MODEL_OUTPUT_PATH,\n    MODEL_VERSION_INPUTS_PATH = API.MODEL_VERSION_INPUTS_PATH,\n    MODEL_VERSION_METRICS_PATH = API.MODEL_VERSION_METRICS_PATH;\n\n/**\n * class representing a model\n * @class\n */\n\nvar Model = function () {\n  function Model(_config, data) {\n    _classCallCheck(this, Model);\n\n    this._config = _config;\n    this.name = data.name;\n    this.id = data.id;\n    this.createdAt = data.created_at || data.createdAt;\n    this.appId = data.app_id || data.appId;\n    this.outputInfo = data.output_info || data.outputInfo;\n    if (checkType(/(String)/, data.version)) {\n      this.modelVersion = {};\n      this.versionId = data.version;\n    } else {\n      if (data.model_version || data.modelVersion || data.version) {\n        this.modelVersion = new ModelVersion(this._config, data.model_version || data.modelVersion || data.version);\n      }\n      this.versionId = (this.modelVersion || {}).id;\n    }\n    this.rawData = data;\n  }\n\n  /**\n   * Merge concepts to a model\n   * @param {object[]}      concepts    List of concept objects with id\n   * @return {Promise(Model, error)} A Promise that is fulfilled with a Model instance or rejected with an error\n   */\n\n\n  _createClass(Model, [{\n    key: 'mergeConcepts',\n    value: function mergeConcepts() {\n      var concepts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      var conceptsArr = Array.isArray(concepts) ? concepts : [concepts];\n      return this.update({ action: 'merge', concepts: conceptsArr });\n    }\n\n    /**\n     * Remove concepts from a model\n     * @param {object[]}      concepts    List of concept objects with id\n     * @return {Promise(Model, error)} A Promise that is fulfilled with a Model instance or rejected with an error\n     */\n\n  }, {\n    key: 'deleteConcepts',\n    value: function deleteConcepts() {\n      var concepts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      var conceptsArr = Array.isArray(concepts) ? concepts : [concepts];\n      return this.update({ action: 'remove', concepts: conceptsArr });\n    }\n\n    /**\n     * Overwrite concepts in a model\n     * @param {object[]}      concepts    List of concept objects with id\n     * @return {Promise(Model, error)} A Promise that is fulfilled with a Model instance or rejected with an error\n     */\n\n  }, {\n    key: 'overwriteConcepts',\n    value: function overwriteConcepts() {\n      var concepts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      var conceptsArr = Array.isArray(concepts) ? concepts : [concepts];\n      return this.update({ action: 'overwrite', concepts: conceptsArr });\n    }\n\n    /**\n     * Start a model evaluation job\n     * @return {Promise(ModelVersion, error)} A Promise that is fulfilled with a ModelVersion instance or rejected with an error\n     */\n\n  }, {\n    key: 'runModelEval',\n    value: function runModelEval() {\n      var _this = this;\n\n      var url = '' + this._config.basePath + replaceVars(MODEL_VERSION_METRICS_PATH, [this.id, this.versionId]);\n      return wrapToken(this._config, function (headers) {\n        return new Promise(function (resolve, reject) {\n          axios.post(url, {}, { headers: headers }).then(function (response) {\n            if (isSuccess(response)) {\n              resolve(new ModelVersion(_this._config, response.data.model_version));\n            } else {\n              reject(response);\n            }\n          }, reject);\n        });\n      });\n    }\n\n    /**\n     * Update a model's output config or concepts\n     * @param {object}               model                                 An object with any of the following attrs:\n     *   @param {string}               name                                  The new name of the model to update with\n     *   @param {boolean}              conceptsMutuallyExclusive             Do you expect to see more than one of the concepts in this model in the SAME image? Set to false (default) if so. Otherwise, set to true.\n     *   @param {boolean}              closedEnvironment                     Do you expect to run the trained model on images that do not contain ANY of the concepts in the model? Set to false (default) if so. Otherwise, set to true.\n     *   @param {object[]}             concepts                              An array of concept objects or string\n     *     @param {object|string}        concepts[].concept                    If string is given, this is interpreted as concept id. Otherwise, if object is given, client expects the following attributes\n     *       @param {string}             concepts[].concept.id                   The id of the concept to attach to the model\n     *   @param {object[]}             action                                The action to perform on the given concepts. Possible values are 'merge', 'remove', or 'overwrite'. Default: 'merge'\n     * @return {Promise(Model, error)} A Promise that is fulfilled with a Model instance or rejected with an error\n     */\n\n  }, {\n    key: 'update',\n    value: function update(obj) {\n      var _this2 = this;\n\n      var url = '' + this._config.basePath + MODELS_PATH;\n      var modelData = [obj];\n      var data = { models: modelData.map(function (m) {\n          return formatModel(Object.assign(m, { id: _this2.id }));\n        }) };\n      if (Array.isArray(obj.concepts)) {\n        data['action'] = obj.action || 'merge';\n      }\n\n      return wrapToken(this._config, function (headers) {\n        return new Promise(function (resolve, reject) {\n          axios.patch(url, data, { headers: headers }).then(function (response) {\n            if (isSuccess(response)) {\n              resolve(new Model(_this2._config, response.data.models[0]));\n            } else {\n              reject(response);\n            }\n          }, reject);\n        });\n      });\n    }\n\n    /**\n     * Create a new model version\n     * @param {boolean}       sync     If true, this returns after model has completely trained. If false, this immediately returns default api response.\n     * @return {Promise(Model, error)} A Promise that is fulfilled with a Model instance or rejected with an error\n     */\n\n  }, {\n    key: 'train',\n    value: function train(sync) {\n      var _this3 = this;\n\n      var url = '' + this._config.basePath + replaceVars(MODEL_VERSIONS_PATH, [this.id]);\n      return wrapToken(this._config, function (headers) {\n        return new Promise(function (resolve, reject) {\n          axios.post(url, null, { headers: headers }).then(function (response) {\n            if (isSuccess(response)) {\n              // Training produces a new model version ID.\n              _this3.versionId = response.data.model.model_version.id;\n\n              if (sync) {\n                var timeStart = Date.now();\n                _this3._pollTrain.bind(_this3)(timeStart, resolve, reject);\n              } else {\n                resolve(new Model(_this3._config, response.data.model));\n              }\n            } else {\n              reject(response);\n            }\n          }, reject);\n        });\n      });\n    }\n  }, {\n    key: '_pollTrain',\n    value: function _pollTrain(timeStart, resolve, reject) {\n      var _this4 = this;\n\n      clearTimeout(this.pollTimeout);\n      if (Date.now() - timeStart >= SYNC_TIMEOUT) {\n        return reject({\n          status: 'Error',\n          message: 'Sync call timed out'\n        });\n      }\n      this.getOutputInfo().then(function (model) {\n        var modelStatusCode = model.modelVersion.status.code.toString();\n        if (modelStatusCode === MODEL_QUEUED_FOR_TRAINING || modelStatusCode === MODEL_TRAINING) {\n          _this4.pollTimeout = setTimeout(function () {\n            return _this4._pollTrain(timeStart, resolve, reject);\n          }, POLLTIME);\n        } else {\n          resolve(model);\n        }\n      }, reject).catch(reject);\n    }\n\n    /**\n     * Returns model ouputs according to inputs\n     * @param {object[]|object|string}       inputs    An array of objects/object/string pointing to an image resource. A string can either be a url or base64 image bytes. Object keys explained below:\n     *    @param {object}                      inputs[].image     Object with keys explained below:\n     *       @param {string}                     inputs[].image.(url|base64)   Can be a publicly accessibly url or base64 string representing image bytes (required)\n     *       @param {number[]}                   inputs[].image.crop           An array containing the percent to be cropped from top, left, bottom and right (optional)\n     * @param {object|string} config An object with keys explained below. If a string is passed instead, it will be treated as the language (backwards compatibility)\n     *   @param {string} config.language A string code representing the language to return results in (example: 'zh' for simplified Chinese, 'ru' for Russian, 'ja' for Japanese)\n     *   @param {boolean} config.video indicates if the input should be processed as a video\n     *   @param {object[]} config.selectConcepts An array of concepts to return. Each object in the array will have a form of {name: <CONCEPT_NAME>} or {id: CONCEPT_ID}\n     *   @param {float} config.minValue The minimum confidence threshold that a result must meet. From 0.0 to 1.0\n     *   @param {number} config.maxConcepts The maximum number of concepts to return\n     * @param {boolean} isVideo  Deprecated: indicates if the input should be processed as a video (default false). Deprecated in favor of using config object\n     * @return {Promise(response, error)} A Promise that is fulfilled with the API response or rejected with an error\n     */\n\n  }, {\n    key: 'predict',\n    value: function predict(inputs) {\n      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var isVideo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      if (checkType(/String/, config)) {\n        console.warn('passing the language as a string is deprecated, consider using the configuration object instead');\n        config = {\n          language: config\n        };\n      }\n\n      if (isVideo) {\n        console.warn('\"isVideo\" argument is deprecated, consider using the configuration object instead');\n        config.video = isVideo;\n      }\n      var video = config.video || false;\n      delete config.video;\n      if (checkType(/(Object|String)/, inputs)) {\n        inputs = [inputs];\n      }\n      var url = '' + this._config.basePath + (this.versionId ? replaceVars(VERSION_PREDICT_PATH, [this.id, this.versionId]) : replaceVars(PREDICT_PATH, [this.id]));\n      return wrapToken(this._config, function (headers) {\n        var params = { inputs: inputs.map(function (input) {\n            return formatMediaPredict(input, video ? 'video' : 'image');\n          }) };\n        if (config && Object.getOwnPropertyNames(config).length > 0) {\n          params['model'] = {\n            output_info: {\n              output_config: formatObjectForSnakeCase(config)\n            }\n          };\n        }\n        return new Promise(function (resolve, reject) {\n          axios.post(url, params, { headers: headers }).then(function (response) {\n            var data = clone(response.data);\n            data.rawData = clone(response.data);\n            resolve(data);\n          }, reject);\n        });\n      });\n    }\n\n    /**\n     * Returns a version of the model specified by its id\n     * @param {string}     versionId   The model's id\n     * @return {Promise(response, error)} A Promise that is fulfilled with the API response or rejected with an error\n     */\n\n  }, {\n    key: 'getVersion',\n    value: function getVersion(versionId) {\n      // TODO(Rok) MEDIUM: The version ID isn't URI encoded, as opposed to the model ID. This should probably be\n      //  consistent - i.e. the same in both cases.\n      var url = '' + this._config.basePath + replaceVars(MODEL_VERSION_PATH, [this.id, versionId]);\n      return wrapToken(this._config, function (headers) {\n        return new Promise(function (resolve, reject) {\n          axios.get(url, { headers: headers }).then(function (response) {\n            var data = clone(response.data);\n            data.rawData = clone(response.data);\n            resolve(data);\n          }, reject);\n        });\n      });\n    }\n\n    /**\n     * Returns a list of versions of the model\n     * @param {object}     options     Object with keys explained below: (optional)\n     *   @param {number}     options.page        The page number (optional, default: 1)\n     *   @param {number}     options.perPage     Number of images to return per page (optional, default: 20)\n     * @return {Promise(response, error)} A Promise that is fulfilled with the API response or rejected with an error\n     */\n\n  }, {\n    key: 'getVersions',\n    value: function getVersions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { page: 1, perPage: 20 };\n\n      var url = '' + this._config.basePath + replaceVars(MODEL_VERSIONS_PATH, [this.id]);\n      return wrapToken(this._config, function (headers) {\n        var data = {\n          headers: headers,\n          params: { 'per_page': options.perPage, 'page': options.page }\n        };\n        return new Promise(function (resolve, reject) {\n          axios.get(url, data).then(function (response) {\n            var data = clone(response.data);\n            data.rawData = clone(response.data);\n            resolve(data);\n          }, reject);\n        });\n      });\n    }\n\n    /**\n     * Returns all the model's output info\n     * @return {Promise(Model, error)} A Promise that is fulfilled with a Model instance or rejected with an error\n     */\n\n  }, {\n    key: 'getOutputInfo',\n    value: function getOutputInfo() {\n      var _this5 = this;\n\n      var url = '' + this._config.basePath + (this.versionId ? replaceVars(MODEL_VERSION_OUTPUT_PATH, [this.id, this.versionId]) : replaceVars(MODEL_OUTPUT_PATH, [this.id]));\n      return wrapToken(this._config, function (headers) {\n        return new Promise(function (resolve, reject) {\n          axios.get(url, { headers: headers }).then(function (response) {\n            resolve(new Model(_this5._config, response.data.model));\n          }, reject);\n        });\n      });\n    }\n\n    /**\n     * Returns all the model's inputs\n     * @param {object}     options     Object with keys explained below: (optional)\n     *   @param {number}     options.page        The page number (optional, default: 1)\n     *   @param {number}     options.perPage     Number of images to return per page (optional, default: 20)\n     * @return {Promise(response, error)} A Promise that is fulfilled with the API response or rejected with an error\n     */\n\n  }, {\n    key: 'getInputs',\n    value: function getInputs() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { page: 1, perPage: 20 };\n\n      var url = '' + this._config.basePath + (this.versionId ? replaceVars(MODEL_VERSION_INPUTS_PATH, [this.id, this.versionId]) : replaceVars(MODEL_INPUTS_PATH, [this.id]));\n      return wrapToken(this._config, function (headers) {\n        return new Promise(function (resolve, reject) {\n          axios.get(url, {\n            params: { 'per_page': options.perPage, 'page': options.page },\n            headers: headers\n          }).then(function (response) {\n            var data = clone(response.data);\n            data.rawData = clone(response.data);\n            resolve(data);\n          }, reject);\n        });\n      });\n    }\n\n    /**\n     *\n     * @param {string} input A string pointing to an image resource. A string must be a url\n     * @param {object} config A configuration object consisting of the following required keys\n     *   @param {string} config.id The id of the feedback request\n     *   @param {object} config.data The feedback data to be sent\n     *   @param {object} config.info Meta data related to the feedback request\n     * @return {Promise(response, error)} A Promise that is fulfilled with the API response or rejected with an error\n     */\n\n  }, {\n    key: 'feedback',\n    value: function feedback(input, _ref) {\n      var id = _ref.id,\n          data = _ref.data,\n          info = _ref.info;\n\n      var url = '' + this._config.basePath + (this.versionId ? replaceVars(MODEL_VERSION_FEEDBACK_PATH, [this.id, this.versionId]) : replaceVars(MODEL_FEEDBACK_PATH, [this.id]));\n      var media = formatMediaPredict(input).data;\n      info.eventType = 'annotation';\n      var body = {\n        input: {\n          id: id,\n          data: Object.assign(media, data),\n          'feedback_info': formatObjectForSnakeCase(info)\n        }\n      };\n      return wrapToken(this._config, function (headers) {\n        return new Promise(function (resolve, reject) {\n          axios.post(url, body, {\n            headers: headers\n          }).then(function (_ref2) {\n            var data = _ref2.data;\n\n            var d = clone(data);\n            d.rawData = clone(data);\n            resolve(d);\n          }, reject);\n        });\n      });\n    }\n  }]);\n\n  return Model;\n}();\n\nmodule.exports = Model;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2xhcmlmYWkvZGlzdC9Nb2RlbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixpQ0FBaUMsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsK0RBQStELHlEQUF5RCxxRUFBcUUsNkRBQTZELHdCQUF3Qjs7QUFFampCLGtEQUFrRCwwQ0FBMEM7O0FBRTVGLFlBQVksbUJBQU8sQ0FBQyw2REFBTztBQUMzQixtQkFBbUIsbUJBQU8sQ0FBQywwRUFBZ0I7O0FBRTNDLGVBQWUsbUJBQU8sQ0FBQyxnRUFBVztBQUNsQztBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsb0VBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFnQixtQkFBTyxDQUFDLDREQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixjQUFjLHVCQUF1QjtBQUNyQzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsd0NBQXdDO0FBQ25FOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZ0JBQWdCLHVCQUF1QjtBQUN2Qzs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLHlDQUF5QztBQUNwRTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGdCQUFnQix1QkFBdUI7QUFDdkM7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQiw0Q0FBNEM7QUFDdkU7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQiw4QkFBOEI7QUFDOUM7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsSUFBSSxrQkFBa0I7QUFDbEQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDLGlCQUFpQixzQkFBc0I7QUFDdkMsaUJBQWlCLHNCQUFzQjtBQUN2QyxpQkFBaUIsc0JBQXNCO0FBQ3ZDLGlCQUFpQixzQkFBc0I7QUFDdkMsbUJBQW1CLHNCQUFzQjtBQUN6QyxxQkFBcUIsb0JBQW9CO0FBQ3pDLGlCQUFpQixzQkFBc0I7QUFDdkMsZ0JBQWdCLHVCQUF1QjtBQUN2Qzs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsZ0RBQWdELGVBQWU7QUFDL0QsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLGtCQUFrQjtBQUNyRDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGdCQUFnQix1QkFBdUI7QUFDdkM7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msa0JBQWtCO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxlQUFlLDhCQUE4QjtBQUM3QyxrQkFBa0IsNkJBQTZCO0FBQy9DLHFCQUFxQiw0QkFBNEI7QUFDakQscUJBQXFCLDRCQUE0QjtBQUNqRCxlQUFlLGVBQWU7QUFDOUIsaUJBQWlCLFFBQVE7QUFDekIsaUJBQWlCLFNBQVM7QUFDMUIsaUJBQWlCLFVBQVUsb0dBQW9HLHNCQUFzQixJQUFJO0FBQ3pKLGlCQUFpQixPQUFPO0FBQ3hCLGlCQUFpQixRQUFRO0FBQ3pCLGVBQWUsU0FBUztBQUN4QixnQkFBZ0IsMEJBQTBCO0FBQzFDOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGtCQUFrQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGdCQUFnQiwwQkFBMEI7QUFDMUM7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQixZQUFZO0FBQzdCLGlCQUFpQixZQUFZO0FBQzdCLGdCQUFnQiwwQkFBMEI7QUFDMUM7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQSwwRkFBMEY7O0FBRTFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCLFlBQVk7QUFDN0IsaUJBQWlCLFlBQVk7QUFDN0IsZ0JBQWdCLDBCQUEwQjtBQUMxQzs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDBGQUEwRjs7QUFFMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbURBQW1EO0FBQ3pFO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCLGdCQUFnQiwwQkFBMEI7QUFDMUM7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVmcmlnZXJhdG9yX2FwcC8uL25vZGVfbW9kdWxlcy9jbGFyaWZhaS9kaXN0L01vZGVsLmpzPzM5MTkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgYXhpb3MgPSByZXF1aXJlKCdheGlvcycpO1xudmFyIE1vZGVsVmVyc2lvbiA9IHJlcXVpcmUoJy4vTW9kZWxWZXJzaW9uJyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vaGVscGVycycpLFxuICAgIGlzU3VjY2VzcyA9IF9yZXF1aXJlLmlzU3VjY2VzcyxcbiAgICBjaGVja1R5cGUgPSBfcmVxdWlyZS5jaGVja1R5cGUsXG4gICAgY2xvbmUgPSBfcmVxdWlyZS5jbG9uZTtcblxudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyksXG4gICAgQVBJID0gX3JlcXVpcmUyLkFQSSxcbiAgICBTWU5DX1RJTUVPVVQgPSBfcmVxdWlyZTIuU1lOQ19USU1FT1VULFxuICAgIHJlcGxhY2VWYXJzID0gX3JlcXVpcmUyLnJlcGxhY2VWYXJzLFxuICAgIFNUQVRVUyA9IF9yZXF1aXJlMi5TVEFUVVMsXG4gICAgUE9MTFRJTUUgPSBfcmVxdWlyZTIuUE9MTFRJTUU7XG5cbnZhciBNT0RFTF9RVUVVRURfRk9SX1RSQUlOSU5HID0gU1RBVFVTLk1PREVMX1FVRVVFRF9GT1JfVFJBSU5JTkcsXG4gICAgTU9ERUxfVFJBSU5JTkcgPSBTVEFUVVMuTU9ERUxfVFJBSU5JTkc7XG5cbnZhciBfcmVxdWlyZTMgPSByZXF1aXJlKCcuL3V0aWxzJyksXG4gICAgd3JhcFRva2VuID0gX3JlcXVpcmUzLndyYXBUb2tlbixcbiAgICBmb3JtYXRNZWRpYVByZWRpY3QgPSBfcmVxdWlyZTMuZm9ybWF0TWVkaWFQcmVkaWN0LFxuICAgIGZvcm1hdE1vZGVsID0gX3JlcXVpcmUzLmZvcm1hdE1vZGVsLFxuICAgIGZvcm1hdE9iamVjdEZvclNuYWtlQ2FzZSA9IF9yZXF1aXJlMy5mb3JtYXRPYmplY3RGb3JTbmFrZUNhc2U7XG5cbnZhciBNT0RFTF9WRVJTSU9OU19QQVRIID0gQVBJLk1PREVMX1ZFUlNJT05TX1BBVEgsXG4gICAgTU9ERUxfVkVSU0lPTl9QQVRIID0gQVBJLk1PREVMX1ZFUlNJT05fUEFUSCxcbiAgICBNT0RFTFNfUEFUSCA9IEFQSS5NT0RFTFNfUEFUSCxcbiAgICBNT0RFTF9GRUVEQkFDS19QQVRIID0gQVBJLk1PREVMX0ZFRURCQUNLX1BBVEgsXG4gICAgTU9ERUxfVkVSU0lPTl9GRUVEQkFDS19QQVRIID0gQVBJLk1PREVMX1ZFUlNJT05fRkVFREJBQ0tfUEFUSCxcbiAgICBQUkVESUNUX1BBVEggPSBBUEkuUFJFRElDVF9QQVRILFxuICAgIFZFUlNJT05fUFJFRElDVF9QQVRIID0gQVBJLlZFUlNJT05fUFJFRElDVF9QQVRILFxuICAgIE1PREVMX0lOUFVUU19QQVRIID0gQVBJLk1PREVMX0lOUFVUU19QQVRILFxuICAgIE1PREVMX1ZFUlNJT05fT1VUUFVUX1BBVEggPSBBUEkuTU9ERUxfVkVSU0lPTl9PVVRQVVRfUEFUSCxcbiAgICBNT0RFTF9PVVRQVVRfUEFUSCA9IEFQSS5NT0RFTF9PVVRQVVRfUEFUSCxcbiAgICBNT0RFTF9WRVJTSU9OX0lOUFVUU19QQVRIID0gQVBJLk1PREVMX1ZFUlNJT05fSU5QVVRTX1BBVEgsXG4gICAgTU9ERUxfVkVSU0lPTl9NRVRSSUNTX1BBVEggPSBBUEkuTU9ERUxfVkVSU0lPTl9NRVRSSUNTX1BBVEg7XG5cbi8qKlxuICogY2xhc3MgcmVwcmVzZW50aW5nIGEgbW9kZWxcbiAqIEBjbGFzc1xuICovXG5cbnZhciBNb2RlbCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTW9kZWwoX2NvbmZpZywgZGF0YSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNb2RlbCk7XG5cbiAgICB0aGlzLl9jb25maWcgPSBfY29uZmlnO1xuICAgIHRoaXMubmFtZSA9IGRhdGEubmFtZTtcbiAgICB0aGlzLmlkID0gZGF0YS5pZDtcbiAgICB0aGlzLmNyZWF0ZWRBdCA9IGRhdGEuY3JlYXRlZF9hdCB8fCBkYXRhLmNyZWF0ZWRBdDtcbiAgICB0aGlzLmFwcElkID0gZGF0YS5hcHBfaWQgfHwgZGF0YS5hcHBJZDtcbiAgICB0aGlzLm91dHB1dEluZm8gPSBkYXRhLm91dHB1dF9pbmZvIHx8IGRhdGEub3V0cHV0SW5mbztcbiAgICBpZiAoY2hlY2tUeXBlKC8oU3RyaW5nKS8sIGRhdGEudmVyc2lvbikpIHtcbiAgICAgIHRoaXMubW9kZWxWZXJzaW9uID0ge307XG4gICAgICB0aGlzLnZlcnNpb25JZCA9IGRhdGEudmVyc2lvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRhdGEubW9kZWxfdmVyc2lvbiB8fCBkYXRhLm1vZGVsVmVyc2lvbiB8fCBkYXRhLnZlcnNpb24pIHtcbiAgICAgICAgdGhpcy5tb2RlbFZlcnNpb24gPSBuZXcgTW9kZWxWZXJzaW9uKHRoaXMuX2NvbmZpZywgZGF0YS5tb2RlbF92ZXJzaW9uIHx8IGRhdGEubW9kZWxWZXJzaW9uIHx8IGRhdGEudmVyc2lvbik7XG4gICAgICB9XG4gICAgICB0aGlzLnZlcnNpb25JZCA9ICh0aGlzLm1vZGVsVmVyc2lvbiB8fCB7fSkuaWQ7XG4gICAgfVxuICAgIHRoaXMucmF3RGF0YSA9IGRhdGE7XG4gIH1cblxuICAvKipcbiAgICogTWVyZ2UgY29uY2VwdHMgdG8gYSBtb2RlbFxuICAgKiBAcGFyYW0ge29iamVjdFtdfSAgICAgIGNvbmNlcHRzICAgIExpc3Qgb2YgY29uY2VwdCBvYmplY3RzIHdpdGggaWRcbiAgICogQHJldHVybiB7UHJvbWlzZShNb2RlbCwgZXJyb3IpfSBBIFByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2l0aCBhIE1vZGVsIGluc3RhbmNlIG9yIHJlamVjdGVkIHdpdGggYW4gZXJyb3JcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoTW9kZWwsIFt7XG4gICAga2V5OiAnbWVyZ2VDb25jZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1lcmdlQ29uY2VwdHMoKSB7XG4gICAgICB2YXIgY29uY2VwdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuXG4gICAgICB2YXIgY29uY2VwdHNBcnIgPSBBcnJheS5pc0FycmF5KGNvbmNlcHRzKSA/IGNvbmNlcHRzIDogW2NvbmNlcHRzXTtcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZSh7IGFjdGlvbjogJ21lcmdlJywgY29uY2VwdHM6IGNvbmNlcHRzQXJyIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBjb25jZXB0cyBmcm9tIGEgbW9kZWxcbiAgICAgKiBAcGFyYW0ge29iamVjdFtdfSAgICAgIGNvbmNlcHRzICAgIExpc3Qgb2YgY29uY2VwdCBvYmplY3RzIHdpdGggaWRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlKE1vZGVsLCBlcnJvcil9IEEgUHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aXRoIGEgTW9kZWwgaW5zdGFuY2Ugb3IgcmVqZWN0ZWQgd2l0aCBhbiBlcnJvclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkZWxldGVDb25jZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZUNvbmNlcHRzKCkge1xuICAgICAgdmFyIGNvbmNlcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcblxuICAgICAgdmFyIGNvbmNlcHRzQXJyID0gQXJyYXkuaXNBcnJheShjb25jZXB0cykgPyBjb25jZXB0cyA6IFtjb25jZXB0c107XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGUoeyBhY3Rpb246ICdyZW1vdmUnLCBjb25jZXB0czogY29uY2VwdHNBcnIgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcndyaXRlIGNvbmNlcHRzIGluIGEgbW9kZWxcbiAgICAgKiBAcGFyYW0ge29iamVjdFtdfSAgICAgIGNvbmNlcHRzICAgIExpc3Qgb2YgY29uY2VwdCBvYmplY3RzIHdpdGggaWRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlKE1vZGVsLCBlcnJvcil9IEEgUHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aXRoIGEgTW9kZWwgaW5zdGFuY2Ugb3IgcmVqZWN0ZWQgd2l0aCBhbiBlcnJvclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdvdmVyd3JpdGVDb25jZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG92ZXJ3cml0ZUNvbmNlcHRzKCkge1xuICAgICAgdmFyIGNvbmNlcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcblxuICAgICAgdmFyIGNvbmNlcHRzQXJyID0gQXJyYXkuaXNBcnJheShjb25jZXB0cykgPyBjb25jZXB0cyA6IFtjb25jZXB0c107XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGUoeyBhY3Rpb246ICdvdmVyd3JpdGUnLCBjb25jZXB0czogY29uY2VwdHNBcnIgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnQgYSBtb2RlbCBldmFsdWF0aW9uIGpvYlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UoTW9kZWxWZXJzaW9uLCBlcnJvcil9IEEgUHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aXRoIGEgTW9kZWxWZXJzaW9uIGluc3RhbmNlIG9yIHJlamVjdGVkIHdpdGggYW4gZXJyb3JcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncnVuTW9kZWxFdmFsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcnVuTW9kZWxFdmFsKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHVybCA9ICcnICsgdGhpcy5fY29uZmlnLmJhc2VQYXRoICsgcmVwbGFjZVZhcnMoTU9ERUxfVkVSU0lPTl9NRVRSSUNTX1BBVEgsIFt0aGlzLmlkLCB0aGlzLnZlcnNpb25JZF0pO1xuICAgICAgcmV0dXJuIHdyYXBUb2tlbih0aGlzLl9jb25maWcsIGZ1bmN0aW9uIChoZWFkZXJzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgYXhpb3MucG9zdCh1cmwsIHt9LCB7IGhlYWRlcnM6IGhlYWRlcnMgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChpc1N1Y2Nlc3MocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUobmV3IE1vZGVsVmVyc2lvbihfdGhpcy5fY29uZmlnLCByZXNwb25zZS5kYXRhLm1vZGVsX3ZlcnNpb24pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlamVjdChyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYSBtb2RlbCdzIG91dHB1dCBjb25maWcgb3IgY29uY2VwdHNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgICAgICAgICBtb2RlbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFuIG9iamVjdCB3aXRoIGFueSBvZiB0aGUgZm9sbG93aW5nIGF0dHJzOlxuICAgICAqICAgQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgbmFtZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgbmV3IG5hbWUgb2YgdGhlIG1vZGVsIHRvIHVwZGF0ZSB3aXRoXG4gICAgICogICBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgICAgICBjb25jZXB0c011dHVhbGx5RXhjbHVzaXZlICAgICAgICAgICAgIERvIHlvdSBleHBlY3QgdG8gc2VlIG1vcmUgdGhhbiBvbmUgb2YgdGhlIGNvbmNlcHRzIGluIHRoaXMgbW9kZWwgaW4gdGhlIFNBTUUgaW1hZ2U/IFNldCB0byBmYWxzZSAoZGVmYXVsdCkgaWYgc28uIE90aGVyd2lzZSwgc2V0IHRvIHRydWUuXG4gICAgICogICBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgICAgICBjbG9zZWRFbnZpcm9ubWVudCAgICAgICAgICAgICAgICAgICAgIERvIHlvdSBleHBlY3QgdG8gcnVuIHRoZSB0cmFpbmVkIG1vZGVsIG9uIGltYWdlcyB0aGF0IGRvIG5vdCBjb250YWluIEFOWSBvZiB0aGUgY29uY2VwdHMgaW4gdGhlIG1vZGVsPyBTZXQgdG8gZmFsc2UgKGRlZmF1bHQpIGlmIHNvLiBPdGhlcndpc2UsIHNldCB0byB0cnVlLlxuICAgICAqICAgQHBhcmFtIHtvYmplY3RbXX0gICAgICAgICAgICAgY29uY2VwdHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbiBhcnJheSBvZiBjb25jZXB0IG9iamVjdHMgb3Igc3RyaW5nXG4gICAgICogICAgIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gICAgICAgIGNvbmNlcHRzW10uY29uY2VwdCAgICAgICAgICAgICAgICAgICAgSWYgc3RyaW5nIGlzIGdpdmVuLCB0aGlzIGlzIGludGVycHJldGVkIGFzIGNvbmNlcHQgaWQuIE90aGVyd2lzZSwgaWYgb2JqZWN0IGlzIGdpdmVuLCBjbGllbnQgZXhwZWN0cyB0aGUgZm9sbG93aW5nIGF0dHJpYnV0ZXNcbiAgICAgKiAgICAgICBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgY29uY2VwdHNbXS5jb25jZXB0LmlkICAgICAgICAgICAgICAgICAgIFRoZSBpZCBvZiB0aGUgY29uY2VwdCB0byBhdHRhY2ggdG8gdGhlIG1vZGVsXG4gICAgICogICBAcGFyYW0ge29iamVjdFtdfSAgICAgICAgICAgICBhY3Rpb24gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBhY3Rpb24gdG8gcGVyZm9ybSBvbiB0aGUgZ2l2ZW4gY29uY2VwdHMuIFBvc3NpYmxlIHZhbHVlcyBhcmUgJ21lcmdlJywgJ3JlbW92ZScsIG9yICdvdmVyd3JpdGUnLiBEZWZhdWx0OiAnbWVyZ2UnXG4gICAgICogQHJldHVybiB7UHJvbWlzZShNb2RlbCwgZXJyb3IpfSBBIFByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2l0aCBhIE1vZGVsIGluc3RhbmNlIG9yIHJlamVjdGVkIHdpdGggYW4gZXJyb3JcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKG9iaikge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciB1cmwgPSAnJyArIHRoaXMuX2NvbmZpZy5iYXNlUGF0aCArIE1PREVMU19QQVRIO1xuICAgICAgdmFyIG1vZGVsRGF0YSA9IFtvYmpdO1xuICAgICAgdmFyIGRhdGEgPSB7IG1vZGVsczogbW9kZWxEYXRhLm1hcChmdW5jdGlvbiAobSkge1xuICAgICAgICAgIHJldHVybiBmb3JtYXRNb2RlbChPYmplY3QuYXNzaWduKG0sIHsgaWQ6IF90aGlzMi5pZCB9KSk7XG4gICAgICAgIH0pIH07XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmouY29uY2VwdHMpKSB7XG4gICAgICAgIGRhdGFbJ2FjdGlvbiddID0gb2JqLmFjdGlvbiB8fCAnbWVyZ2UnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gd3JhcFRva2VuKHRoaXMuX2NvbmZpZywgZnVuY3Rpb24gKGhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBheGlvcy5wYXRjaCh1cmwsIGRhdGEsIHsgaGVhZGVyczogaGVhZGVycyB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKGlzU3VjY2VzcyhyZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShuZXcgTW9kZWwoX3RoaXMyLl9jb25maWcsIHJlc3BvbnNlLmRhdGEubW9kZWxzWzBdKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWplY3QocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IG1vZGVsIHZlcnNpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgIHN5bmMgICAgIElmIHRydWUsIHRoaXMgcmV0dXJucyBhZnRlciBtb2RlbCBoYXMgY29tcGxldGVseSB0cmFpbmVkLiBJZiBmYWxzZSwgdGhpcyBpbW1lZGlhdGVseSByZXR1cm5zIGRlZmF1bHQgYXBpIHJlc3BvbnNlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UoTW9kZWwsIGVycm9yKX0gQSBQcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdpdGggYSBNb2RlbCBpbnN0YW5jZSBvciByZWplY3RlZCB3aXRoIGFuIGVycm9yXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3RyYWluJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhaW4oc3luYykge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciB1cmwgPSAnJyArIHRoaXMuX2NvbmZpZy5iYXNlUGF0aCArIHJlcGxhY2VWYXJzKE1PREVMX1ZFUlNJT05TX1BBVEgsIFt0aGlzLmlkXSk7XG4gICAgICByZXR1cm4gd3JhcFRva2VuKHRoaXMuX2NvbmZpZywgZnVuY3Rpb24gKGhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBheGlvcy5wb3N0KHVybCwgbnVsbCwgeyBoZWFkZXJzOiBoZWFkZXJzIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAoaXNTdWNjZXNzKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAvLyBUcmFpbmluZyBwcm9kdWNlcyBhIG5ldyBtb2RlbCB2ZXJzaW9uIElELlxuICAgICAgICAgICAgICBfdGhpczMudmVyc2lvbklkID0gcmVzcG9uc2UuZGF0YS5tb2RlbC5tb2RlbF92ZXJzaW9uLmlkO1xuXG4gICAgICAgICAgICAgIGlmIChzeW5jKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWVTdGFydCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgX3RoaXMzLl9wb2xsVHJhaW4uYmluZChfdGhpczMpKHRpbWVTdGFydCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG5ldyBNb2RlbChfdGhpczMuX2NvbmZpZywgcmVzcG9uc2UuZGF0YS5tb2RlbCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWplY3QocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX3BvbGxUcmFpbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wb2xsVHJhaW4odGltZVN0YXJ0LCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5wb2xsVGltZW91dCk7XG4gICAgICBpZiAoRGF0ZS5ub3coKSAtIHRpbWVTdGFydCA+PSBTWU5DX1RJTUVPVVQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdCh7XG4gICAgICAgICAgc3RhdHVzOiAnRXJyb3InLFxuICAgICAgICAgIG1lc3NhZ2U6ICdTeW5jIGNhbGwgdGltZWQgb3V0J1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZ2V0T3V0cHV0SW5mbygpLnRoZW4oZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgIHZhciBtb2RlbFN0YXR1c0NvZGUgPSBtb2RlbC5tb2RlbFZlcnNpb24uc3RhdHVzLmNvZGUudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKG1vZGVsU3RhdHVzQ29kZSA9PT0gTU9ERUxfUVVFVUVEX0ZPUl9UUkFJTklORyB8fCBtb2RlbFN0YXR1c0NvZGUgPT09IE1PREVMX1RSQUlOSU5HKSB7XG4gICAgICAgICAgX3RoaXM0LnBvbGxUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM0Ll9wb2xsVHJhaW4odGltZVN0YXJ0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIFBPTExUSU1FKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKG1vZGVsKTtcbiAgICAgICAgfVxuICAgICAgfSwgcmVqZWN0KS5jYXRjaChyZWplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbW9kZWwgb3VwdXRzIGFjY29yZGluZyB0byBpbnB1dHNcbiAgICAgKiBAcGFyYW0ge29iamVjdFtdfG9iamVjdHxzdHJpbmd9ICAgICAgIGlucHV0cyAgICBBbiBhcnJheSBvZiBvYmplY3RzL29iamVjdC9zdHJpbmcgcG9pbnRpbmcgdG8gYW4gaW1hZ2UgcmVzb3VyY2UuIEEgc3RyaW5nIGNhbiBlaXRoZXIgYmUgYSB1cmwgb3IgYmFzZTY0IGltYWdlIGJ5dGVzLiBPYmplY3Qga2V5cyBleHBsYWluZWQgYmVsb3c6XG4gICAgICogICAgQHBhcmFtIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgICAgIGlucHV0c1tdLmltYWdlICAgICBPYmplY3Qgd2l0aCBrZXlzIGV4cGxhaW5lZCBiZWxvdzpcbiAgICAgKiAgICAgICBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICAgICBpbnB1dHNbXS5pbWFnZS4odXJsfGJhc2U2NCkgICBDYW4gYmUgYSBwdWJsaWNseSBhY2Nlc3NpYmx5IHVybCBvciBiYXNlNjQgc3RyaW5nIHJlcHJlc2VudGluZyBpbWFnZSBieXRlcyAocmVxdWlyZWQpXG4gICAgICogICAgICAgQHBhcmFtIHtudW1iZXJbXX0gICAgICAgICAgICAgICAgICAgaW5wdXRzW10uaW1hZ2UuY3JvcCAgICAgICAgICAgQW4gYXJyYXkgY29udGFpbmluZyB0aGUgcGVyY2VudCB0byBiZSBjcm9wcGVkIGZyb20gdG9wLCBsZWZ0LCBib3R0b20gYW5kIHJpZ2h0IChvcHRpb25hbClcbiAgICAgKiBAcGFyYW0ge29iamVjdHxzdHJpbmd9IGNvbmZpZyBBbiBvYmplY3Qgd2l0aCBrZXlzIGV4cGxhaW5lZCBiZWxvdy4gSWYgYSBzdHJpbmcgaXMgcGFzc2VkIGluc3RlYWQsIGl0IHdpbGwgYmUgdHJlYXRlZCBhcyB0aGUgbGFuZ3VhZ2UgKGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5KVxuICAgICAqICAgQHBhcmFtIHtzdHJpbmd9IGNvbmZpZy5sYW5ndWFnZSBBIHN0cmluZyBjb2RlIHJlcHJlc2VudGluZyB0aGUgbGFuZ3VhZ2UgdG8gcmV0dXJuIHJlc3VsdHMgaW4gKGV4YW1wbGU6ICd6aCcgZm9yIHNpbXBsaWZpZWQgQ2hpbmVzZSwgJ3J1JyBmb3IgUnVzc2lhbiwgJ2phJyBmb3IgSmFwYW5lc2UpXG4gICAgICogICBAcGFyYW0ge2Jvb2xlYW59IGNvbmZpZy52aWRlbyBpbmRpY2F0ZXMgaWYgdGhlIGlucHV0IHNob3VsZCBiZSBwcm9jZXNzZWQgYXMgYSB2aWRlb1xuICAgICAqICAgQHBhcmFtIHtvYmplY3RbXX0gY29uZmlnLnNlbGVjdENvbmNlcHRzIEFuIGFycmF5IG9mIGNvbmNlcHRzIHRvIHJldHVybi4gRWFjaCBvYmplY3QgaW4gdGhlIGFycmF5IHdpbGwgaGF2ZSBhIGZvcm0gb2Yge25hbWU6IDxDT05DRVBUX05BTUU+fSBvciB7aWQ6IENPTkNFUFRfSUR9XG4gICAgICogICBAcGFyYW0ge2Zsb2F0fSBjb25maWcubWluVmFsdWUgVGhlIG1pbmltdW0gY29uZmlkZW5jZSB0aHJlc2hvbGQgdGhhdCBhIHJlc3VsdCBtdXN0IG1lZXQuIEZyb20gMC4wIHRvIDEuMFxuICAgICAqICAgQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy5tYXhDb25jZXB0cyBUaGUgbWF4aW11bSBudW1iZXIgb2YgY29uY2VwdHMgdG8gcmV0dXJuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1ZpZGVvICBEZXByZWNhdGVkOiBpbmRpY2F0ZXMgaWYgdGhlIGlucHV0IHNob3VsZCBiZSBwcm9jZXNzZWQgYXMgYSB2aWRlbyAoZGVmYXVsdCBmYWxzZSkuIERlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgdXNpbmcgY29uZmlnIG9iamVjdFxuICAgICAqIEByZXR1cm4ge1Byb21pc2UocmVzcG9uc2UsIGVycm9yKX0gQSBQcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdpdGggdGhlIEFQSSByZXNwb25zZSBvciByZWplY3RlZCB3aXRoIGFuIGVycm9yXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3ByZWRpY3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVkaWN0KGlucHV0cykge1xuICAgICAgdmFyIGNvbmZpZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICB2YXIgaXNWaWRlbyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgICAgIGlmIChjaGVja1R5cGUoL1N0cmluZy8sIGNvbmZpZykpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdwYXNzaW5nIHRoZSBsYW5ndWFnZSBhcyBhIHN0cmluZyBpcyBkZXByZWNhdGVkLCBjb25zaWRlciB1c2luZyB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgaW5zdGVhZCcpO1xuICAgICAgICBjb25maWcgPSB7XG4gICAgICAgICAgbGFuZ3VhZ2U6IGNvbmZpZ1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNWaWRlbykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1wiaXNWaWRlb1wiIGFyZ3VtZW50IGlzIGRlcHJlY2F0ZWQsIGNvbnNpZGVyIHVzaW5nIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBpbnN0ZWFkJyk7XG4gICAgICAgIGNvbmZpZy52aWRlbyA9IGlzVmlkZW87XG4gICAgICB9XG4gICAgICB2YXIgdmlkZW8gPSBjb25maWcudmlkZW8gfHwgZmFsc2U7XG4gICAgICBkZWxldGUgY29uZmlnLnZpZGVvO1xuICAgICAgaWYgKGNoZWNrVHlwZSgvKE9iamVjdHxTdHJpbmcpLywgaW5wdXRzKSkge1xuICAgICAgICBpbnB1dHMgPSBbaW5wdXRzXTtcbiAgICAgIH1cbiAgICAgIHZhciB1cmwgPSAnJyArIHRoaXMuX2NvbmZpZy5iYXNlUGF0aCArICh0aGlzLnZlcnNpb25JZCA/IHJlcGxhY2VWYXJzKFZFUlNJT05fUFJFRElDVF9QQVRILCBbdGhpcy5pZCwgdGhpcy52ZXJzaW9uSWRdKSA6IHJlcGxhY2VWYXJzKFBSRURJQ1RfUEFUSCwgW3RoaXMuaWRdKSk7XG4gICAgICByZXR1cm4gd3JhcFRva2VuKHRoaXMuX2NvbmZpZywgZnVuY3Rpb24gKGhlYWRlcnMpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHsgaW5wdXRzOiBpbnB1dHMubWFwKGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1lZGlhUHJlZGljdChpbnB1dCwgdmlkZW8gPyAndmlkZW8nIDogJ2ltYWdlJyk7XG4gICAgICAgICAgfSkgfTtcbiAgICAgICAgaWYgKGNvbmZpZyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjb25maWcpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBwYXJhbXNbJ21vZGVsJ10gPSB7XG4gICAgICAgICAgICBvdXRwdXRfaW5mbzoge1xuICAgICAgICAgICAgICBvdXRwdXRfY29uZmlnOiBmb3JtYXRPYmplY3RGb3JTbmFrZUNhc2UoY29uZmlnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBheGlvcy5wb3N0KHVybCwgcGFyYW1zLCB7IGhlYWRlcnM6IGhlYWRlcnMgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gY2xvbmUocmVzcG9uc2UuZGF0YSk7XG4gICAgICAgICAgICBkYXRhLnJhd0RhdGEgPSBjbG9uZShyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgdmVyc2lvbiBvZiB0aGUgbW9kZWwgc3BlY2lmaWVkIGJ5IGl0cyBpZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgdmVyc2lvbklkICAgVGhlIG1vZGVsJ3MgaWRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlKHJlc3BvbnNlLCBlcnJvcil9IEEgUHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aXRoIHRoZSBBUEkgcmVzcG9uc2Ugb3IgcmVqZWN0ZWQgd2l0aCBhbiBlcnJvclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRWZXJzaW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmVyc2lvbih2ZXJzaW9uSWQpIHtcbiAgICAgIC8vIFRPRE8oUm9rKSBNRURJVU06IFRoZSB2ZXJzaW9uIElEIGlzbid0IFVSSSBlbmNvZGVkLCBhcyBvcHBvc2VkIHRvIHRoZSBtb2RlbCBJRC4gVGhpcyBzaG91bGQgcHJvYmFibHkgYmVcbiAgICAgIC8vICBjb25zaXN0ZW50IC0gaS5lLiB0aGUgc2FtZSBpbiBib3RoIGNhc2VzLlxuICAgICAgdmFyIHVybCA9ICcnICsgdGhpcy5fY29uZmlnLmJhc2VQYXRoICsgcmVwbGFjZVZhcnMoTU9ERUxfVkVSU0lPTl9QQVRILCBbdGhpcy5pZCwgdmVyc2lvbklkXSk7XG4gICAgICByZXR1cm4gd3JhcFRva2VuKHRoaXMuX2NvbmZpZywgZnVuY3Rpb24gKGhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBheGlvcy5nZXQodXJsLCB7IGhlYWRlcnM6IGhlYWRlcnMgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gY2xvbmUocmVzcG9uc2UuZGF0YSk7XG4gICAgICAgICAgICBkYXRhLnJhd0RhdGEgPSBjbG9uZShyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiB2ZXJzaW9ucyBvZiB0aGUgbW9kZWxcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gICAgIG9wdGlvbnMgICAgIE9iamVjdCB3aXRoIGtleXMgZXhwbGFpbmVkIGJlbG93OiAob3B0aW9uYWwpXG4gICAgICogICBAcGFyYW0ge251bWJlcn0gICAgIG9wdGlvbnMucGFnZSAgICAgICAgVGhlIHBhZ2UgbnVtYmVyIChvcHRpb25hbCwgZGVmYXVsdDogMSlcbiAgICAgKiAgIEBwYXJhbSB7bnVtYmVyfSAgICAgb3B0aW9ucy5wZXJQYWdlICAgICBOdW1iZXIgb2YgaW1hZ2VzIHRvIHJldHVybiBwZXIgcGFnZSAob3B0aW9uYWwsIGRlZmF1bHQ6IDIwKVxuICAgICAqIEByZXR1cm4ge1Byb21pc2UocmVzcG9uc2UsIGVycm9yKX0gQSBQcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdpdGggdGhlIEFQSSByZXNwb25zZSBvciByZWplY3RlZCB3aXRoIGFuIGVycm9yXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFZlcnNpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmVyc2lvbnMoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogeyBwYWdlOiAxLCBwZXJQYWdlOiAyMCB9O1xuXG4gICAgICB2YXIgdXJsID0gJycgKyB0aGlzLl9jb25maWcuYmFzZVBhdGggKyByZXBsYWNlVmFycyhNT0RFTF9WRVJTSU9OU19QQVRILCBbdGhpcy5pZF0pO1xuICAgICAgcmV0dXJuIHdyYXBUb2tlbih0aGlzLl9jb25maWcsIGZ1bmN0aW9uIChoZWFkZXJzKSB7XG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgcGFyYW1zOiB7ICdwZXJfcGFnZSc6IG9wdGlvbnMucGVyUGFnZSwgJ3BhZ2UnOiBvcHRpb25zLnBhZ2UgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGF4aW9zLmdldCh1cmwsIGRhdGEpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGNsb25lKHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICAgICAgZGF0YS5yYXdEYXRhID0gY2xvbmUocmVzcG9uc2UuZGF0YSk7XG4gICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgdGhlIG1vZGVsJ3Mgb3V0cHV0IGluZm9cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlKE1vZGVsLCBlcnJvcil9IEEgUHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aXRoIGEgTW9kZWwgaW5zdGFuY2Ugb3IgcmVqZWN0ZWQgd2l0aCBhbiBlcnJvclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRPdXRwdXRJbmZvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3V0cHV0SW5mbygpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICB2YXIgdXJsID0gJycgKyB0aGlzLl9jb25maWcuYmFzZVBhdGggKyAodGhpcy52ZXJzaW9uSWQgPyByZXBsYWNlVmFycyhNT0RFTF9WRVJTSU9OX09VVFBVVF9QQVRILCBbdGhpcy5pZCwgdGhpcy52ZXJzaW9uSWRdKSA6IHJlcGxhY2VWYXJzKE1PREVMX09VVFBVVF9QQVRILCBbdGhpcy5pZF0pKTtcbiAgICAgIHJldHVybiB3cmFwVG9rZW4odGhpcy5fY29uZmlnLCBmdW5jdGlvbiAoaGVhZGVycykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGF4aW9zLmdldCh1cmwsIHsgaGVhZGVyczogaGVhZGVycyB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgcmVzb2x2ZShuZXcgTW9kZWwoX3RoaXM1Ll9jb25maWcsIHJlc3BvbnNlLmRhdGEubW9kZWwpKTtcbiAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIHRoZSBtb2RlbCdzIGlucHV0c1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgb3B0aW9ucyAgICAgT2JqZWN0IHdpdGgga2V5cyBleHBsYWluZWQgYmVsb3c6IChvcHRpb25hbClcbiAgICAgKiAgIEBwYXJhbSB7bnVtYmVyfSAgICAgb3B0aW9ucy5wYWdlICAgICAgICBUaGUgcGFnZSBudW1iZXIgKG9wdGlvbmFsLCBkZWZhdWx0OiAxKVxuICAgICAqICAgQHBhcmFtIHtudW1iZXJ9ICAgICBvcHRpb25zLnBlclBhZ2UgICAgIE51bWJlciBvZiBpbWFnZXMgdG8gcmV0dXJuIHBlciBwYWdlIChvcHRpb25hbCwgZGVmYXVsdDogMjApXG4gICAgICogQHJldHVybiB7UHJvbWlzZShyZXNwb25zZSwgZXJyb3IpfSBBIFByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2l0aCB0aGUgQVBJIHJlc3BvbnNlIG9yIHJlamVjdGVkIHdpdGggYW4gZXJyb3JcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0SW5wdXRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5wdXRzKCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHsgcGFnZTogMSwgcGVyUGFnZTogMjAgfTtcblxuICAgICAgdmFyIHVybCA9ICcnICsgdGhpcy5fY29uZmlnLmJhc2VQYXRoICsgKHRoaXMudmVyc2lvbklkID8gcmVwbGFjZVZhcnMoTU9ERUxfVkVSU0lPTl9JTlBVVFNfUEFUSCwgW3RoaXMuaWQsIHRoaXMudmVyc2lvbklkXSkgOiByZXBsYWNlVmFycyhNT0RFTF9JTlBVVFNfUEFUSCwgW3RoaXMuaWRdKSk7XG4gICAgICByZXR1cm4gd3JhcFRva2VuKHRoaXMuX2NvbmZpZywgZnVuY3Rpb24gKGhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBheGlvcy5nZXQodXJsLCB7XG4gICAgICAgICAgICBwYXJhbXM6IHsgJ3Blcl9wYWdlJzogb3B0aW9ucy5wZXJQYWdlLCAncGFnZSc6IG9wdGlvbnMucGFnZSB9LFxuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyc1xuICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGNsb25lKHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICAgICAgZGF0YS5yYXdEYXRhID0gY2xvbmUocmVzcG9uc2UuZGF0YSk7XG4gICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgQSBzdHJpbmcgcG9pbnRpbmcgdG8gYW4gaW1hZ2UgcmVzb3VyY2UuIEEgc3RyaW5nIG11c3QgYmUgYSB1cmxcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIEEgY29uZmlndXJhdGlvbiBvYmplY3QgY29uc2lzdGluZyBvZiB0aGUgZm9sbG93aW5nIHJlcXVpcmVkIGtleXNcbiAgICAgKiAgIEBwYXJhbSB7c3RyaW5nfSBjb25maWcuaWQgVGhlIGlkIG9mIHRoZSBmZWVkYmFjayByZXF1ZXN0XG4gICAgICogICBAcGFyYW0ge29iamVjdH0gY29uZmlnLmRhdGEgVGhlIGZlZWRiYWNrIGRhdGEgdG8gYmUgc2VudFxuICAgICAqICAgQHBhcmFtIHtvYmplY3R9IGNvbmZpZy5pbmZvIE1ldGEgZGF0YSByZWxhdGVkIHRvIHRoZSBmZWVkYmFjayByZXF1ZXN0XG4gICAgICogQHJldHVybiB7UHJvbWlzZShyZXNwb25zZSwgZXJyb3IpfSBBIFByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2l0aCB0aGUgQVBJIHJlc3BvbnNlIG9yIHJlamVjdGVkIHdpdGggYW4gZXJyb3JcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZmVlZGJhY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmZWVkYmFjayhpbnB1dCwgX3JlZikge1xuICAgICAgdmFyIGlkID0gX3JlZi5pZCxcbiAgICAgICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgICAgIGluZm8gPSBfcmVmLmluZm87XG5cbiAgICAgIHZhciB1cmwgPSAnJyArIHRoaXMuX2NvbmZpZy5iYXNlUGF0aCArICh0aGlzLnZlcnNpb25JZCA/IHJlcGxhY2VWYXJzKE1PREVMX1ZFUlNJT05fRkVFREJBQ0tfUEFUSCwgW3RoaXMuaWQsIHRoaXMudmVyc2lvbklkXSkgOiByZXBsYWNlVmFycyhNT0RFTF9GRUVEQkFDS19QQVRILCBbdGhpcy5pZF0pKTtcbiAgICAgIHZhciBtZWRpYSA9IGZvcm1hdE1lZGlhUHJlZGljdChpbnB1dCkuZGF0YTtcbiAgICAgIGluZm8uZXZlbnRUeXBlID0gJ2Fubm90YXRpb24nO1xuICAgICAgdmFyIGJvZHkgPSB7XG4gICAgICAgIGlucHV0OiB7XG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24obWVkaWEsIGRhdGEpLFxuICAgICAgICAgICdmZWVkYmFja19pbmZvJzogZm9ybWF0T2JqZWN0Rm9yU25ha2VDYXNlKGluZm8pXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gd3JhcFRva2VuKHRoaXMuX2NvbmZpZywgZnVuY3Rpb24gKGhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBheGlvcy5wb3N0KHVybCwgYm9keSwge1xuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyc1xuICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IF9yZWYyLmRhdGE7XG5cbiAgICAgICAgICAgIHZhciBkID0gY2xvbmUoZGF0YSk7XG4gICAgICAgICAgICBkLnJhd0RhdGEgPSBjbG9uZShkYXRhKTtcbiAgICAgICAgICAgIHJlc29sdmUoZCk7XG4gICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTW9kZWw7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gTW9kZWw7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/clarifai/dist/Model.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/clarifai/dist/ModelVersion.js":
/*!****************************************************!*\
  !*** ./node_modules/clarifai/dist/ModelVersion.js ***!
  \****************************************************/
/***/ ((module) => {

eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * class representing a version of a model\n * @class\n */\nvar ModelVersion = function ModelVersion(_config, data) {\n  _classCallCheck(this, ModelVersion);\n\n  this.id = data.id;\n  this.created_at = this.createdAt = data.created_at || data.createdAt;\n  this.status = data.status;\n  this.active_concept_count = data.active_concept_count;\n  this.metrics = data.metrics;\n  this._config = _config;\n  this.rawData = data;\n};\n\n;\n\nmodule.exports = ModelVersion;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2xhcmlmYWkvZGlzdC9Nb2RlbFZlcnNpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsa0RBQWtELDBDQUEwQzs7QUFFNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWZyaWdlcmF0b3JfYXBwLy4vbm9kZV9tb2R1bGVzL2NsYXJpZmFpL2Rpc3QvTW9kZWxWZXJzaW9uLmpzP2Q1MWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogY2xhc3MgcmVwcmVzZW50aW5nIGEgdmVyc2lvbiBvZiBhIG1vZGVsXG4gKiBAY2xhc3NcbiAqL1xudmFyIE1vZGVsVmVyc2lvbiA9IGZ1bmN0aW9uIE1vZGVsVmVyc2lvbihfY29uZmlnLCBkYXRhKSB7XG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNb2RlbFZlcnNpb24pO1xuXG4gIHRoaXMuaWQgPSBkYXRhLmlkO1xuICB0aGlzLmNyZWF0ZWRfYXQgPSB0aGlzLmNyZWF0ZWRBdCA9IGRhdGEuY3JlYXRlZF9hdCB8fCBkYXRhLmNyZWF0ZWRBdDtcbiAgdGhpcy5zdGF0dXMgPSBkYXRhLnN0YXR1cztcbiAgdGhpcy5hY3RpdmVfY29uY2VwdF9jb3VudCA9IGRhdGEuYWN0aXZlX2NvbmNlcHRfY291bnQ7XG4gIHRoaXMubWV0cmljcyA9IGRhdGEubWV0cmljcztcbiAgdGhpcy5fY29uZmlnID0gX2NvbmZpZztcbiAgdGhpcy5yYXdEYXRhID0gZGF0YTtcbn07XG5cbjtcblxubW9kdWxlLmV4cG9ydHMgPSBNb2RlbFZlcnNpb247Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/clarifai/dist/ModelVersion.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/clarifai/dist/Models.js":
/*!**********************************************!*\
  !*** ./node_modules/clarifai/dist/Models.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar axios = __webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\");\nvar Promise = __webpack_require__(/*! promise */ \"(rsc)/./node_modules/promise/index.js\");\nvar Model = __webpack_require__(/*! ./Model */ \"(rsc)/./node_modules/clarifai/dist/Model.js\");\nvar Concepts = __webpack_require__(/*! ./Concepts */ \"(rsc)/./node_modules/clarifai/dist/Concepts.js\");\n\nvar _require = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/clarifai/dist/constants.js\"),\n    API = _require.API,\n    ERRORS = _require.ERRORS,\n    replaceVars = _require.replaceVars;\n\nvar _require2 = __webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/clarifai/dist/helpers.js\"),\n    isSuccess = _require2.isSuccess,\n    checkType = _require2.checkType,\n    clone = _require2.clone;\n\nvar _require3 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/clarifai/dist/utils.js\"),\n    wrapToken = _require3.wrapToken,\n    formatModel = _require3.formatModel;\n\nvar MODELS_PATH = API.MODELS_PATH,\n    MODEL_PATH = API.MODEL_PATH,\n    MODEL_SEARCH_PATH = API.MODEL_SEARCH_PATH,\n    MODEL_VERSION_PATH = API.MODEL_VERSION_PATH;\n\n/**\n * class representing a collection of models\n * @class\n */\n\nvar Models = function () {\n  function Models(_config) {\n    var _this = this;\n\n    var rawData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    _classCallCheck(this, Models);\n\n    this._config = _config;\n    this.rawData = rawData;\n    rawData.forEach(function (modelData, index) {\n      _this[index] = new Model(_this._config, modelData);\n    });\n    this.length = rawData.length;\n  }\n\n  /**\n   * Returns a Model instance given model id or name. It will call search if name is given.\n   * @param {string|object}    model       If string, it is assumed to be model id. Otherwise, if object is given, it can have any of the following keys:\n   *   @param {string}           model.id          Model id\n   *   @param {string}           model.name        Model name\n   *   @param {string}           model.version     Model version\n   *   @param {string}           model.type        This can be \"concept\", \"color\", \"embed\", \"facedetect\", \"cluster\" or \"blur\"\n   * @return {Promise(Model, error)} A Promise that is fulfilled with a Model instance or rejected with an error\n   */\n\n\n  _createClass(Models, [{\n    key: 'initModel',\n    value: function initModel(model) {\n      var _this2 = this;\n\n      var data = {};\n      var fn = void 0;\n      if (checkType(/String/, model)) {\n        data.id = model;\n      } else {\n        data = model;\n      }\n      if (data.id) {\n        fn = function fn(resolve, reject) {\n          resolve(new Model(_this2._config, data));\n        };\n      } else {\n        fn = function fn(resolve, reject) {\n          _this2.search(data.name, data.type).then(function (models) {\n            if (data.version) {\n              resolve(models.rawData.filter(function (model) {\n                return model.modelVersion.id === data.version;\n              }));\n            } else {\n              resolve(models[0]);\n            }\n          }, reject).catch(reject);\n        };\n      }\n      return new Promise(fn);\n    }\n\n    /**\n     * Calls predict given model info and inputs to predict on\n     * @param {string|object}            model       If string, it is assumed to be model id. Otherwise, if object is given, it can have any of the following keys:\n     *   @param {string}                   model.id          Model id\n     *   @param {string}                   model.name        Model name\n     *   @param {string}                   model.version     Model version\n     *   @param {string}                   model.language    Model language (only for Clarifai's public models)\n     *   @param {string}                   model.type        This can be \"concept\", \"color\", \"embed\", \"facedetect\", \"cluster\" or \"blur\"\n     * @param {object[]|object|string}   inputs    An array of objects/object/string pointing to an image resource. A string can either be a url or base64 image bytes. Object keys explained below:\n     *    @param {object}                  inputs[].image     Object with keys explained below:\n     *       @param {string}                 inputs[].image.(url|base64)  Can be a publicly accessibly url or base64 string representing image bytes (required)\n     * @param {boolean} isVideo  indicates if the input should be processed as a video (default false)\n     * @return {Promise(response, error)} A Promise that is fulfilled with the API response or rejected with an error\n     */\n\n  }, {\n    key: 'predict',\n    value: function predict(model, inputs) {\n      var _this3 = this;\n\n      var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (checkType(/Boolean/, config)) {\n        console.warn('\"isVideo\" argument is deprecated, consider using the configuration object instead');\n        config = {\n          video: config\n        };\n      }\n      if (model.language) {\n        config.language = model.language;\n      }\n      return new Promise(function (resolve, reject) {\n        _this3.initModel(model).then(function (modelObj) {\n          modelObj.predict(inputs, config).then(resolve, reject).catch(reject);\n        }, reject);\n      });\n    }\n\n    /**\n     * Calls train on a model and creates a new model version given model info\n     * @param {string|object}            model       If string, it is assumed to be model id. Otherwise, if object is given, it can have any of the following keys:\n     *   @param {string}                   model.id          Model id\n     *   @param {string}                   model.name        Model name\n     *   @param {string}                   model.version     Model version\n     *   @param {string}                   model.type        This can be \"concept\", \"color\", \"embed\", \"facedetect\", \"cluster\" or \"blur\"\n     * @param {boolean}                  sync        If true, this returns after model has completely trained. If false, this immediately returns default api response.\n     * @return {Promise(Model, error)} A Promise that is fulfilled with a Model instance or rejected with an error\n     */\n\n  }, {\n    key: 'train',\n    value: function train(model) {\n      var _this4 = this;\n\n      var sync = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      return new Promise(function (resolve, reject) {\n        _this4.initModel(model).then(function (model) {\n          model.train(sync).then(resolve, reject).catch(reject);\n        }, reject);\n      });\n    }\n\n    /**\n     *\n     * @param {string|object}            model       If string, it is assumed to be model id. Otherwise, if object is given, it can have any of the following keys:\n     *   @param {string}                   model.id          Model id\n     *   @param {string}                   model.name        Model name\n     *   @param {string}                   model.version     Model version\n     *   @param {string}                   model.type        This can be \"concept\", \"color\", \"embed\", \"facedetect\", \"cluster\" or \"blur\"\n     * @param {string} input A string pointing to an image resource. A string must be a url\n     * @param {object} config A configuration object consisting of the following required keys\n     *   @param {string} config.id The id of the feedback request\n     *   @param {object} config.data The feedback data to be sent\n     *   @param {object} config.info Meta data related to the feedback request\n     */\n\n  }, {\n    key: 'feedback',\n    value: function feedback(model, input, config) {\n      var _this5 = this;\n\n      return new Promise(function (resolve, reject) {\n        _this5.initModel(model).then(function (model) {\n          return model.feedback(input, config);\n        }).then(function (d) {\n          return resolve(d);\n        }).catch(function (e) {\n          return reject(e);\n        });\n      });\n    }\n\n    /**\n     * Returns a version of the model specified by its id\n     * @param {string|object}            model       If string, it is assumed to be model id. Otherwise, if object is given, it can have any of the following keys:\n     *   @param {string}                   model.id          Model id\n     *   @param {string}                   model.name        Model name\n     *   @param {string}                   model.version     Model version\n     *   @param {string}                   model.type        This can be \"concept\", \"color\", \"embed\", \"facedetect\", \"cluster\" or \"blur\"\n     * @param {string}     versionId   The model's id\n     * @return {Promise(response, error)} A Promise that is fulfilled with the API response or rejected with an error\n     */\n\n  }, {\n    key: 'getVersion',\n    value: function getVersion(model, versionId) {\n      var _this6 = this;\n\n      return new Promise(function (resolve, reject) {\n        _this6.initModel(model).then(function (model) {\n          model.getVersion(versionId).then(resolve, reject).catch(reject);\n        }, reject);\n      });\n    }\n\n    /**\n     * Returns a list of versions of the model\n     * @param {string|object}            model       If string, it is assumed to be model id. Otherwise, if object is given, it can have any of the following keys:\n     *   @param {string}                   model.id          Model id\n     *   @param {string}                   model.name        Model name\n     *   @param {string}                   model.version     Model version\n     *   @param {string}                   model.type        This can be \"concept\", \"color\", \"embed\", \"facedetect\", \"cluster\" or \"blur\"\n     * @param {object}                   options     Object with keys explained below: (optional)\n     *   @param {number}                   options.page        The page number (optional, default: 1)\n     *   @param {number}                   options.perPage     Number of images to return per page (optional, default: 20)\n     * @return {Promise(response, error)} A Promise that is fulfilled with the API response or rejected with an error\n     */\n\n  }, {\n    key: 'getVersions',\n    value: function getVersions(model) {\n      var _this7 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { page: 1, perPage: 20 };\n\n      return new Promise(function (resolve, reject) {\n        _this7.initModel(model).then(function (model) {\n          model.getVersions(options).then(resolve, reject).catch(reject);\n        }, reject);\n      });\n    }\n\n    /**\n     * Returns all the model's output info\n     * @param {string|object}            model       If string, it is assumed to be model id. Otherwise, if object is given, it can have any of the following keys:\n     *   @param {string}                   model.id          Model id\n     *   @param {string}                   model.name        Model name\n     *   @param {string}                   model.version     Model version\n     *   @param {string}                   model.type        This can be \"concept\", \"color\", \"embed\", \"facedetect\", \"cluster\" or \"blur\"\n     * @return {Promise(Model, error)} A Promise that is fulfilled with a Model instance or rejected with an error\n     */\n\n  }, {\n    key: 'getOutputInfo',\n    value: function getOutputInfo(model) {\n      var _this8 = this;\n\n      return new Promise(function (resolve, reject) {\n        _this8.initModel(model).then(function (model) {\n          model.getOutputInfo().then(resolve, reject).catch(reject);\n        }, reject);\n      });\n    }\n\n    /**\n     * Returns all the models\n     * @param {Object}     options     Object with keys explained below: (optional)\n     *   @param {Number}     options.page        The page number (optional, default: 1)\n     *   @param {Number}     options.perPage     Number of images to return per page (optional, default: 20)\n     * @return {Promise(Models, error)} A Promise that is fulfilled with an instance of Models or rejected with an error\n     */\n\n  }, {\n    key: 'list',\n    value: function list() {\n      var _this9 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { page: 1, perPage: 20 };\n\n      var url = '' + this._config.basePath + MODELS_PATH;\n      return wrapToken(this._config, function (headers) {\n        return new Promise(function (resolve, reject) {\n          axios.get(url, {\n            params: { 'per_page': options.perPage, 'page': options.page },\n            headers: headers\n          }).then(function (response) {\n            if (isSuccess(response)) {\n              resolve(new Models(_this9._config, response.data.models));\n            } else {\n              reject(response);\n            }\n          }, reject);\n        });\n      });\n    }\n\n    /**\n     * Create a model\n     * @param {string|object}                  model                                  If string, it is assumed to be the model id. Otherwise, if object is given, it can have any of the following keys:\n     *   @param {string}                         model.id                               Model id\n     *   @param {string}                         model.name                             Model name\n     * @param {object[]|string[]|Concepts[]}   conceptsData                           List of objects with ids, concept id strings or an instance of Concepts object\n     * @param {Object}                         options                                Object with keys explained below:\n     *   @param {boolean}                        options.conceptsMutuallyExclusive      Do you expect to see more than one of the concepts in this model in the SAME image? Set to false (default) if so. Otherwise, set to true.\n     *   @param {boolean}                        options.closedEnvironment              Do you expect to run the trained model on images that do not contain ANY of the concepts in the model? Set to false (default) if so. Otherwise, set to true.\n     * @return {Promise(Model, error)} A Promise that is fulfilled with an instance of Model or rejected with an error\n     */\n\n  }, {\n    key: 'create',\n    value: function create(model) {\n      var _this10 = this;\n\n      var conceptsData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var concepts = conceptsData instanceof Concepts ? conceptsData.toObject('id') : conceptsData.map(function (concept) {\n        var val = concept;\n        if (checkType(/String/, concept)) {\n          val = { 'id': concept };\n        }\n        return val;\n      });\n      var modelObj = model;\n      if (checkType(/String/, model)) {\n        modelObj = { id: model, name: model };\n      }\n      if (modelObj.id === undefined) {\n        throw ERRORS.paramsRequired('Model ID');\n      }\n      var url = '' + this._config.basePath + MODELS_PATH;\n      var data = { model: modelObj };\n      data['model']['output_info'] = {\n        'data': {\n          concepts: concepts\n        },\n        'output_config': {\n          'concepts_mutually_exclusive': !!options.conceptsMutuallyExclusive,\n          'closed_environment': !!options.closedEnvironment\n        }\n      };\n\n      return wrapToken(this._config, function (headers) {\n        return new Promise(function (resolve, reject) {\n          axios.post(url, data, { headers: headers }).then(function (response) {\n            if (isSuccess(response)) {\n              resolve(new Model(_this10._config, response.data.model));\n            } else {\n              reject(response);\n            }\n          }, reject);\n        });\n      });\n    }\n\n    /**\n     * Returns a model specified by ID\n     * @param {String}     id          The model's id\n     * @return {Promise(Model, error)} A Promise that is fulfilled with an instance of Model or rejected with an error\n     */\n\n  }, {\n    key: 'get',\n    value: function get(id) {\n      var _this11 = this;\n\n      var url = '' + this._config.basePath + replaceVars(MODEL_PATH, [id]);\n      return wrapToken(this._config, function (headers) {\n        return new Promise(function (resolve, reject) {\n          axios.get(url, { headers: headers }).then(function (response) {\n            if (isSuccess(response)) {\n              resolve(new Model(_this11._config, response.data.model));\n            } else {\n              reject(response);\n            }\n          }, reject);\n        });\n      });\n    }\n\n    /**\n     * Update a model's or a list of models' output config or concepts\n     * @param {object|object[]}      models                                 Can be a single model object or list of model objects with the following attrs:\n     *   @param {string}               models.id                                    The id of the model to apply changes to (Required)\n     *   @param {string}               models.name                                  The new name of the model to update with\n     *   @param {boolean}              models.conceptsMutuallyExclusive             Do you expect to see more than one of the concepts in this model in the SAME image? Set to false (default) if so. Otherwise, set to true.\n     *   @param {boolean}              models.closedEnvironment                     Do you expect to run the trained model on images that do not contain ANY of the concepts in the model? Set to false (default) if so. Otherwise, set to true.\n     *   @param {object[]}             models.concepts                              An array of concept objects or string\n     *     @param {object|string}        models.concepts[].concept                    If string is given, this is interpreted as concept id. Otherwise, if object is given, client expects the following attributes\n     *       @param {string}             models.concepts[].concept.id                   The id of the concept to attach to the model\n     *   @param {object[]}             models.action                                The action to perform on the given concepts. Possible values are 'merge', 'remove', or 'overwrite'. Default: 'merge'\n     * @return {Promise(Models, error)} A Promise that is fulfilled with an instance of Models or rejected with an error\n     */\n\n  }, {\n    key: 'update',\n    value: function update(models) {\n      var _this12 = this;\n\n      var url = '' + this._config.basePath + MODELS_PATH;\n      var modelsList = Array.isArray(models) ? models : [models];\n      var data = { models: modelsList.map(formatModel) };\n      data['action'] = models.action || 'merge';\n      return wrapToken(this._config, function (headers) {\n        return new Promise(function (resolve, reject) {\n          axios.patch(url, data, { headers: headers }).then(function (response) {\n            if (isSuccess(response)) {\n              resolve(new Models(_this12._config, response.data.models));\n            } else {\n              reject(response);\n            }\n          }, reject);\n        });\n      });\n    }\n\n    /**\n     * Update model by merging concepts\n     * @param {object|object[]}      model                                 Can be a single model object or list of model objects with the following attrs:\n     *   @param {string}               model.id                                    The id of the model to apply changes to (Required)\n     *   @param {object[]}             model.concepts                              An array of concept objects or string\n     *     @param {object|string}        model.concepts[].concept                    If string is given, this is interpreted as concept id. Otherwise, if object is given, client expects the following attributes\n     *       @param {string}             model.concepts[].concept.id                   The id of the concept to attach to the model\n     */\n\n  }, {\n    key: 'mergeConcepts',\n    value: function mergeConcepts() {\n      var model = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      model.action = 'merge';\n      return this.update(model);\n    }\n\n    /**\n     * Update model by removing concepts\n     * @param {object|object[]}      model                                 Can be a single model object or list of model objects with the following attrs:\n     *   @param {string}               model.id                                    The id of the model to apply changes to (Required)\n     *   @param {object[]}             model.concepts                              An array of concept objects or string\n     *     @param {object|string}        model.concepts[].concept                    If string is given, this is interpreted as concept id. Otherwise, if object is given, client expects the following attributes\n     *       @param {string}             model.concepts[].concept.id                   The id of the concept to attach to the model\n     */\n\n  }, {\n    key: 'deleteConcepts',\n    value: function deleteConcepts() {\n      var model = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      model.action = 'remove';\n      return this.update(model);\n    }\n\n    /**\n     * Update model by overwriting concepts\n     * @param {object|object[]}      model                                 Can be a single model object or list of model objects with the following attrs:\n     *   @param {string}               model.id                                    The id of the model to apply changes to (Required)\n     *   @param {object[]}             model.concepts                              An array of concept objects or string\n     *     @param {object|string}        model.concepts[].concept                    If string is given, this is interpreted as concept id. Otherwise, if object is given, client expects the following attributes\n     *       @param {string}             model.concepts[].concept.id                   The id of the concept to attach to the model\n     */\n\n  }, {\n    key: 'overwriteConcepts',\n    value: function overwriteConcepts() {\n      var model = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      model.action = 'overwrite';\n      return this.update(model);\n    }\n\n    /**\n     * Deletes all models (if no ids and versionId given) or a model (if given id) or a model version (if given id and verion id)\n     * @param {String|String[]}      ids         Can be a single string or an array of strings representing the model ids\n     * @param {String}               versionId   The model's version id\n     * @return {Promise(response, error)} A Promise that is fulfilled with the API response or rejected with an error\n     */\n\n  }, {\n    key: 'delete',\n    value: function _delete(ids) {\n      var versionId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      var request = void 0,\n          url = void 0,\n          data = void 0;\n      var id = ids;\n\n      if (checkType(/String/, ids) || checkType(/Array/, ids) && ids.length === 1) {\n        if (versionId) {\n          url = '' + this._config.basePath + replaceVars(MODEL_VERSION_PATH, [id, versionId]);\n        } else {\n          url = '' + this._config.basePath + replaceVars(MODEL_PATH, [id]);\n        }\n        request = wrapToken(this._config, function (headers) {\n          return new Promise(function (resolve, reject) {\n            axios.delete(url, { headers: headers }).then(function (response) {\n              var data = clone(response.data);\n              data.rawData = clone(response.data);\n              resolve(data);\n            }, reject);\n          });\n        });\n      } else {\n        if (!ids && !versionId) {\n          url = '' + this._config.basePath + MODELS_PATH;\n          data = { 'delete_all': true };\n        } else if (!versionId && ids.length > 1) {\n          url = '' + this._config.basePath + MODELS_PATH;\n          data = { ids: ids };\n        } else {\n          throw ERRORS.INVALID_DELETE_ARGS;\n        }\n        request = wrapToken(this._config, function (headers) {\n          return new Promise(function (resolve, reject) {\n            axios({\n              method: 'delete',\n              url: url,\n              data: data,\n              headers: headers\n            }).then(function (response) {\n              var data = clone(response.data);\n              data.rawData = clone(response.data);\n              resolve(data);\n            }, reject);\n          });\n        });\n      }\n\n      return request;\n    }\n\n    /**\n     * Search for models by name or type\n     * @param {String}     name        The model name\n     * @param {String}     type        This can be \"concept\", \"color\", \"embed\", \"facedetect\", \"cluster\" or \"blur\"\n     * @return {Promise(models, error)} A Promise that is fulfilled with an instance of Models or rejected with an error\n     */\n\n  }, {\n    key: 'search',\n    value: function search(name) {\n      var _this13 = this;\n\n      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      var url = '' + this._config.basePath + MODEL_SEARCH_PATH;\n      return wrapToken(this._config, function (headers) {\n        var params = {\n          'model_query': {\n            name: name,\n            type: type\n          }\n        };\n        return new Promise(function (resolve, reject) {\n          axios.post(url, params, { headers: headers }).then(function (response) {\n            if (isSuccess(response)) {\n              resolve(new Models(_this13._config, response.data.models));\n            } else {\n              reject(response);\n            }\n          }, reject);\n        });\n      });\n    }\n  }]);\n\n  return Models;\n}();\n\nmodule.exports = Models;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2xhcmlmYWkvZGlzdC9Nb2RlbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsaUNBQWlDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELCtEQUErRCx5REFBeUQscUVBQXFFLDZEQUE2RCx3QkFBd0I7O0FBRWpqQixrREFBa0QsMENBQTBDOztBQUU1RixZQUFZLG1CQUFPLENBQUMsNkRBQU87QUFDM0IsY0FBYyxtQkFBTyxDQUFDLHNEQUFTO0FBQy9CLFlBQVksbUJBQU8sQ0FBQyw0REFBUztBQUM3QixlQUFlLG1CQUFPLENBQUMsa0VBQVk7O0FBRW5DLGVBQWUsbUJBQU8sQ0FBQyxvRUFBYTtBQUNwQztBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsZ0VBQVc7QUFDbkM7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixtQkFBTyxDQUFDLDREQUFTO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CLGVBQWUsa0JBQWtCO0FBQ2pDLGVBQWUsa0JBQWtCO0FBQ2pDLGVBQWUsa0JBQWtCO0FBQ2pDLGVBQWUsa0JBQWtCO0FBQ2pDLGNBQWMsdUJBQXVCO0FBQ3JDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekMsaUJBQWlCLDBCQUEwQjtBQUMzQyxpQkFBaUIsMEJBQTBCO0FBQzNDLGlCQUFpQiwwQkFBMEI7QUFDM0MsaUJBQWlCLDBCQUEwQjtBQUMzQyxpQkFBaUIsMEJBQTBCO0FBQzNDLGVBQWUsMEJBQTBCO0FBQ3pDLGtCQUFrQix5QkFBeUI7QUFDM0MscUJBQXFCLHdCQUF3QjtBQUM3QyxlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCLDBCQUEwQjtBQUMxQzs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDLGlCQUFpQiwwQkFBMEI7QUFDM0MsaUJBQWlCLDBCQUEwQjtBQUMzQyxpQkFBaUIsMEJBQTBCO0FBQzNDLGlCQUFpQiwwQkFBMEI7QUFDM0MsZUFBZSwwQkFBMEI7QUFDekMsZ0JBQWdCLHVCQUF1QjtBQUN2Qzs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDLGlCQUFpQiwwQkFBMEI7QUFDM0MsaUJBQWlCLDBCQUEwQjtBQUMzQyxpQkFBaUIsMEJBQTBCO0FBQzNDLGlCQUFpQiwwQkFBMEI7QUFDM0MsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDLGlCQUFpQiwwQkFBMEI7QUFDM0MsaUJBQWlCLDBCQUEwQjtBQUMzQyxpQkFBaUIsMEJBQTBCO0FBQzNDLGlCQUFpQiwwQkFBMEI7QUFDM0MsZUFBZSxZQUFZO0FBQzNCLGdCQUFnQiwwQkFBMEI7QUFDMUM7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QyxpQkFBaUIsMEJBQTBCO0FBQzNDLGlCQUFpQiwwQkFBMEI7QUFDM0MsaUJBQWlCLDBCQUEwQjtBQUMzQyxpQkFBaUIsMEJBQTBCO0FBQzNDLGVBQWUsMEJBQTBCO0FBQ3pDLGlCQUFpQiwwQkFBMEI7QUFDM0MsaUJBQWlCLDBCQUEwQjtBQUMzQyxnQkFBZ0IsMEJBQTBCO0FBQzFDOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsMEZBQTBGOztBQUUxRjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QyxpQkFBaUIsMEJBQTBCO0FBQzNDLGlCQUFpQiwwQkFBMEI7QUFDM0MsaUJBQWlCLDBCQUEwQjtBQUMzQyxpQkFBaUIsMEJBQTBCO0FBQzNDLGdCQUFnQix1QkFBdUI7QUFDdkM7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCLFlBQVk7QUFDN0IsaUJBQWlCLFlBQVk7QUFDN0IsZ0JBQWdCLHdCQUF3QjtBQUN4Qzs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLDBGQUEwRjs7QUFFMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbURBQW1EO0FBQ3pFO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGdDQUFnQztBQUMvQyxpQkFBaUIsZ0NBQWdDO0FBQ2pELGlCQUFpQixnQ0FBZ0M7QUFDakQsZUFBZSxnQ0FBZ0M7QUFDL0MsZUFBZSxnQ0FBZ0M7QUFDL0MsaUJBQWlCLGdDQUFnQztBQUNqRCxpQkFBaUIsZ0NBQWdDO0FBQ2pELGdCQUFnQix1QkFBdUI7QUFDdkM7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLGtCQUFrQjtBQUNwRDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGdCQUFnQix1QkFBdUI7QUFDdkM7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQyxpQkFBaUIsc0JBQXNCO0FBQ3ZDLGlCQUFpQixzQkFBc0I7QUFDdkMsaUJBQWlCLHNCQUFzQjtBQUN2QyxpQkFBaUIsc0JBQXNCO0FBQ3ZDLGlCQUFpQixzQkFBc0I7QUFDdkMsbUJBQW1CLHNCQUFzQjtBQUN6QyxxQkFBcUIsb0JBQW9CO0FBQ3pDLGlCQUFpQixzQkFBc0I7QUFDdkMsZ0JBQWdCLHdCQUF3QjtBQUN4Qzs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGtCQUFrQjtBQUNyRDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckMsaUJBQWlCLHNCQUFzQjtBQUN2QyxpQkFBaUIsc0JBQXNCO0FBQ3ZDLG1CQUFtQixzQkFBc0I7QUFDekMscUJBQXFCLG9CQUFvQjtBQUN6Qzs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckMsaUJBQWlCLHNCQUFzQjtBQUN2QyxpQkFBaUIsc0JBQXNCO0FBQ3ZDLG1CQUFtQixzQkFBc0I7QUFDekMscUJBQXFCLG9CQUFvQjtBQUN6Qzs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckMsaUJBQWlCLHNCQUFzQjtBQUN2QyxpQkFBaUIsc0JBQXNCO0FBQ3ZDLG1CQUFtQixzQkFBc0I7QUFDekMscUJBQXFCLG9CQUFvQjtBQUN6Qzs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckMsZUFBZSxzQkFBc0I7QUFDckMsZ0JBQWdCLDBCQUEwQjtBQUMxQzs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsVUFBVTtBQUNWO0FBQ0EsbUJBQW1CO0FBQ25CLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGVBQWUsWUFBWTtBQUMzQixnQkFBZ0Isd0JBQXdCO0FBQ3hDOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGtCQUFrQjtBQUN0RDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVmcmlnZXJhdG9yX2FwcC8uL25vZGVfbW9kdWxlcy9jbGFyaWZhaS9kaXN0L01vZGVscy5qcz8xMjU4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIGF4aW9zID0gcmVxdWlyZSgnYXhpb3MnKTtcbnZhciBQcm9taXNlID0gcmVxdWlyZSgncHJvbWlzZScpO1xudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xudmFyIENvbmNlcHRzID0gcmVxdWlyZSgnLi9Db25jZXB0cycpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpLFxuICAgIEFQSSA9IF9yZXF1aXJlLkFQSSxcbiAgICBFUlJPUlMgPSBfcmVxdWlyZS5FUlJPUlMsXG4gICAgcmVwbGFjZVZhcnMgPSBfcmVxdWlyZS5yZXBsYWNlVmFycztcblxudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoJy4vaGVscGVycycpLFxuICAgIGlzU3VjY2VzcyA9IF9yZXF1aXJlMi5pc1N1Y2Nlc3MsXG4gICAgY2hlY2tUeXBlID0gX3JlcXVpcmUyLmNoZWNrVHlwZSxcbiAgICBjbG9uZSA9IF9yZXF1aXJlMi5jbG9uZTtcblxudmFyIF9yZXF1aXJlMyA9IHJlcXVpcmUoJy4vdXRpbHMnKSxcbiAgICB3cmFwVG9rZW4gPSBfcmVxdWlyZTMud3JhcFRva2VuLFxuICAgIGZvcm1hdE1vZGVsID0gX3JlcXVpcmUzLmZvcm1hdE1vZGVsO1xuXG52YXIgTU9ERUxTX1BBVEggPSBBUEkuTU9ERUxTX1BBVEgsXG4gICAgTU9ERUxfUEFUSCA9IEFQSS5NT0RFTF9QQVRILFxuICAgIE1PREVMX1NFQVJDSF9QQVRIID0gQVBJLk1PREVMX1NFQVJDSF9QQVRILFxuICAgIE1PREVMX1ZFUlNJT05fUEFUSCA9IEFQSS5NT0RFTF9WRVJTSU9OX1BBVEg7XG5cbi8qKlxuICogY2xhc3MgcmVwcmVzZW50aW5nIGEgY29sbGVjdGlvbiBvZiBtb2RlbHNcbiAqIEBjbGFzc1xuICovXG5cbnZhciBNb2RlbHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1vZGVscyhfY29uZmlnKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciByYXdEYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNb2RlbHMpO1xuXG4gICAgdGhpcy5fY29uZmlnID0gX2NvbmZpZztcbiAgICB0aGlzLnJhd0RhdGEgPSByYXdEYXRhO1xuICAgIHJhd0RhdGEuZm9yRWFjaChmdW5jdGlvbiAobW9kZWxEYXRhLCBpbmRleCkge1xuICAgICAgX3RoaXNbaW5kZXhdID0gbmV3IE1vZGVsKF90aGlzLl9jb25maWcsIG1vZGVsRGF0YSk7XG4gICAgfSk7XG4gICAgdGhpcy5sZW5ndGggPSByYXdEYXRhLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgTW9kZWwgaW5zdGFuY2UgZ2l2ZW4gbW9kZWwgaWQgb3IgbmFtZS4gSXQgd2lsbCBjYWxsIHNlYXJjaCBpZiBuYW1lIGlzIGdpdmVuLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9ICAgIG1vZGVsICAgICAgIElmIHN0cmluZywgaXQgaXMgYXNzdW1lZCB0byBiZSBtb2RlbCBpZC4gT3RoZXJ3aXNlLCBpZiBvYmplY3QgaXMgZ2l2ZW4sIGl0IGNhbiBoYXZlIGFueSBvZiB0aGUgZm9sbG93aW5nIGtleXM6XG4gICAqICAgQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICBtb2RlbC5pZCAgICAgICAgICBNb2RlbCBpZFxuICAgKiAgIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgbW9kZWwubmFtZSAgICAgICAgTW9kZWwgbmFtZVxuICAgKiAgIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgbW9kZWwudmVyc2lvbiAgICAgTW9kZWwgdmVyc2lvblxuICAgKiAgIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgbW9kZWwudHlwZSAgICAgICAgVGhpcyBjYW4gYmUgXCJjb25jZXB0XCIsIFwiY29sb3JcIiwgXCJlbWJlZFwiLCBcImZhY2VkZXRlY3RcIiwgXCJjbHVzdGVyXCIgb3IgXCJibHVyXCJcbiAgICogQHJldHVybiB7UHJvbWlzZShNb2RlbCwgZXJyb3IpfSBBIFByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2l0aCBhIE1vZGVsIGluc3RhbmNlIG9yIHJlamVjdGVkIHdpdGggYW4gZXJyb3JcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoTW9kZWxzLCBbe1xuICAgIGtleTogJ2luaXRNb2RlbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRNb2RlbChtb2RlbCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBkYXRhID0ge307XG4gICAgICB2YXIgZm4gPSB2b2lkIDA7XG4gICAgICBpZiAoY2hlY2tUeXBlKC9TdHJpbmcvLCBtb2RlbCkpIHtcbiAgICAgICAgZGF0YS5pZCA9IG1vZGVsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSA9IG1vZGVsO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEuaWQpIHtcbiAgICAgICAgZm4gPSBmdW5jdGlvbiBmbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICByZXNvbHZlKG5ldyBNb2RlbChfdGhpczIuX2NvbmZpZywgZGF0YSkpO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm4gPSBmdW5jdGlvbiBmbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBfdGhpczIuc2VhcmNoKGRhdGEubmFtZSwgZGF0YS50eXBlKS50aGVuKGZ1bmN0aW9uIChtb2RlbHMpIHtcbiAgICAgICAgICAgIGlmIChkYXRhLnZlcnNpb24pIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShtb2RlbHMucmF3RGF0YS5maWx0ZXIoZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsLm1vZGVsVmVyc2lvbi5pZCA9PT0gZGF0YS52ZXJzaW9uO1xuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNvbHZlKG1vZGVsc1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVqZWN0KS5jYXRjaChyZWplY3QpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxscyBwcmVkaWN0IGdpdmVuIG1vZGVsIGluZm8gYW5kIGlucHV0cyB0byBwcmVkaWN0IG9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSAgICAgICAgICAgIG1vZGVsICAgICAgIElmIHN0cmluZywgaXQgaXMgYXNzdW1lZCB0byBiZSBtb2RlbCBpZC4gT3RoZXJ3aXNlLCBpZiBvYmplY3QgaXMgZ2l2ZW4sIGl0IGNhbiBoYXZlIGFueSBvZiB0aGUgZm9sbG93aW5nIGtleXM6XG4gICAgICogICBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICAgbW9kZWwuaWQgICAgICAgICAgTW9kZWwgaWRcbiAgICAgKiAgIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgICBtb2RlbC5uYW1lICAgICAgICBNb2RlbCBuYW1lXG4gICAgICogICBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICAgbW9kZWwudmVyc2lvbiAgICAgTW9kZWwgdmVyc2lvblxuICAgICAqICAgQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgIG1vZGVsLmxhbmd1YWdlICAgIE1vZGVsIGxhbmd1YWdlIChvbmx5IGZvciBDbGFyaWZhaSdzIHB1YmxpYyBtb2RlbHMpXG4gICAgICogICBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICAgbW9kZWwudHlwZSAgICAgICAgVGhpcyBjYW4gYmUgXCJjb25jZXB0XCIsIFwiY29sb3JcIiwgXCJlbWJlZFwiLCBcImZhY2VkZXRlY3RcIiwgXCJjbHVzdGVyXCIgb3IgXCJibHVyXCJcbiAgICAgKiBAcGFyYW0ge29iamVjdFtdfG9iamVjdHxzdHJpbmd9ICAgaW5wdXRzICAgIEFuIGFycmF5IG9mIG9iamVjdHMvb2JqZWN0L3N0cmluZyBwb2ludGluZyB0byBhbiBpbWFnZSByZXNvdXJjZS4gQSBzdHJpbmcgY2FuIGVpdGhlciBiZSBhIHVybCBvciBiYXNlNjQgaW1hZ2UgYnl0ZXMuIE9iamVjdCBrZXlzIGV4cGxhaW5lZCBiZWxvdzpcbiAgICAgKiAgICBAcGFyYW0ge29iamVjdH0gICAgICAgICAgICAgICAgICBpbnB1dHNbXS5pbWFnZSAgICAgT2JqZWN0IHdpdGgga2V5cyBleHBsYWluZWQgYmVsb3c6XG4gICAgICogICAgICAgQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICBpbnB1dHNbXS5pbWFnZS4odXJsfGJhc2U2NCkgIENhbiBiZSBhIHB1YmxpY2x5IGFjY2Vzc2libHkgdXJsIG9yIGJhc2U2NCBzdHJpbmcgcmVwcmVzZW50aW5nIGltYWdlIGJ5dGVzIChyZXF1aXJlZClcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVmlkZW8gIGluZGljYXRlcyBpZiB0aGUgaW5wdXQgc2hvdWxkIGJlIHByb2Nlc3NlZCBhcyBhIHZpZGVvIChkZWZhdWx0IGZhbHNlKVxuICAgICAqIEByZXR1cm4ge1Byb21pc2UocmVzcG9uc2UsIGVycm9yKX0gQSBQcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdpdGggdGhlIEFQSSByZXNwb25zZSBvciByZWplY3RlZCB3aXRoIGFuIGVycm9yXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3ByZWRpY3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVkaWN0KG1vZGVsLCBpbnB1dHMpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgY29uZmlnID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgaWYgKGNoZWNrVHlwZSgvQm9vbGVhbi8sIGNvbmZpZykpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdcImlzVmlkZW9cIiBhcmd1bWVudCBpcyBkZXByZWNhdGVkLCBjb25zaWRlciB1c2luZyB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgaW5zdGVhZCcpO1xuICAgICAgICBjb25maWcgPSB7XG4gICAgICAgICAgdmlkZW86IGNvbmZpZ1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKG1vZGVsLmxhbmd1YWdlKSB7XG4gICAgICAgIGNvbmZpZy5sYW5ndWFnZSA9IG1vZGVsLmxhbmd1YWdlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgX3RoaXMzLmluaXRNb2RlbChtb2RlbCkudGhlbihmdW5jdGlvbiAobW9kZWxPYmopIHtcbiAgICAgICAgICBtb2RlbE9iai5wcmVkaWN0KGlucHV0cywgY29uZmlnKS50aGVuKHJlc29sdmUsIHJlamVjdCkuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxzIHRyYWluIG9uIGEgbW9kZWwgYW5kIGNyZWF0ZXMgYSBuZXcgbW9kZWwgdmVyc2lvbiBnaXZlbiBtb2RlbCBpbmZvXG4gICAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSAgICAgICAgICAgIG1vZGVsICAgICAgIElmIHN0cmluZywgaXQgaXMgYXNzdW1lZCB0byBiZSBtb2RlbCBpZC4gT3RoZXJ3aXNlLCBpZiBvYmplY3QgaXMgZ2l2ZW4sIGl0IGNhbiBoYXZlIGFueSBvZiB0aGUgZm9sbG93aW5nIGtleXM6XG4gICAgICogICBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICAgbW9kZWwuaWQgICAgICAgICAgTW9kZWwgaWRcbiAgICAgKiAgIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgICBtb2RlbC5uYW1lICAgICAgICBNb2RlbCBuYW1lXG4gICAgICogICBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICAgbW9kZWwudmVyc2lvbiAgICAgTW9kZWwgdmVyc2lvblxuICAgICAqICAgQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgIG1vZGVsLnR5cGUgICAgICAgIFRoaXMgY2FuIGJlIFwiY29uY2VwdFwiLCBcImNvbG9yXCIsIFwiZW1iZWRcIiwgXCJmYWNlZGV0ZWN0XCIsIFwiY2x1c3RlclwiIG9yIFwiYmx1clwiXG4gICAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgICAgICAgICAgIHN5bmMgICAgICAgIElmIHRydWUsIHRoaXMgcmV0dXJucyBhZnRlciBtb2RlbCBoYXMgY29tcGxldGVseSB0cmFpbmVkLiBJZiBmYWxzZSwgdGhpcyBpbW1lZGlhdGVseSByZXR1cm5zIGRlZmF1bHQgYXBpIHJlc3BvbnNlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UoTW9kZWwsIGVycm9yKX0gQSBQcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdpdGggYSBNb2RlbCBpbnN0YW5jZSBvciByZWplY3RlZCB3aXRoIGFuIGVycm9yXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3RyYWluJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhaW4obW9kZWwpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgc3luYyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIF90aGlzNC5pbml0TW9kZWwobW9kZWwpLnRoZW4oZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgICAgbW9kZWwudHJhaW4oc3luYykudGhlbihyZXNvbHZlLCByZWplY3QpLmNhdGNoKHJlamVjdCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gICAgICAgICAgICBtb2RlbCAgICAgICBJZiBzdHJpbmcsIGl0IGlzIGFzc3VtZWQgdG8gYmUgbW9kZWwgaWQuIE90aGVyd2lzZSwgaWYgb2JqZWN0IGlzIGdpdmVuLCBpdCBjYW4gaGF2ZSBhbnkgb2YgdGhlIGZvbGxvd2luZyBrZXlzOlxuICAgICAqICAgQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgIG1vZGVsLmlkICAgICAgICAgIE1vZGVsIGlkXG4gICAgICogICBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICAgbW9kZWwubmFtZSAgICAgICAgTW9kZWwgbmFtZVxuICAgICAqICAgQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgIG1vZGVsLnZlcnNpb24gICAgIE1vZGVsIHZlcnNpb25cbiAgICAgKiAgIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgICBtb2RlbC50eXBlICAgICAgICBUaGlzIGNhbiBiZSBcImNvbmNlcHRcIiwgXCJjb2xvclwiLCBcImVtYmVkXCIsIFwiZmFjZWRldGVjdFwiLCBcImNsdXN0ZXJcIiBvciBcImJsdXJcIlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCBBIHN0cmluZyBwb2ludGluZyB0byBhbiBpbWFnZSByZXNvdXJjZS4gQSBzdHJpbmcgbXVzdCBiZSBhIHVybFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgQSBjb25maWd1cmF0aW9uIG9iamVjdCBjb25zaXN0aW5nIG9mIHRoZSBmb2xsb3dpbmcgcmVxdWlyZWQga2V5c1xuICAgICAqICAgQHBhcmFtIHtzdHJpbmd9IGNvbmZpZy5pZCBUaGUgaWQgb2YgdGhlIGZlZWRiYWNrIHJlcXVlc3RcbiAgICAgKiAgIEBwYXJhbSB7b2JqZWN0fSBjb25maWcuZGF0YSBUaGUgZmVlZGJhY2sgZGF0YSB0byBiZSBzZW50XG4gICAgICogICBAcGFyYW0ge29iamVjdH0gY29uZmlnLmluZm8gTWV0YSBkYXRhIHJlbGF0ZWQgdG8gdGhlIGZlZWRiYWNrIHJlcXVlc3RcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZmVlZGJhY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmZWVkYmFjayhtb2RlbCwgaW5wdXQsIGNvbmZpZykge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIF90aGlzNS5pbml0TW9kZWwobW9kZWwpLnRoZW4oZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgICAgcmV0dXJuIG1vZGVsLmZlZWRiYWNrKGlucHV0LCBjb25maWcpO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoZCk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgdmVyc2lvbiBvZiB0aGUgbW9kZWwgc3BlY2lmaWVkIGJ5IGl0cyBpZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gICAgICAgICAgICBtb2RlbCAgICAgICBJZiBzdHJpbmcsIGl0IGlzIGFzc3VtZWQgdG8gYmUgbW9kZWwgaWQuIE90aGVyd2lzZSwgaWYgb2JqZWN0IGlzIGdpdmVuLCBpdCBjYW4gaGF2ZSBhbnkgb2YgdGhlIGZvbGxvd2luZyBrZXlzOlxuICAgICAqICAgQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgIG1vZGVsLmlkICAgICAgICAgIE1vZGVsIGlkXG4gICAgICogICBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICAgbW9kZWwubmFtZSAgICAgICAgTW9kZWwgbmFtZVxuICAgICAqICAgQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgIG1vZGVsLnZlcnNpb24gICAgIE1vZGVsIHZlcnNpb25cbiAgICAgKiAgIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgICBtb2RlbC50eXBlICAgICAgICBUaGlzIGNhbiBiZSBcImNvbmNlcHRcIiwgXCJjb2xvclwiLCBcImVtYmVkXCIsIFwiZmFjZWRldGVjdFwiLCBcImNsdXN0ZXJcIiBvciBcImJsdXJcIlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgdmVyc2lvbklkICAgVGhlIG1vZGVsJ3MgaWRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlKHJlc3BvbnNlLCBlcnJvcil9IEEgUHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aXRoIHRoZSBBUEkgcmVzcG9uc2Ugb3IgcmVqZWN0ZWQgd2l0aCBhbiBlcnJvclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRWZXJzaW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmVyc2lvbihtb2RlbCwgdmVyc2lvbklkKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgX3RoaXM2LmluaXRNb2RlbChtb2RlbCkudGhlbihmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgICBtb2RlbC5nZXRWZXJzaW9uKHZlcnNpb25JZCkudGhlbihyZXNvbHZlLCByZWplY3QpLmNhdGNoKHJlamVjdCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiB2ZXJzaW9ucyBvZiB0aGUgbW9kZWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9ICAgICAgICAgICAgbW9kZWwgICAgICAgSWYgc3RyaW5nLCBpdCBpcyBhc3N1bWVkIHRvIGJlIG1vZGVsIGlkLiBPdGhlcndpc2UsIGlmIG9iamVjdCBpcyBnaXZlbiwgaXQgY2FuIGhhdmUgYW55IG9mIHRoZSBmb2xsb3dpbmcga2V5czpcbiAgICAgKiAgIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgICBtb2RlbC5pZCAgICAgICAgICBNb2RlbCBpZFxuICAgICAqICAgQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgIG1vZGVsLm5hbWUgICAgICAgIE1vZGVsIG5hbWVcbiAgICAgKiAgIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgICBtb2RlbC52ZXJzaW9uICAgICBNb2RlbCB2ZXJzaW9uXG4gICAgICogICBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICAgbW9kZWwudHlwZSAgICAgICAgVGhpcyBjYW4gYmUgXCJjb25jZXB0XCIsIFwiY29sb3JcIiwgXCJlbWJlZFwiLCBcImZhY2VkZXRlY3RcIiwgXCJjbHVzdGVyXCIgb3IgXCJibHVyXCJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgICAgICAgICAgICAgb3B0aW9ucyAgICAgT2JqZWN0IHdpdGgga2V5cyBleHBsYWluZWQgYmVsb3c6IChvcHRpb25hbClcbiAgICAgKiAgIEBwYXJhbSB7bnVtYmVyfSAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhZ2UgICAgICAgIFRoZSBwYWdlIG51bWJlciAob3B0aW9uYWwsIGRlZmF1bHQ6IDEpXG4gICAgICogICBAcGFyYW0ge251bWJlcn0gICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wZXJQYWdlICAgICBOdW1iZXIgb2YgaW1hZ2VzIHRvIHJldHVybiBwZXIgcGFnZSAob3B0aW9uYWwsIGRlZmF1bHQ6IDIwKVxuICAgICAqIEByZXR1cm4ge1Byb21pc2UocmVzcG9uc2UsIGVycm9yKX0gQSBQcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdpdGggdGhlIEFQSSByZXNwb25zZSBvciByZWplY3RlZCB3aXRoIGFuIGVycm9yXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFZlcnNpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmVyc2lvbnMobW9kZWwpIHtcbiAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogeyBwYWdlOiAxLCBwZXJQYWdlOiAyMCB9O1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBfdGhpczcuaW5pdE1vZGVsKG1vZGVsKS50aGVuKGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICAgIG1vZGVsLmdldFZlcnNpb25zKG9wdGlvbnMpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KS5jYXRjaChyZWplY3QpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgdGhlIG1vZGVsJ3Mgb3V0cHV0IGluZm9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9ICAgICAgICAgICAgbW9kZWwgICAgICAgSWYgc3RyaW5nLCBpdCBpcyBhc3N1bWVkIHRvIGJlIG1vZGVsIGlkLiBPdGhlcndpc2UsIGlmIG9iamVjdCBpcyBnaXZlbiwgaXQgY2FuIGhhdmUgYW55IG9mIHRoZSBmb2xsb3dpbmcga2V5czpcbiAgICAgKiAgIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgICBtb2RlbC5pZCAgICAgICAgICBNb2RlbCBpZFxuICAgICAqICAgQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgIG1vZGVsLm5hbWUgICAgICAgIE1vZGVsIG5hbWVcbiAgICAgKiAgIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgICBtb2RlbC52ZXJzaW9uICAgICBNb2RlbCB2ZXJzaW9uXG4gICAgICogICBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICAgbW9kZWwudHlwZSAgICAgICAgVGhpcyBjYW4gYmUgXCJjb25jZXB0XCIsIFwiY29sb3JcIiwgXCJlbWJlZFwiLCBcImZhY2VkZXRlY3RcIiwgXCJjbHVzdGVyXCIgb3IgXCJibHVyXCJcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlKE1vZGVsLCBlcnJvcil9IEEgUHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aXRoIGEgTW9kZWwgaW5zdGFuY2Ugb3IgcmVqZWN0ZWQgd2l0aCBhbiBlcnJvclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRPdXRwdXRJbmZvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3V0cHV0SW5mbyhtb2RlbCkge1xuICAgICAgdmFyIF90aGlzOCA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIF90aGlzOC5pbml0TW9kZWwobW9kZWwpLnRoZW4oZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgICAgbW9kZWwuZ2V0T3V0cHV0SW5mbygpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KS5jYXRjaChyZWplY3QpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgdGhlIG1vZGVsc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgb3B0aW9ucyAgICAgT2JqZWN0IHdpdGgga2V5cyBleHBsYWluZWQgYmVsb3c6IChvcHRpb25hbClcbiAgICAgKiAgIEBwYXJhbSB7TnVtYmVyfSAgICAgb3B0aW9ucy5wYWdlICAgICAgICBUaGUgcGFnZSBudW1iZXIgKG9wdGlvbmFsLCBkZWZhdWx0OiAxKVxuICAgICAqICAgQHBhcmFtIHtOdW1iZXJ9ICAgICBvcHRpb25zLnBlclBhZ2UgICAgIE51bWJlciBvZiBpbWFnZXMgdG8gcmV0dXJuIHBlciBwYWdlIChvcHRpb25hbCwgZGVmYXVsdDogMjApXG4gICAgICogQHJldHVybiB7UHJvbWlzZShNb2RlbHMsIGVycm9yKX0gQSBQcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdpdGggYW4gaW5zdGFuY2Ugb2YgTW9kZWxzIG9yIHJlamVjdGVkIHdpdGggYW4gZXJyb3JcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbGlzdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpc3QoKSB7XG4gICAgICB2YXIgX3RoaXM5ID0gdGhpcztcblxuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHsgcGFnZTogMSwgcGVyUGFnZTogMjAgfTtcblxuICAgICAgdmFyIHVybCA9ICcnICsgdGhpcy5fY29uZmlnLmJhc2VQYXRoICsgTU9ERUxTX1BBVEg7XG4gICAgICByZXR1cm4gd3JhcFRva2VuKHRoaXMuX2NvbmZpZywgZnVuY3Rpb24gKGhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBheGlvcy5nZXQodXJsLCB7XG4gICAgICAgICAgICBwYXJhbXM6IHsgJ3Blcl9wYWdlJzogb3B0aW9ucy5wZXJQYWdlLCAncGFnZSc6IG9wdGlvbnMucGFnZSB9LFxuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyc1xuICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAoaXNTdWNjZXNzKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICByZXNvbHZlKG5ldyBNb2RlbHMoX3RoaXM5Ll9jb25maWcsIHJlc3BvbnNlLmRhdGEubW9kZWxzKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWplY3QocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbW9kZWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9ICAgICAgICAgICAgICAgICAgbW9kZWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgc3RyaW5nLCBpdCBpcyBhc3N1bWVkIHRvIGJlIHRoZSBtb2RlbCBpZC4gT3RoZXJ3aXNlLCBpZiBvYmplY3QgaXMgZ2l2ZW4sIGl0IGNhbiBoYXZlIGFueSBvZiB0aGUgZm9sbG93aW5nIGtleXM6XG4gICAgICogICBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuaWQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTW9kZWwgaWRcbiAgICAgKiAgIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5uYW1lICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNb2RlbCBuYW1lXG4gICAgICogQHBhcmFtIHtvYmplY3RbXXxzdHJpbmdbXXxDb25jZXB0c1tdfSAgIGNvbmNlcHRzRGF0YSAgICAgICAgICAgICAgICAgICAgICAgICAgIExpc3Qgb2Ygb2JqZWN0cyB3aXRoIGlkcywgY29uY2VwdCBpZCBzdHJpbmdzIG9yIGFuIGluc3RhbmNlIG9mIENvbmNlcHRzIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qgd2l0aCBrZXlzIGV4cGxhaW5lZCBiZWxvdzpcbiAgICAgKiAgIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmNvbmNlcHRzTXV0dWFsbHlFeGNsdXNpdmUgICAgICBEbyB5b3UgZXhwZWN0IHRvIHNlZSBtb3JlIHRoYW4gb25lIG9mIHRoZSBjb25jZXB0cyBpbiB0aGlzIG1vZGVsIGluIHRoZSBTQU1FIGltYWdlPyBTZXQgdG8gZmFsc2UgKGRlZmF1bHQpIGlmIHNvLiBPdGhlcndpc2UsIHNldCB0byB0cnVlLlxuICAgICAqICAgQHBhcmFtIHtib29sZWFufSAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY2xvc2VkRW52aXJvbm1lbnQgICAgICAgICAgICAgIERvIHlvdSBleHBlY3QgdG8gcnVuIHRoZSB0cmFpbmVkIG1vZGVsIG9uIGltYWdlcyB0aGF0IGRvIG5vdCBjb250YWluIEFOWSBvZiB0aGUgY29uY2VwdHMgaW4gdGhlIG1vZGVsPyBTZXQgdG8gZmFsc2UgKGRlZmF1bHQpIGlmIHNvLiBPdGhlcndpc2UsIHNldCB0byB0cnVlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UoTW9kZWwsIGVycm9yKX0gQSBQcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdpdGggYW4gaW5zdGFuY2Ugb2YgTW9kZWwgb3IgcmVqZWN0ZWQgd2l0aCBhbiBlcnJvclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjcmVhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUobW9kZWwpIHtcbiAgICAgIHZhciBfdGhpczEwID0gdGhpcztcblxuICAgICAgdmFyIGNvbmNlcHRzRGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIHZhciBjb25jZXB0cyA9IGNvbmNlcHRzRGF0YSBpbnN0YW5jZW9mIENvbmNlcHRzID8gY29uY2VwdHNEYXRhLnRvT2JqZWN0KCdpZCcpIDogY29uY2VwdHNEYXRhLm1hcChmdW5jdGlvbiAoY29uY2VwdCkge1xuICAgICAgICB2YXIgdmFsID0gY29uY2VwdDtcbiAgICAgICAgaWYgKGNoZWNrVHlwZSgvU3RyaW5nLywgY29uY2VwdCkpIHtcbiAgICAgICAgICB2YWwgPSB7ICdpZCc6IGNvbmNlcHQgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfSk7XG4gICAgICB2YXIgbW9kZWxPYmogPSBtb2RlbDtcbiAgICAgIGlmIChjaGVja1R5cGUoL1N0cmluZy8sIG1vZGVsKSkge1xuICAgICAgICBtb2RlbE9iaiA9IHsgaWQ6IG1vZGVsLCBuYW1lOiBtb2RlbCB9O1xuICAgICAgfVxuICAgICAgaWYgKG1vZGVsT2JqLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgRVJST1JTLnBhcmFtc1JlcXVpcmVkKCdNb2RlbCBJRCcpO1xuICAgICAgfVxuICAgICAgdmFyIHVybCA9ICcnICsgdGhpcy5fY29uZmlnLmJhc2VQYXRoICsgTU9ERUxTX1BBVEg7XG4gICAgICB2YXIgZGF0YSA9IHsgbW9kZWw6IG1vZGVsT2JqIH07XG4gICAgICBkYXRhWydtb2RlbCddWydvdXRwdXRfaW5mbyddID0ge1xuICAgICAgICAnZGF0YSc6IHtcbiAgICAgICAgICBjb25jZXB0czogY29uY2VwdHNcbiAgICAgICAgfSxcbiAgICAgICAgJ291dHB1dF9jb25maWcnOiB7XG4gICAgICAgICAgJ2NvbmNlcHRzX211dHVhbGx5X2V4Y2x1c2l2ZSc6ICEhb3B0aW9ucy5jb25jZXB0c011dHVhbGx5RXhjbHVzaXZlLFxuICAgICAgICAgICdjbG9zZWRfZW52aXJvbm1lbnQnOiAhIW9wdGlvbnMuY2xvc2VkRW52aXJvbm1lbnRcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHdyYXBUb2tlbih0aGlzLl9jb25maWcsIGZ1bmN0aW9uIChoZWFkZXJzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgYXhpb3MucG9zdCh1cmwsIGRhdGEsIHsgaGVhZGVyczogaGVhZGVycyB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKGlzU3VjY2VzcyhyZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShuZXcgTW9kZWwoX3RoaXMxMC5fY29uZmlnLCByZXNwb25zZS5kYXRhLm1vZGVsKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWplY3QocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG1vZGVsIHNwZWNpZmllZCBieSBJRFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgaWQgICAgICAgICAgVGhlIG1vZGVsJ3MgaWRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlKE1vZGVsLCBlcnJvcil9IEEgUHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aXRoIGFuIGluc3RhbmNlIG9mIE1vZGVsIG9yIHJlamVjdGVkIHdpdGggYW4gZXJyb3JcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KGlkKSB7XG4gICAgICB2YXIgX3RoaXMxMSA9IHRoaXM7XG5cbiAgICAgIHZhciB1cmwgPSAnJyArIHRoaXMuX2NvbmZpZy5iYXNlUGF0aCArIHJlcGxhY2VWYXJzKE1PREVMX1BBVEgsIFtpZF0pO1xuICAgICAgcmV0dXJuIHdyYXBUb2tlbih0aGlzLl9jb25maWcsIGZ1bmN0aW9uIChoZWFkZXJzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgYXhpb3MuZ2V0KHVybCwgeyBoZWFkZXJzOiBoZWFkZXJzIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAoaXNTdWNjZXNzKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICByZXNvbHZlKG5ldyBNb2RlbChfdGhpczExLl9jb25maWcsIHJlc3BvbnNlLmRhdGEubW9kZWwpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlamVjdChyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYSBtb2RlbCdzIG9yIGEgbGlzdCBvZiBtb2RlbHMnIG91dHB1dCBjb25maWcgb3IgY29uY2VwdHNcbiAgICAgKiBAcGFyYW0ge29iamVjdHxvYmplY3RbXX0gICAgICBtb2RlbHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYW4gYmUgYSBzaW5nbGUgbW9kZWwgb2JqZWN0IG9yIGxpc3Qgb2YgbW9kZWwgb2JqZWN0cyB3aXRoIHRoZSBmb2xsb3dpbmcgYXR0cnM6XG4gICAgICogICBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICBtb2RlbHMuaWQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgaWQgb2YgdGhlIG1vZGVsIHRvIGFwcGx5IGNoYW5nZXMgdG8gKFJlcXVpcmVkKVxuICAgICAqICAgQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgbW9kZWxzLm5hbWUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG5ldyBuYW1lIG9mIHRoZSBtb2RlbCB0byB1cGRhdGUgd2l0aFxuICAgICAqICAgQHBhcmFtIHtib29sZWFufSAgICAgICAgICAgICAgbW9kZWxzLmNvbmNlcHRzTXV0dWFsbHlFeGNsdXNpdmUgICAgICAgICAgICAgRG8geW91IGV4cGVjdCB0byBzZWUgbW9yZSB0aGFuIG9uZSBvZiB0aGUgY29uY2VwdHMgaW4gdGhpcyBtb2RlbCBpbiB0aGUgU0FNRSBpbWFnZT8gU2V0IHRvIGZhbHNlIChkZWZhdWx0KSBpZiBzby4gT3RoZXJ3aXNlLCBzZXQgdG8gdHJ1ZS5cbiAgICAgKiAgIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICAgICAgIG1vZGVscy5jbG9zZWRFbnZpcm9ubWVudCAgICAgICAgICAgICAgICAgICAgIERvIHlvdSBleHBlY3QgdG8gcnVuIHRoZSB0cmFpbmVkIG1vZGVsIG9uIGltYWdlcyB0aGF0IGRvIG5vdCBjb250YWluIEFOWSBvZiB0aGUgY29uY2VwdHMgaW4gdGhlIG1vZGVsPyBTZXQgdG8gZmFsc2UgKGRlZmF1bHQpIGlmIHNvLiBPdGhlcndpc2UsIHNldCB0byB0cnVlLlxuICAgICAqICAgQHBhcmFtIHtvYmplY3RbXX0gICAgICAgICAgICAgbW9kZWxzLmNvbmNlcHRzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQW4gYXJyYXkgb2YgY29uY2VwdCBvYmplY3RzIG9yIHN0cmluZ1xuICAgICAqICAgICBAcGFyYW0ge29iamVjdHxzdHJpbmd9ICAgICAgICBtb2RlbHMuY29uY2VwdHNbXS5jb25jZXB0ICAgICAgICAgICAgICAgICAgICBJZiBzdHJpbmcgaXMgZ2l2ZW4sIHRoaXMgaXMgaW50ZXJwcmV0ZWQgYXMgY29uY2VwdCBpZC4gT3RoZXJ3aXNlLCBpZiBvYmplY3QgaXMgZ2l2ZW4sIGNsaWVudCBleHBlY3RzIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlc1xuICAgICAqICAgICAgIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICBtb2RlbHMuY29uY2VwdHNbXS5jb25jZXB0LmlkICAgICAgICAgICAgICAgICAgIFRoZSBpZCBvZiB0aGUgY29uY2VwdCB0byBhdHRhY2ggdG8gdGhlIG1vZGVsXG4gICAgICogICBAcGFyYW0ge29iamVjdFtdfSAgICAgICAgICAgICBtb2RlbHMuYWN0aW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgYWN0aW9uIHRvIHBlcmZvcm0gb24gdGhlIGdpdmVuIGNvbmNlcHRzLiBQb3NzaWJsZSB2YWx1ZXMgYXJlICdtZXJnZScsICdyZW1vdmUnLCBvciAnb3ZlcndyaXRlJy4gRGVmYXVsdDogJ21lcmdlJ1xuICAgICAqIEByZXR1cm4ge1Byb21pc2UoTW9kZWxzLCBlcnJvcil9IEEgUHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aXRoIGFuIGluc3RhbmNlIG9mIE1vZGVscyBvciByZWplY3RlZCB3aXRoIGFuIGVycm9yXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShtb2RlbHMpIHtcbiAgICAgIHZhciBfdGhpczEyID0gdGhpcztcblxuICAgICAgdmFyIHVybCA9ICcnICsgdGhpcy5fY29uZmlnLmJhc2VQYXRoICsgTU9ERUxTX1BBVEg7XG4gICAgICB2YXIgbW9kZWxzTGlzdCA9IEFycmF5LmlzQXJyYXkobW9kZWxzKSA/IG1vZGVscyA6IFttb2RlbHNdO1xuICAgICAgdmFyIGRhdGEgPSB7IG1vZGVsczogbW9kZWxzTGlzdC5tYXAoZm9ybWF0TW9kZWwpIH07XG4gICAgICBkYXRhWydhY3Rpb24nXSA9IG1vZGVscy5hY3Rpb24gfHwgJ21lcmdlJztcbiAgICAgIHJldHVybiB3cmFwVG9rZW4odGhpcy5fY29uZmlnLCBmdW5jdGlvbiAoaGVhZGVycykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGF4aW9zLnBhdGNoKHVybCwgZGF0YSwgeyBoZWFkZXJzOiBoZWFkZXJzIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAoaXNTdWNjZXNzKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICByZXNvbHZlKG5ldyBNb2RlbHMoX3RoaXMxMi5fY29uZmlnLCByZXNwb25zZS5kYXRhLm1vZGVscykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVqZWN0KHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBtb2RlbCBieSBtZXJnaW5nIGNvbmNlcHRzXG4gICAgICogQHBhcmFtIHtvYmplY3R8b2JqZWN0W119ICAgICAgbW9kZWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYW4gYmUgYSBzaW5nbGUgbW9kZWwgb2JqZWN0IG9yIGxpc3Qgb2YgbW9kZWwgb2JqZWN0cyB3aXRoIHRoZSBmb2xsb3dpbmcgYXR0cnM6XG4gICAgICogICBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICBtb2RlbC5pZCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBpZCBvZiB0aGUgbW9kZWwgdG8gYXBwbHkgY2hhbmdlcyB0byAoUmVxdWlyZWQpXG4gICAgICogICBAcGFyYW0ge29iamVjdFtdfSAgICAgICAgICAgICBtb2RlbC5jb25jZXB0cyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFuIGFycmF5IG9mIGNvbmNlcHQgb2JqZWN0cyBvciBzdHJpbmdcbiAgICAgKiAgICAgQHBhcmFtIHtvYmplY3R8c3RyaW5nfSAgICAgICAgbW9kZWwuY29uY2VwdHNbXS5jb25jZXB0ICAgICAgICAgICAgICAgICAgICBJZiBzdHJpbmcgaXMgZ2l2ZW4sIHRoaXMgaXMgaW50ZXJwcmV0ZWQgYXMgY29uY2VwdCBpZC4gT3RoZXJ3aXNlLCBpZiBvYmplY3QgaXMgZ2l2ZW4sIGNsaWVudCBleHBlY3RzIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlc1xuICAgICAqICAgICAgIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICBtb2RlbC5jb25jZXB0c1tdLmNvbmNlcHQuaWQgICAgICAgICAgICAgICAgICAgVGhlIGlkIG9mIHRoZSBjb25jZXB0IHRvIGF0dGFjaCB0byB0aGUgbW9kZWxcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbWVyZ2VDb25jZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1lcmdlQ29uY2VwdHMoKSB7XG4gICAgICB2YXIgbW9kZWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICBtb2RlbC5hY3Rpb24gPSAnbWVyZ2UnO1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKG1vZGVsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgbW9kZWwgYnkgcmVtb3ZpbmcgY29uY2VwdHNcbiAgICAgKiBAcGFyYW0ge29iamVjdHxvYmplY3RbXX0gICAgICBtb2RlbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENhbiBiZSBhIHNpbmdsZSBtb2RlbCBvYmplY3Qgb3IgbGlzdCBvZiBtb2RlbCBvYmplY3RzIHdpdGggdGhlIGZvbGxvd2luZyBhdHRyczpcbiAgICAgKiAgIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgIG1vZGVsLmlkICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGlkIG9mIHRoZSBtb2RlbCB0byBhcHBseSBjaGFuZ2VzIHRvIChSZXF1aXJlZClcbiAgICAgKiAgIEBwYXJhbSB7b2JqZWN0W119ICAgICAgICAgICAgIG1vZGVsLmNvbmNlcHRzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQW4gYXJyYXkgb2YgY29uY2VwdCBvYmplY3RzIG9yIHN0cmluZ1xuICAgICAqICAgICBAcGFyYW0ge29iamVjdHxzdHJpbmd9ICAgICAgICBtb2RlbC5jb25jZXB0c1tdLmNvbmNlcHQgICAgICAgICAgICAgICAgICAgIElmIHN0cmluZyBpcyBnaXZlbiwgdGhpcyBpcyBpbnRlcnByZXRlZCBhcyBjb25jZXB0IGlkLiBPdGhlcndpc2UsIGlmIG9iamVjdCBpcyBnaXZlbiwgY2xpZW50IGV4cGVjdHMgdGhlIGZvbGxvd2luZyBhdHRyaWJ1dGVzXG4gICAgICogICAgICAgQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgIG1vZGVsLmNvbmNlcHRzW10uY29uY2VwdC5pZCAgICAgICAgICAgICAgICAgICBUaGUgaWQgb2YgdGhlIGNvbmNlcHQgdG8gYXR0YWNoIHRvIHRoZSBtb2RlbFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkZWxldGVDb25jZXB0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZUNvbmNlcHRzKCkge1xuICAgICAgdmFyIG1vZGVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgbW9kZWwuYWN0aW9uID0gJ3JlbW92ZSc7XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGUobW9kZWwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBtb2RlbCBieSBvdmVyd3JpdGluZyBjb25jZXB0c1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fG9iamVjdFtdfSAgICAgIG1vZGVsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2FuIGJlIGEgc2luZ2xlIG1vZGVsIG9iamVjdCBvciBsaXN0IG9mIG1vZGVsIG9iamVjdHMgd2l0aCB0aGUgZm9sbG93aW5nIGF0dHJzOlxuICAgICAqICAgQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgbW9kZWwuaWQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgaWQgb2YgdGhlIG1vZGVsIHRvIGFwcGx5IGNoYW5nZXMgdG8gKFJlcXVpcmVkKVxuICAgICAqICAgQHBhcmFtIHtvYmplY3RbXX0gICAgICAgICAgICAgbW9kZWwuY29uY2VwdHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbiBhcnJheSBvZiBjb25jZXB0IG9iamVjdHMgb3Igc3RyaW5nXG4gICAgICogICAgIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gICAgICAgIG1vZGVsLmNvbmNlcHRzW10uY29uY2VwdCAgICAgICAgICAgICAgICAgICAgSWYgc3RyaW5nIGlzIGdpdmVuLCB0aGlzIGlzIGludGVycHJldGVkIGFzIGNvbmNlcHQgaWQuIE90aGVyd2lzZSwgaWYgb2JqZWN0IGlzIGdpdmVuLCBjbGllbnQgZXhwZWN0cyB0aGUgZm9sbG93aW5nIGF0dHJpYnV0ZXNcbiAgICAgKiAgICAgICBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgbW9kZWwuY29uY2VwdHNbXS5jb25jZXB0LmlkICAgICAgICAgICAgICAgICAgIFRoZSBpZCBvZiB0aGUgY29uY2VwdCB0byBhdHRhY2ggdG8gdGhlIG1vZGVsXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ292ZXJ3cml0ZUNvbmNlcHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3ZlcndyaXRlQ29uY2VwdHMoKSB7XG4gICAgICB2YXIgbW9kZWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICBtb2RlbC5hY3Rpb24gPSAnb3ZlcndyaXRlJztcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShtb2RlbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhbGwgbW9kZWxzIChpZiBubyBpZHMgYW5kIHZlcnNpb25JZCBnaXZlbikgb3IgYSBtb2RlbCAoaWYgZ2l2ZW4gaWQpIG9yIGEgbW9kZWwgdmVyc2lvbiAoaWYgZ2l2ZW4gaWQgYW5kIHZlcmlvbiBpZClcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xTdHJpbmdbXX0gICAgICBpZHMgICAgICAgICBDYW4gYmUgYSBzaW5nbGUgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgcmVwcmVzZW50aW5nIHRoZSBtb2RlbCBpZHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgICAgICAgICB2ZXJzaW9uSWQgICBUaGUgbW9kZWwncyB2ZXJzaW9uIGlkXG4gICAgICogQHJldHVybiB7UHJvbWlzZShyZXNwb25zZSwgZXJyb3IpfSBBIFByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2l0aCB0aGUgQVBJIHJlc3BvbnNlIG9yIHJlamVjdGVkIHdpdGggYW4gZXJyb3JcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGVsZXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlbGV0ZShpZHMpIHtcbiAgICAgIHZhciB2ZXJzaW9uSWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG5cbiAgICAgIHZhciByZXF1ZXN0ID0gdm9pZCAwLFxuICAgICAgICAgIHVybCA9IHZvaWQgMCxcbiAgICAgICAgICBkYXRhID0gdm9pZCAwO1xuICAgICAgdmFyIGlkID0gaWRzO1xuXG4gICAgICBpZiAoY2hlY2tUeXBlKC9TdHJpbmcvLCBpZHMpIHx8IGNoZWNrVHlwZSgvQXJyYXkvLCBpZHMpICYmIGlkcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKHZlcnNpb25JZCkge1xuICAgICAgICAgIHVybCA9ICcnICsgdGhpcy5fY29uZmlnLmJhc2VQYXRoICsgcmVwbGFjZVZhcnMoTU9ERUxfVkVSU0lPTl9QQVRILCBbaWQsIHZlcnNpb25JZF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVybCA9ICcnICsgdGhpcy5fY29uZmlnLmJhc2VQYXRoICsgcmVwbGFjZVZhcnMoTU9ERUxfUEFUSCwgW2lkXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdCA9IHdyYXBUb2tlbih0aGlzLl9jb25maWcsIGZ1bmN0aW9uIChoZWFkZXJzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGF4aW9zLmRlbGV0ZSh1cmwsIHsgaGVhZGVyczogaGVhZGVycyB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICB2YXIgZGF0YSA9IGNsb25lKHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICAgICAgICBkYXRhLnJhd0RhdGEgPSBjbG9uZShyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFpZHMgJiYgIXZlcnNpb25JZCkge1xuICAgICAgICAgIHVybCA9ICcnICsgdGhpcy5fY29uZmlnLmJhc2VQYXRoICsgTU9ERUxTX1BBVEg7XG4gICAgICAgICAgZGF0YSA9IHsgJ2RlbGV0ZV9hbGwnOiB0cnVlIH07XG4gICAgICAgIH0gZWxzZSBpZiAoIXZlcnNpb25JZCAmJiBpZHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHVybCA9ICcnICsgdGhpcy5fY29uZmlnLmJhc2VQYXRoICsgTU9ERUxTX1BBVEg7XG4gICAgICAgICAgZGF0YSA9IHsgaWRzOiBpZHMgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBFUlJPUlMuSU5WQUxJRF9ERUxFVEVfQVJHUztcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0ID0gd3JhcFRva2VuKHRoaXMuX2NvbmZpZywgZnVuY3Rpb24gKGhlYWRlcnMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgYXhpb3Moe1xuICAgICAgICAgICAgICBtZXRob2Q6ICdkZWxldGUnLFxuICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyc1xuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgdmFyIGRhdGEgPSBjbG9uZShyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICAgICAgZGF0YS5yYXdEYXRhID0gY2xvbmUocmVzcG9uc2UuZGF0YSk7XG4gICAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VhcmNoIGZvciBtb2RlbHMgYnkgbmFtZSBvciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICBuYW1lICAgICAgICBUaGUgbW9kZWwgbmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgdHlwZSAgICAgICAgVGhpcyBjYW4gYmUgXCJjb25jZXB0XCIsIFwiY29sb3JcIiwgXCJlbWJlZFwiLCBcImZhY2VkZXRlY3RcIiwgXCJjbHVzdGVyXCIgb3IgXCJibHVyXCJcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlKG1vZGVscywgZXJyb3IpfSBBIFByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2l0aCBhbiBpbnN0YW5jZSBvZiBNb2RlbHMgb3IgcmVqZWN0ZWQgd2l0aCBhbiBlcnJvclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZWFyY2gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWFyY2gobmFtZSkge1xuICAgICAgdmFyIF90aGlzMTMgPSB0aGlzO1xuXG4gICAgICB2YXIgdHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcblxuICAgICAgdmFyIHVybCA9ICcnICsgdGhpcy5fY29uZmlnLmJhc2VQYXRoICsgTU9ERUxfU0VBUkNIX1BBVEg7XG4gICAgICByZXR1cm4gd3JhcFRva2VuKHRoaXMuX2NvbmZpZywgZnVuY3Rpb24gKGhlYWRlcnMpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAnbW9kZWxfcXVlcnknOiB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBheGlvcy5wb3N0KHVybCwgcGFyYW1zLCB7IGhlYWRlcnM6IGhlYWRlcnMgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChpc1N1Y2Nlc3MocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUobmV3IE1vZGVscyhfdGhpczEzLl9jb25maWcsIHJlc3BvbnNlLmRhdGEubW9kZWxzKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWplY3QocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1vZGVscztcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBNb2RlbHM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/clarifai/dist/Models.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/clarifai/dist/Region.js":
/*!**********************************************!*\
  !*** ./node_modules/clarifai/dist/Region.js ***!
  \**********************************************/
/***/ ((module) => {

eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Region / bounding box. Region points are percentages from the edge.\n * E.g. top of 0.2 means the cropped input will start 20% down from the original edge.\n * @class\n */\nvar Region = function Region(_config, data) {\n  _classCallCheck(this, Region);\n\n  this.id = data.id;\n  this.top = data.region_info.bounding_box.top_row;\n  this.left = data.region_info.bounding_box.left_col;\n  this.bottom = data.region_info.bounding_box.bottom_row;\n  this.right = data.region_info.bounding_box.right_col;\n};\n\nmodule.exports = Region;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2xhcmlmYWkvZGlzdC9SZWdpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsa0RBQWtELDBDQUEwQzs7QUFFNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVmcmlnZXJhdG9yX2FwcC8uL25vZGVfbW9kdWxlcy9jbGFyaWZhaS9kaXN0L1JlZ2lvbi5qcz9hOWFjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIFJlZ2lvbiAvIGJvdW5kaW5nIGJveC4gUmVnaW9uIHBvaW50cyBhcmUgcGVyY2VudGFnZXMgZnJvbSB0aGUgZWRnZS5cbiAqIEUuZy4gdG9wIG9mIDAuMiBtZWFucyB0aGUgY3JvcHBlZCBpbnB1dCB3aWxsIHN0YXJ0IDIwJSBkb3duIGZyb20gdGhlIG9yaWdpbmFsIGVkZ2UuXG4gKiBAY2xhc3NcbiAqL1xudmFyIFJlZ2lvbiA9IGZ1bmN0aW9uIFJlZ2lvbihfY29uZmlnLCBkYXRhKSB7XG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWdpb24pO1xuXG4gIHRoaXMuaWQgPSBkYXRhLmlkO1xuICB0aGlzLnRvcCA9IGRhdGEucmVnaW9uX2luZm8uYm91bmRpbmdfYm94LnRvcF9yb3c7XG4gIHRoaXMubGVmdCA9IGRhdGEucmVnaW9uX2luZm8uYm91bmRpbmdfYm94LmxlZnRfY29sO1xuICB0aGlzLmJvdHRvbSA9IGRhdGEucmVnaW9uX2luZm8uYm91bmRpbmdfYm94LmJvdHRvbV9yb3c7XG4gIHRoaXMucmlnaHQgPSBkYXRhLnJlZ2lvbl9pbmZvLmJvdW5kaW5nX2JveC5yaWdodF9jb2w7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlZ2lvbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/clarifai/dist/Region.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/clarifai/dist/Regions.js":
/*!***********************************************!*\
  !*** ./node_modules/clarifai/dist/Regions.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Region = __webpack_require__(/*! ./Region */ \"(rsc)/./node_modules/clarifai/dist/Region.js\");\n\n/**\n * A collection of regions.\n * @class\n */\n\nvar Regions = function () {\n  function Regions(_config) {\n    var _this = this;\n\n    var rawData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    _classCallCheck(this, Regions);\n\n    this._config = _config;\n    this.rawData = rawData;\n    rawData.forEach(function (regionData, index) {\n      _this[index] = new Region(_this._config, regionData);\n    });\n    this.length = rawData.length;\n  }\n\n  _createClass(Regions, [{\n    key: Symbol.iterator,\n    value: function value() {\n      var _this2 = this;\n\n      var index = -1;\n      return {\n        next: function next() {\n          return { value: _this2[++index], done: index >= _this2.length };\n        }\n      };\n    }\n  }]);\n\n  return Regions;\n}();\n\nmodule.exports = Regions;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2xhcmlmYWkvZGlzdC9SZWdpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGlDQUFpQywyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwrREFBK0QseURBQXlELHFFQUFxRSw2REFBNkQsd0JBQXdCOztBQUVqakIsa0RBQWtELDBDQUEwQzs7QUFFNUYsYUFBYSxtQkFBTyxDQUFDLDhEQUFVOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWZyaWdlcmF0b3JfYXBwLy4vbm9kZV9tb2R1bGVzL2NsYXJpZmFpL2Rpc3QvUmVnaW9ucy5qcz9iNGM2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFJlZ2lvbiA9IHJlcXVpcmUoJy4vUmVnaW9uJyk7XG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIHJlZ2lvbnMuXG4gKiBAY2xhc3NcbiAqL1xuXG52YXIgUmVnaW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVnaW9ucyhfY29uZmlnKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciByYXdEYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWdpb25zKTtcblxuICAgIHRoaXMuX2NvbmZpZyA9IF9jb25maWc7XG4gICAgdGhpcy5yYXdEYXRhID0gcmF3RGF0YTtcbiAgICByYXdEYXRhLmZvckVhY2goZnVuY3Rpb24gKHJlZ2lvbkRhdGEsIGluZGV4KSB7XG4gICAgICBfdGhpc1tpbmRleF0gPSBuZXcgUmVnaW9uKF90aGlzLl9jb25maWcsIHJlZ2lvbkRhdGEpO1xuICAgIH0pO1xuICAgIHRoaXMubGVuZ3RoID0gcmF3RGF0YS5sZW5ndGg7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUmVnaW9ucywgW3tcbiAgICBrZXk6IFN5bWJvbC5pdGVyYXRvcixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBfdGhpczJbKytpbmRleF0sIGRvbmU6IGluZGV4ID49IF90aGlzMi5sZW5ndGggfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmVnaW9ucztcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWdpb25zOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/clarifai/dist/Regions.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/clarifai/dist/Workflow.js":
/*!************************************************!*\
  !*** ./node_modules/clarifai/dist/Workflow.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/clarifai/dist/utils.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar axios = __webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\");\n\nvar _require = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/clarifai/dist/constants.js\"),\n    API = _require.API,\n    replaceVars = _require.replaceVars;\n\nvar WORKFLOWS_PATH = API.WORKFLOWS_PATH,\n    WORKFLOW_PATH = API.WORKFLOW_PATH,\n    WORKFLOW_RESULTS_PATH = API.WORKFLOW_RESULTS_PATH;\n\nvar _require2 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/clarifai/dist/utils.js\"),\n    wrapToken = _require2.wrapToken,\n    formatInput = _require2.formatInput;\n\nvar _require3 = __webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/clarifai/dist/helpers.js\"),\n    checkType = _require3.checkType;\n\n/**\n * class representing a workflow\n * @class\n */\n\n\nvar Workflow = function () {\n  function Workflow(_config) {\n    var rawData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    _classCallCheck(this, Workflow);\n\n    this._config = _config;\n    this.rawData = rawData;\n    this.id = rawData.id;\n    this.createdAt = rawData.created_at || rawData.createdAt;\n    this.appId = rawData.app_id || rawData.appId;\n  }\n\n  /**\n   * @deprecated\n   */\n\n\n  _createClass(Workflow, [{\n    key: 'create',\n    value: function create(workflowId, config) {\n      var url = '' + this._config.basePath + WORKFLOWS_PATH;\n      var modelId = config.modelId;\n      var modelVersionId = config.modelVersionId;\n      var body = {\n        workflows: [{\n          id: workflowId,\n          nodes: [{\n            id: 'concepts',\n            model: {\n              id: modelId,\n              model_version: {\n                id: modelVersionId\n              }\n            }\n          }]\n        }]\n      };\n\n      return wrapToken(this._config, function (headers) {\n        return new Promise(function (resolve, reject) {\n          axios.post(url, body, {\n            headers: headers\n          }).then(function (response) {\n            var workflowId = response.data.workflows[0].id;\n            resolve(workflowId);\n          }, reject);\n        });\n      });\n    }\n\n    /**\n     * @deprecated\n     */\n\n  }, {\n    key: 'delete',\n    value: function _delete(workflowId, config) {\n      var url = '' + this._config.basePath + replaceVars(WORKFLOW_PATH, [workflowId]);\n      return wrapToken(this._config, function (headers) {\n        return new Promise(function (resolve, reject) {\n          axios.delete(url, {\n            headers: headers\n          }).then(function (response) {\n            var data = response.data;\n            resolve(data);\n          }, reject);\n        });\n      });\n    }\n\n    /**\n     * Returns workflow output according to inputs\n     * @param {string}                   workflowId    Workflow id\n     * @param {object[]|object|string}   inputs    An array of objects/object/string pointing to an image resource. A string can either be a url or base64 image bytes. Object keys explained below:\n     *    @param {object}                  inputs[].image     Object with keys explained below:\n     *       @param {string}                 inputs[].image.(url|base64)  Can be a publicly accessibly url or base64 string representing image bytes (required)\n     * @param {object} config An object with keys explained below.\n     *   @param {float} config.minValue The minimum confidence threshold that a result must meet. From 0.0 to 1.0\n     *   @param {number} config.maxConcepts The maximum number of concepts to return\n     */\n\n  }, {\n    key: 'predict',\n    value: function predict(workflowId, inputs) {\n      var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var url = '' + this._config.basePath + replaceVars(WORKFLOW_RESULTS_PATH, [workflowId]);\n      if (checkType(/(Object|String)/, inputs)) {\n        inputs = [inputs];\n      }\n      return wrapToken(this._config, function (headers) {\n        var params = {\n          inputs: inputs.map(formatInput)\n        };\n        if (config && Object.getOwnPropertyNames(config).length > 0) {\n          params['output_config'] = (0, _utils.formatObjectForSnakeCase)(config);\n        }\n        return new Promise(function (resolve, reject) {\n          axios.post(url, params, {\n            headers: headers\n          }).then(function (response) {\n            var data = response.data;\n            resolve(data);\n          }, reject);\n        });\n      });\n    }\n  }]);\n\n  return Workflow;\n}();\n\nmodule.exports = Workflow;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2xhcmlmYWkvZGlzdC9Xb3JrZmxvdy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixpQ0FBaUMsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsK0RBQStELHlEQUF5RCxxRUFBcUUsNkRBQTZELHdCQUF3Qjs7QUFFampCLGFBQWEsbUJBQU8sQ0FBQyw0REFBUzs7QUFFOUIsa0RBQWtELDBDQUEwQzs7QUFFNUYsWUFBWSxtQkFBTyxDQUFDLDZEQUFPOztBQUUzQixlQUFlLG1CQUFPLENBQUMsb0VBQWE7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsNERBQVM7QUFDakM7QUFDQTs7QUFFQSxnQkFBZ0IsbUJBQU8sQ0FBQyxnRUFBVztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSwwQkFBMEI7QUFDekMsa0JBQWtCLHlCQUF5QjtBQUMzQyxxQkFBcUIsd0JBQXdCO0FBQzdDLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsUUFBUTtBQUN6Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWZyaWdlcmF0b3JfYXBwLy4vbm9kZV9tb2R1bGVzL2NsYXJpZmFpL2Rpc3QvV29ya2Zsb3cuanM/MDMyYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBheGlvcyA9IHJlcXVpcmUoJ2F4aW9zJyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyksXG4gICAgQVBJID0gX3JlcXVpcmUuQVBJLFxuICAgIHJlcGxhY2VWYXJzID0gX3JlcXVpcmUucmVwbGFjZVZhcnM7XG5cbnZhciBXT1JLRkxPV1NfUEFUSCA9IEFQSS5XT1JLRkxPV1NfUEFUSCxcbiAgICBXT1JLRkxPV19QQVRIID0gQVBJLldPUktGTE9XX1BBVEgsXG4gICAgV09SS0ZMT1dfUkVTVUxUU19QQVRIID0gQVBJLldPUktGTE9XX1JFU1VMVFNfUEFUSDtcblxudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoJy4vdXRpbHMnKSxcbiAgICB3cmFwVG9rZW4gPSBfcmVxdWlyZTIud3JhcFRva2VuLFxuICAgIGZvcm1hdElucHV0ID0gX3JlcXVpcmUyLmZvcm1hdElucHV0O1xuXG52YXIgX3JlcXVpcmUzID0gcmVxdWlyZSgnLi9oZWxwZXJzJyksXG4gICAgY2hlY2tUeXBlID0gX3JlcXVpcmUzLmNoZWNrVHlwZTtcblxuLyoqXG4gKiBjbGFzcyByZXByZXNlbnRpbmcgYSB3b3JrZmxvd1xuICogQGNsYXNzXG4gKi9cblxuXG52YXIgV29ya2Zsb3cgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFdvcmtmbG93KF9jb25maWcpIHtcbiAgICB2YXIgcmF3RGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV29ya2Zsb3cpO1xuXG4gICAgdGhpcy5fY29uZmlnID0gX2NvbmZpZztcbiAgICB0aGlzLnJhd0RhdGEgPSByYXdEYXRhO1xuICAgIHRoaXMuaWQgPSByYXdEYXRhLmlkO1xuICAgIHRoaXMuY3JlYXRlZEF0ID0gcmF3RGF0YS5jcmVhdGVkX2F0IHx8IHJhd0RhdGEuY3JlYXRlZEF0O1xuICAgIHRoaXMuYXBwSWQgPSByYXdEYXRhLmFwcF9pZCB8fCByYXdEYXRhLmFwcElkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFdvcmtmbG93LCBbe1xuICAgIGtleTogJ2NyZWF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZSh3b3JrZmxvd0lkLCBjb25maWcpIHtcbiAgICAgIHZhciB1cmwgPSAnJyArIHRoaXMuX2NvbmZpZy5iYXNlUGF0aCArIFdPUktGTE9XU19QQVRIO1xuICAgICAgdmFyIG1vZGVsSWQgPSBjb25maWcubW9kZWxJZDtcbiAgICAgIHZhciBtb2RlbFZlcnNpb25JZCA9IGNvbmZpZy5tb2RlbFZlcnNpb25JZDtcbiAgICAgIHZhciBib2R5ID0ge1xuICAgICAgICB3b3JrZmxvd3M6IFt7XG4gICAgICAgICAgaWQ6IHdvcmtmbG93SWQsXG4gICAgICAgICAgbm9kZXM6IFt7XG4gICAgICAgICAgICBpZDogJ2NvbmNlcHRzJyxcbiAgICAgICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICAgIGlkOiBtb2RlbElkLFxuICAgICAgICAgICAgICBtb2RlbF92ZXJzaW9uOiB7XG4gICAgICAgICAgICAgICAgaWQ6IG1vZGVsVmVyc2lvbklkXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XVxuICAgICAgICB9XVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHdyYXBUb2tlbih0aGlzLl9jb25maWcsIGZ1bmN0aW9uIChoZWFkZXJzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgYXhpb3MucG9zdCh1cmwsIGJvZHksIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnNcbiAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgdmFyIHdvcmtmbG93SWQgPSByZXNwb25zZS5kYXRhLndvcmtmbG93c1swXS5pZDtcbiAgICAgICAgICAgIHJlc29sdmUod29ya2Zsb3dJZCk7XG4gICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkZWxldGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVsZXRlKHdvcmtmbG93SWQsIGNvbmZpZykge1xuICAgICAgdmFyIHVybCA9ICcnICsgdGhpcy5fY29uZmlnLmJhc2VQYXRoICsgcmVwbGFjZVZhcnMoV09SS0ZMT1dfUEFUSCwgW3dvcmtmbG93SWRdKTtcbiAgICAgIHJldHVybiB3cmFwVG9rZW4odGhpcy5fY29uZmlnLCBmdW5jdGlvbiAoaGVhZGVycykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGF4aW9zLmRlbGV0ZSh1cmwsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnNcbiAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd29ya2Zsb3cgb3V0cHV0IGFjY29yZGluZyB0byBpbnB1dHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICAgd29ya2Zsb3dJZCAgICBXb3JrZmxvdyBpZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0W118b2JqZWN0fHN0cmluZ30gICBpbnB1dHMgICAgQW4gYXJyYXkgb2Ygb2JqZWN0cy9vYmplY3Qvc3RyaW5nIHBvaW50aW5nIHRvIGFuIGltYWdlIHJlc291cmNlLiBBIHN0cmluZyBjYW4gZWl0aGVyIGJlIGEgdXJsIG9yIGJhc2U2NCBpbWFnZSBieXRlcy4gT2JqZWN0IGtleXMgZXhwbGFpbmVkIGJlbG93OlxuICAgICAqICAgIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICAgICAgICAgIGlucHV0c1tdLmltYWdlICAgICBPYmplY3Qgd2l0aCBrZXlzIGV4cGxhaW5lZCBiZWxvdzpcbiAgICAgKiAgICAgICBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgIGlucHV0c1tdLmltYWdlLih1cmx8YmFzZTY0KSAgQ2FuIGJlIGEgcHVibGljbHkgYWNjZXNzaWJseSB1cmwgb3IgYmFzZTY0IHN0cmluZyByZXByZXNlbnRpbmcgaW1hZ2UgYnl0ZXMgKHJlcXVpcmVkKVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgQW4gb2JqZWN0IHdpdGgga2V5cyBleHBsYWluZWQgYmVsb3cuXG4gICAgICogICBAcGFyYW0ge2Zsb2F0fSBjb25maWcubWluVmFsdWUgVGhlIG1pbmltdW0gY29uZmlkZW5jZSB0aHJlc2hvbGQgdGhhdCBhIHJlc3VsdCBtdXN0IG1lZXQuIEZyb20gMC4wIHRvIDEuMFxuICAgICAqICAgQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy5tYXhDb25jZXB0cyBUaGUgbWF4aW11bSBudW1iZXIgb2YgY29uY2VwdHMgdG8gcmV0dXJuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3ByZWRpY3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVkaWN0KHdvcmtmbG93SWQsIGlucHV0cykge1xuICAgICAgdmFyIGNvbmZpZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIHZhciB1cmwgPSAnJyArIHRoaXMuX2NvbmZpZy5iYXNlUGF0aCArIHJlcGxhY2VWYXJzKFdPUktGTE9XX1JFU1VMVFNfUEFUSCwgW3dvcmtmbG93SWRdKTtcbiAgICAgIGlmIChjaGVja1R5cGUoLyhPYmplY3R8U3RyaW5nKS8sIGlucHV0cykpIHtcbiAgICAgICAgaW5wdXRzID0gW2lucHV0c107XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcFRva2VuKHRoaXMuX2NvbmZpZywgZnVuY3Rpb24gKGhlYWRlcnMpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICBpbnB1dHM6IGlucHV0cy5tYXAoZm9ybWF0SW5wdXQpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChjb25maWcgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY29uZmlnKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcGFyYW1zWydvdXRwdXRfY29uZmlnJ10gPSAoMCwgX3V0aWxzLmZvcm1hdE9iamVjdEZvclNuYWtlQ2FzZSkoY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGF4aW9zLnBvc3QodXJsLCBwYXJhbXMsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnNcbiAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBXb3JrZmxvdztcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXb3JrZmxvdzsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/clarifai/dist/Workflow.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/clarifai/dist/Workflows.js":
/*!*************************************************!*\
  !*** ./node_modules/clarifai/dist/Workflows.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar axios = __webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\");\nvar Workflow = __webpack_require__(/*! ./Workflow */ \"(rsc)/./node_modules/clarifai/dist/Workflow.js\");\n\nvar _require = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/clarifai/dist/constants.js\"),\n    API = _require.API,\n    replaceVars = _require.replaceVars;\n\nvar WORKFLOWS_PATH = API.WORKFLOWS_PATH,\n    WORKFLOW_PATH = API.WORKFLOW_PATH;\n\nvar _require2 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/clarifai/dist/utils.js\"),\n    wrapToken = _require2.wrapToken;\n\nvar _require3 = __webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/clarifai/dist/helpers.js\"),\n    isSuccess = _require3.isSuccess;\n\n/**\n * class representing a collection of workflows\n * @class\n */\n\n\nvar Workflows = function () {\n  function Workflows(_config) {\n    var _this = this;\n\n    var rawData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    _classCallCheck(this, Workflows);\n\n    this._config = _config;\n    this.rawData = rawData;\n    rawData.forEach(function (workflowData, index) {\n      _this[index] = new Workflow(_this._config, workflowData);\n    });\n    this.length = rawData.length;\n  }\n\n  /**\n   * Get all workflows in app\n   * @param {Object}    options  Object with keys explained below: (optional)\n   *   @param {Number}    options.page  The page number (optional, default: 1)\n   *   @param {Number}    options.perPage  Number of images to return per page (optional, default: 20)\n   * @return {Promise(Workflows, error)} A Promise that is fulfilled with an instance of Workflows or rejected with an error\n   */\n\n\n  _createClass(Workflows, [{\n    key: 'list',\n    value: function list() {\n      var _this2 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { page: 1, perPage: 20 };\n\n      var url = '' + this._config.basePath + WORKFLOWS_PATH;\n      return wrapToken(this._config, function (headers) {\n        return new Promise(function (resolve, reject) {\n          axios.get(url, {\n            headers: headers,\n            params: {\n              page: options.page,\n              per_page: options.perPage\n            }\n          }).then(function (response) {\n            if (isSuccess(response)) {\n              resolve(new Workflows(_this2._config, response.data.workflows));\n            } else {\n              reject(response);\n            }\n          }, reject);\n        });\n      });\n    }\n  }, {\n    key: 'create',\n    value: function create(workflowId, config) {\n      var url = '' + this._config.basePath + WORKFLOWS_PATH;\n      var modelId = config.modelId;\n      var modelVersionId = config.modelVersionId;\n      var body = {\n        workflows: [{\n          id: workflowId,\n          nodes: [{\n            id: 'concepts',\n            model: {\n              id: modelId,\n              model_version: {\n                id: modelVersionId\n              }\n            }\n          }]\n        }]\n      };\n\n      return wrapToken(this._config, function (headers) {\n        return new Promise(function (resolve, reject) {\n          axios.post(url, body, {\n            headers: headers\n          }).then(function (response) {\n            var workflowId = response.data.workflows[0].id;\n            resolve(workflowId);\n          }, reject);\n        });\n      });\n    }\n  }, {\n    key: 'delete',\n    value: function _delete(workflowId) {\n      var url = '' + this._config.basePath + replaceVars(WORKFLOW_PATH, [workflowId]);\n      return wrapToken(this._config, function (headers) {\n        return new Promise(function (resolve, reject) {\n          axios.delete(url, {\n            headers: headers\n          }).then(function (response) {\n            var data = response.data;\n            resolve(data);\n          }, reject);\n        });\n      });\n    }\n  }]);\n\n  return Workflows;\n}();\n\n;\n\nmodule.exports = Workflows;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2xhcmlmYWkvZGlzdC9Xb3JrZmxvd3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsaUNBQWlDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELCtEQUErRCx5REFBeUQscUVBQXFFLDZEQUE2RCx3QkFBd0I7O0FBRWpqQixrREFBa0QsMENBQTBDOztBQUU1RixZQUFZLG1CQUFPLENBQUMsNkRBQU87QUFDM0IsZUFBZSxtQkFBTyxDQUFDLGtFQUFZOztBQUVuQyxlQUFlLG1CQUFPLENBQUMsb0VBQWE7QUFDcEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFnQixtQkFBTyxDQUFDLDREQUFTO0FBQ2pDOztBQUVBLGdCQUFnQixtQkFBTyxDQUFDLGdFQUFXO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCLGVBQWUsV0FBVztBQUMxQixlQUFlLFdBQVc7QUFDMUIsY0FBYywyQkFBMkI7QUFDekM7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBGQUEwRjs7QUFFMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWZyaWdlcmF0b3JfYXBwLy4vbm9kZV9tb2R1bGVzL2NsYXJpZmFpL2Rpc3QvV29ya2Zsb3dzLmpzP2ZjOTAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgYXhpb3MgPSByZXF1aXJlKCdheGlvcycpO1xudmFyIFdvcmtmbG93ID0gcmVxdWlyZSgnLi9Xb3JrZmxvdycpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpLFxuICAgIEFQSSA9IF9yZXF1aXJlLkFQSSxcbiAgICByZXBsYWNlVmFycyA9IF9yZXF1aXJlLnJlcGxhY2VWYXJzO1xuXG52YXIgV09SS0ZMT1dTX1BBVEggPSBBUEkuV09SS0ZMT1dTX1BBVEgsXG4gICAgV09SS0ZMT1dfUEFUSCA9IEFQSS5XT1JLRkxPV19QQVRIO1xuXG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZSgnLi91dGlscycpLFxuICAgIHdyYXBUb2tlbiA9IF9yZXF1aXJlMi53cmFwVG9rZW47XG5cbnZhciBfcmVxdWlyZTMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKSxcbiAgICBpc1N1Y2Nlc3MgPSBfcmVxdWlyZTMuaXNTdWNjZXNzO1xuXG4vKipcbiAqIGNsYXNzIHJlcHJlc2VudGluZyBhIGNvbGxlY3Rpb24gb2Ygd29ya2Zsb3dzXG4gKiBAY2xhc3NcbiAqL1xuXG5cbnZhciBXb3JrZmxvd3MgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFdvcmtmbG93cyhfY29uZmlnKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciByYXdEYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXb3JrZmxvd3MpO1xuXG4gICAgdGhpcy5fY29uZmlnID0gX2NvbmZpZztcbiAgICB0aGlzLnJhd0RhdGEgPSByYXdEYXRhO1xuICAgIHJhd0RhdGEuZm9yRWFjaChmdW5jdGlvbiAod29ya2Zsb3dEYXRhLCBpbmRleCkge1xuICAgICAgX3RoaXNbaW5kZXhdID0gbmV3IFdvcmtmbG93KF90aGlzLl9jb25maWcsIHdvcmtmbG93RGF0YSk7XG4gICAgfSk7XG4gICAgdGhpcy5sZW5ndGggPSByYXdEYXRhLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIHdvcmtmbG93cyBpbiBhcHBcbiAgICogQHBhcmFtIHtPYmplY3R9ICAgIG9wdGlvbnMgIE9iamVjdCB3aXRoIGtleXMgZXhwbGFpbmVkIGJlbG93OiAob3B0aW9uYWwpXG4gICAqICAgQHBhcmFtIHtOdW1iZXJ9ICAgIG9wdGlvbnMucGFnZSAgVGhlIHBhZ2UgbnVtYmVyIChvcHRpb25hbCwgZGVmYXVsdDogMSlcbiAgICogICBAcGFyYW0ge051bWJlcn0gICAgb3B0aW9ucy5wZXJQYWdlICBOdW1iZXIgb2YgaW1hZ2VzIHRvIHJldHVybiBwZXIgcGFnZSAob3B0aW9uYWwsIGRlZmF1bHQ6IDIwKVxuICAgKiBAcmV0dXJuIHtQcm9taXNlKFdvcmtmbG93cywgZXJyb3IpfSBBIFByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2l0aCBhbiBpbnN0YW5jZSBvZiBXb3JrZmxvd3Mgb3IgcmVqZWN0ZWQgd2l0aCBhbiBlcnJvclxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhXb3JrZmxvd3MsIFt7XG4gICAga2V5OiAnbGlzdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpc3QoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHsgcGFnZTogMSwgcGVyUGFnZTogMjAgfTtcblxuICAgICAgdmFyIHVybCA9ICcnICsgdGhpcy5fY29uZmlnLmJhc2VQYXRoICsgV09SS0ZMT1dTX1BBVEg7XG4gICAgICByZXR1cm4gd3JhcFRva2VuKHRoaXMuX2NvbmZpZywgZnVuY3Rpb24gKGhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBheGlvcy5nZXQodXJsLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgIHBhZ2U6IG9wdGlvbnMucGFnZSxcbiAgICAgICAgICAgICAgcGVyX3BhZ2U6IG9wdGlvbnMucGVyUGFnZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAoaXNTdWNjZXNzKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICByZXNvbHZlKG5ldyBXb3JrZmxvd3MoX3RoaXMyLl9jb25maWcsIHJlc3BvbnNlLmRhdGEud29ya2Zsb3dzKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWplY3QocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY3JlYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKHdvcmtmbG93SWQsIGNvbmZpZykge1xuICAgICAgdmFyIHVybCA9ICcnICsgdGhpcy5fY29uZmlnLmJhc2VQYXRoICsgV09SS0ZMT1dTX1BBVEg7XG4gICAgICB2YXIgbW9kZWxJZCA9IGNvbmZpZy5tb2RlbElkO1xuICAgICAgdmFyIG1vZGVsVmVyc2lvbklkID0gY29uZmlnLm1vZGVsVmVyc2lvbklkO1xuICAgICAgdmFyIGJvZHkgPSB7XG4gICAgICAgIHdvcmtmbG93czogW3tcbiAgICAgICAgICBpZDogd29ya2Zsb3dJZCxcbiAgICAgICAgICBub2RlczogW3tcbiAgICAgICAgICAgIGlkOiAnY29uY2VwdHMnLFxuICAgICAgICAgICAgbW9kZWw6IHtcbiAgICAgICAgICAgICAgaWQ6IG1vZGVsSWQsXG4gICAgICAgICAgICAgIG1vZGVsX3ZlcnNpb246IHtcbiAgICAgICAgICAgICAgICBpZDogbW9kZWxWZXJzaW9uSWRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1dXG4gICAgICAgIH1dXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gd3JhcFRva2VuKHRoaXMuX2NvbmZpZywgZnVuY3Rpb24gKGhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBheGlvcy5wb3N0KHVybCwgYm9keSwge1xuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyc1xuICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICB2YXIgd29ya2Zsb3dJZCA9IHJlc3BvbnNlLmRhdGEud29ya2Zsb3dzWzBdLmlkO1xuICAgICAgICAgICAgcmVzb2x2ZSh3b3JrZmxvd0lkKTtcbiAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RlbGV0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWxldGUod29ya2Zsb3dJZCkge1xuICAgICAgdmFyIHVybCA9ICcnICsgdGhpcy5fY29uZmlnLmJhc2VQYXRoICsgcmVwbGFjZVZhcnMoV09SS0ZMT1dfUEFUSCwgW3dvcmtmbG93SWRdKTtcbiAgICAgIHJldHVybiB3cmFwVG9rZW4odGhpcy5fY29uZmlnLCBmdW5jdGlvbiAoaGVhZGVycykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGF4aW9zLmRlbGV0ZSh1cmwsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnNcbiAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBXb3JrZmxvd3M7XG59KCk7XG5cbjtcblxubW9kdWxlLmV4cG9ydHMgPSBXb3JrZmxvd3M7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/clarifai/dist/Workflows.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/clarifai/dist/constants.js":
/*!*************************************************!*\
  !*** ./node_modules/clarifai/dist/constants.js ***!
  \*************************************************/
/***/ ((module) => {

eval("\n\nvar MAX_BATCH_SIZE = 128;\nvar GEO_LIMIT_TYPES = ['withinMiles', 'withinKilometers', 'withinRadians', 'withinDegrees'];\nvar SYNC_TIMEOUT = 360000; // 6 minutes\nvar MODEL_QUEUED_FOR_TRAINING = '21103';\nvar MODEL_TRAINING = '21101';\nvar POLLTIME = 2000;\n\nmodule.exports = {\n  API: {\n    TOKEN_PATH: '/token',\n    MODELS_PATH: '/models',\n    MODEL_PATH: '/models/$0',\n    MODEL_VERSIONS_PATH: '/models/$0/versions',\n    MODEL_VERSION_PATH: '/models/$0/versions/$1',\n    MODEL_PATCH_PATH: '/models/$0/output_info/data/concepts',\n    MODEL_OUTPUT_PATH: '/models/$0/output_info',\n    MODEL_VERSION_OUTPUT_PATH: '/models/$0/versions/$1/output_info',\n    MODEL_SEARCH_PATH: '/models/searches',\n    MODEL_FEEDBACK_PATH: '/models/$0/feedback',\n    MODEL_VERSION_FEEDBACK_PATH: '/models/$0/versions/$1/feedback',\n    PREDICT_PATH: '/models/$0/outputs',\n    VERSION_PREDICT_PATH: '/models/$0/versions/$1/outputs',\n    CONCEPTS_PATH: '/concepts',\n    CONCEPT_PATH: '/concepts/$0',\n    CONCEPT_SEARCH_PATH: '/concepts/searches',\n    MODEL_INPUTS_PATH: '/models/$0/inputs',\n    MODEL_VERSION_INPUTS_PATH: '/models/$0/versions/$1/inputs',\n    MODEL_VERSION_METRICS_PATH: '/models/$0/versions/$1/metrics',\n    INPUTS_PATH: '/inputs',\n    INPUT_PATH: '/inputs/$0',\n    INPUTS_STATUS_PATH: '/inputs/status',\n    SEARCH_PATH: '/searches',\n    SEARCH_FEEDBACK_PATH: '/searches/feedback',\n    WORKFLOWS_PATH: '/workflows',\n    WORKFLOW_PATH: '/workflows/$0',\n    WORKFLOW_RESULTS_PATH: '/workflows/$0/results'\n  },\n  ERRORS: {\n    paramsRequired: function paramsRequired(param) {\n      var paramList = Array.isArray(param) ? param : [param];\n      return new Error('The following ' + (paramList.length > 1 ? 'params are' : 'param is') + ' required: ' + paramList.join(', '));\n    },\n    MAX_INPUTS: new Error('Number of inputs passed exceeded max of ' + MAX_BATCH_SIZE),\n    INVALID_GEOLIMIT_TYPE: new Error('Incorrect geo_limit type. Value must be any of the following: ' + GEO_LIMIT_TYPES.join(', ')),\n    INVALID_DELETE_ARGS: new Error('Wrong arguments passed. You can only delete all models (provide no arguments), delete select models (provide list of ids),\\n    delete a single model (providing a single id) or delete a model version (provide a single id and version id)')\n  },\n  STATUS: {\n    MODEL_QUEUED_FOR_TRAINING: MODEL_QUEUED_FOR_TRAINING,\n    MODEL_TRAINING: MODEL_TRAINING\n  },\n  // var replacement must be given in order\n  replaceVars: function replaceVars(path) {\n    var vars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    var newPath = path;\n    vars.forEach(function (val, index) {\n      if (index === 0) {\n        val = encodeURIComponent(val);\n      }\n      newPath = newPath.replace(new RegExp('\\\\$' + index, 'g'), val);\n    });\n    return newPath;\n  },\n  getBasePath: function getBasePath() {\n    var apiEndpoint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'https://api.clarifai.com';\n    var userId = arguments[1];\n    var appId = arguments[2];\n\n    if (!userId || !appId) {\n      return apiEndpoint + '/v2';\n    }\n    return apiEndpoint + '/v2/users/' + userId + '/apps/' + appId;\n  },\n  GEO_LIMIT_TYPES: GEO_LIMIT_TYPES,\n  MAX_BATCH_SIZE: MAX_BATCH_SIZE,\n  SYNC_TIMEOUT: SYNC_TIMEOUT,\n  POLLTIME: POLLTIME\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2xhcmlmYWkvZGlzdC9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZnJpZ2VyYXRvcl9hcHAvLi9ub2RlX21vZHVsZXMvY2xhcmlmYWkvZGlzdC9jb25zdGFudHMuanM/MjQ2NSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBNQVhfQkFUQ0hfU0laRSA9IDEyODtcbnZhciBHRU9fTElNSVRfVFlQRVMgPSBbJ3dpdGhpbk1pbGVzJywgJ3dpdGhpbktpbG9tZXRlcnMnLCAnd2l0aGluUmFkaWFucycsICd3aXRoaW5EZWdyZWVzJ107XG52YXIgU1lOQ19USU1FT1VUID0gMzYwMDAwOyAvLyA2IG1pbnV0ZXNcbnZhciBNT0RFTF9RVUVVRURfRk9SX1RSQUlOSU5HID0gJzIxMTAzJztcbnZhciBNT0RFTF9UUkFJTklORyA9ICcyMTEwMSc7XG52YXIgUE9MTFRJTUUgPSAyMDAwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQVBJOiB7XG4gICAgVE9LRU5fUEFUSDogJy90b2tlbicsXG4gICAgTU9ERUxTX1BBVEg6ICcvbW9kZWxzJyxcbiAgICBNT0RFTF9QQVRIOiAnL21vZGVscy8kMCcsXG4gICAgTU9ERUxfVkVSU0lPTlNfUEFUSDogJy9tb2RlbHMvJDAvdmVyc2lvbnMnLFxuICAgIE1PREVMX1ZFUlNJT05fUEFUSDogJy9tb2RlbHMvJDAvdmVyc2lvbnMvJDEnLFxuICAgIE1PREVMX1BBVENIX1BBVEg6ICcvbW9kZWxzLyQwL291dHB1dF9pbmZvL2RhdGEvY29uY2VwdHMnLFxuICAgIE1PREVMX09VVFBVVF9QQVRIOiAnL21vZGVscy8kMC9vdXRwdXRfaW5mbycsXG4gICAgTU9ERUxfVkVSU0lPTl9PVVRQVVRfUEFUSDogJy9tb2RlbHMvJDAvdmVyc2lvbnMvJDEvb3V0cHV0X2luZm8nLFxuICAgIE1PREVMX1NFQVJDSF9QQVRIOiAnL21vZGVscy9zZWFyY2hlcycsXG4gICAgTU9ERUxfRkVFREJBQ0tfUEFUSDogJy9tb2RlbHMvJDAvZmVlZGJhY2snLFxuICAgIE1PREVMX1ZFUlNJT05fRkVFREJBQ0tfUEFUSDogJy9tb2RlbHMvJDAvdmVyc2lvbnMvJDEvZmVlZGJhY2snLFxuICAgIFBSRURJQ1RfUEFUSDogJy9tb2RlbHMvJDAvb3V0cHV0cycsXG4gICAgVkVSU0lPTl9QUkVESUNUX1BBVEg6ICcvbW9kZWxzLyQwL3ZlcnNpb25zLyQxL291dHB1dHMnLFxuICAgIENPTkNFUFRTX1BBVEg6ICcvY29uY2VwdHMnLFxuICAgIENPTkNFUFRfUEFUSDogJy9jb25jZXB0cy8kMCcsXG4gICAgQ09OQ0VQVF9TRUFSQ0hfUEFUSDogJy9jb25jZXB0cy9zZWFyY2hlcycsXG4gICAgTU9ERUxfSU5QVVRTX1BBVEg6ICcvbW9kZWxzLyQwL2lucHV0cycsXG4gICAgTU9ERUxfVkVSU0lPTl9JTlBVVFNfUEFUSDogJy9tb2RlbHMvJDAvdmVyc2lvbnMvJDEvaW5wdXRzJyxcbiAgICBNT0RFTF9WRVJTSU9OX01FVFJJQ1NfUEFUSDogJy9tb2RlbHMvJDAvdmVyc2lvbnMvJDEvbWV0cmljcycsXG4gICAgSU5QVVRTX1BBVEg6ICcvaW5wdXRzJyxcbiAgICBJTlBVVF9QQVRIOiAnL2lucHV0cy8kMCcsXG4gICAgSU5QVVRTX1NUQVRVU19QQVRIOiAnL2lucHV0cy9zdGF0dXMnLFxuICAgIFNFQVJDSF9QQVRIOiAnL3NlYXJjaGVzJyxcbiAgICBTRUFSQ0hfRkVFREJBQ0tfUEFUSDogJy9zZWFyY2hlcy9mZWVkYmFjaycsXG4gICAgV09SS0ZMT1dTX1BBVEg6ICcvd29ya2Zsb3dzJyxcbiAgICBXT1JLRkxPV19QQVRIOiAnL3dvcmtmbG93cy8kMCcsXG4gICAgV09SS0ZMT1dfUkVTVUxUU19QQVRIOiAnL3dvcmtmbG93cy8kMC9yZXN1bHRzJ1xuICB9LFxuICBFUlJPUlM6IHtcbiAgICBwYXJhbXNSZXF1aXJlZDogZnVuY3Rpb24gcGFyYW1zUmVxdWlyZWQocGFyYW0pIHtcbiAgICAgIHZhciBwYXJhbUxpc3QgPSBBcnJheS5pc0FycmF5KHBhcmFtKSA/IHBhcmFtIDogW3BhcmFtXTtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1RoZSBmb2xsb3dpbmcgJyArIChwYXJhbUxpc3QubGVuZ3RoID4gMSA/ICdwYXJhbXMgYXJlJyA6ICdwYXJhbSBpcycpICsgJyByZXF1aXJlZDogJyArIHBhcmFtTGlzdC5qb2luKCcsICcpKTtcbiAgICB9LFxuICAgIE1BWF9JTlBVVFM6IG5ldyBFcnJvcignTnVtYmVyIG9mIGlucHV0cyBwYXNzZWQgZXhjZWVkZWQgbWF4IG9mICcgKyBNQVhfQkFUQ0hfU0laRSksXG4gICAgSU5WQUxJRF9HRU9MSU1JVF9UWVBFOiBuZXcgRXJyb3IoJ0luY29ycmVjdCBnZW9fbGltaXQgdHlwZS4gVmFsdWUgbXVzdCBiZSBhbnkgb2YgdGhlIGZvbGxvd2luZzogJyArIEdFT19MSU1JVF9UWVBFUy5qb2luKCcsICcpKSxcbiAgICBJTlZBTElEX0RFTEVURV9BUkdTOiBuZXcgRXJyb3IoJ1dyb25nIGFyZ3VtZW50cyBwYXNzZWQuIFlvdSBjYW4gb25seSBkZWxldGUgYWxsIG1vZGVscyAocHJvdmlkZSBubyBhcmd1bWVudHMpLCBkZWxldGUgc2VsZWN0IG1vZGVscyAocHJvdmlkZSBsaXN0IG9mIGlkcyksXFxuICAgIGRlbGV0ZSBhIHNpbmdsZSBtb2RlbCAocHJvdmlkaW5nIGEgc2luZ2xlIGlkKSBvciBkZWxldGUgYSBtb2RlbCB2ZXJzaW9uIChwcm92aWRlIGEgc2luZ2xlIGlkIGFuZCB2ZXJzaW9uIGlkKScpXG4gIH0sXG4gIFNUQVRVUzoge1xuICAgIE1PREVMX1FVRVVFRF9GT1JfVFJBSU5JTkc6IE1PREVMX1FVRVVFRF9GT1JfVFJBSU5JTkcsXG4gICAgTU9ERUxfVFJBSU5JTkc6IE1PREVMX1RSQUlOSU5HXG4gIH0sXG4gIC8vIHZhciByZXBsYWNlbWVudCBtdXN0IGJlIGdpdmVuIGluIG9yZGVyXG4gIHJlcGxhY2VWYXJzOiBmdW5jdGlvbiByZXBsYWNlVmFycyhwYXRoKSB7XG4gICAgdmFyIHZhcnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuXG4gICAgdmFyIG5ld1BhdGggPSBwYXRoO1xuICAgIHZhcnMuZm9yRWFjaChmdW5jdGlvbiAodmFsLCBpbmRleCkge1xuICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgIHZhbCA9IGVuY29kZVVSSUNvbXBvbmVudCh2YWwpO1xuICAgICAgfVxuICAgICAgbmV3UGF0aCA9IG5ld1BhdGgucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxcJCcgKyBpbmRleCwgJ2cnKSwgdmFsKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3UGF0aDtcbiAgfSxcbiAgZ2V0QmFzZVBhdGg6IGZ1bmN0aW9uIGdldEJhc2VQYXRoKCkge1xuICAgIHZhciBhcGlFbmRwb2ludCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJ2h0dHBzOi8vYXBpLmNsYXJpZmFpLmNvbSc7XG4gICAgdmFyIHVzZXJJZCA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgYXBwSWQgPSBhcmd1bWVudHNbMl07XG5cbiAgICBpZiAoIXVzZXJJZCB8fCAhYXBwSWQpIHtcbiAgICAgIHJldHVybiBhcGlFbmRwb2ludCArICcvdjInO1xuICAgIH1cbiAgICByZXR1cm4gYXBpRW5kcG9pbnQgKyAnL3YyL3VzZXJzLycgKyB1c2VySWQgKyAnL2FwcHMvJyArIGFwcElkO1xuICB9LFxuICBHRU9fTElNSVRfVFlQRVM6IEdFT19MSU1JVF9UWVBFUyxcbiAgTUFYX0JBVENIX1NJWkU6IE1BWF9CQVRDSF9TSVpFLFxuICBTWU5DX1RJTUVPVVQ6IFNZTkNfVElNRU9VVCxcbiAgUE9MTFRJTUU6IFBPTExUSU1FXG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/clarifai/dist/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/clarifai/dist/helpers.js":
/*!***********************************************!*\
  !*** ./node_modules/clarifai/dist/helpers.js ***!
  \***********************************************/
/***/ ((module) => {

eval("\n\nvar SUCCESS_CODES = [200, 201];\n\nmodule.exports = {\n  isSuccess: function isSuccess(response) {\n    return SUCCESS_CODES.indexOf(response.status) > -1;\n  },\n  deleteEmpty: function deleteEmpty(obj) {\n    var strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    Object.keys(obj).forEach(function (key) {\n      if (obj[key] === null || obj[key] === undefined || strict === true && (obj[key] === '' || obj[key].length === 0 || Object.keys(obj[key]).length === 0)) {\n        delete obj[key];\n      }\n    });\n  },\n  clone: function clone(obj) {\n    var keys = Object.keys(obj);\n    var copy = {};\n    keys.forEach(function (k) {\n      copy[k] = obj[k];\n    });\n    return copy;\n  },\n  checkType: function checkType(regex, val) {\n    if (regex instanceof RegExp === false) {\n      regex = new RegExp(regex);\n    }\n    return regex.test(Object.prototype.toString.call(val));\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2xhcmlmYWkvZGlzdC9oZWxwZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVmcmlnZXJhdG9yX2FwcC8uL25vZGVfbW9kdWxlcy9jbGFyaWZhaS9kaXN0L2hlbHBlcnMuanM/NTdjOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBTVUNDRVNTX0NPREVTID0gWzIwMCwgMjAxXTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzU3VjY2VzczogZnVuY3Rpb24gaXNTdWNjZXNzKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIFNVQ0NFU1NfQ09ERVMuaW5kZXhPZihyZXNwb25zZS5zdGF0dXMpID4gLTE7XG4gIH0sXG4gIGRlbGV0ZUVtcHR5OiBmdW5jdGlvbiBkZWxldGVFbXB0eShvYmopIHtcbiAgICB2YXIgc3RyaWN0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAob2JqW2tleV0gPT09IG51bGwgfHwgb2JqW2tleV0gPT09IHVuZGVmaW5lZCB8fCBzdHJpY3QgPT09IHRydWUgJiYgKG9ialtrZXldID09PSAnJyB8fCBvYmpba2V5XS5sZW5ndGggPT09IDAgfHwgT2JqZWN0LmtleXMob2JqW2tleV0pLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBjbG9uZTogZnVuY3Rpb24gY2xvbmUob2JqKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIHZhciBjb3B5ID0ge307XG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBjb3B5W2tdID0gb2JqW2tdO1xuICAgIH0pO1xuICAgIHJldHVybiBjb3B5O1xuICB9LFxuICBjaGVja1R5cGU6IGZ1bmN0aW9uIGNoZWNrVHlwZShyZWdleCwgdmFsKSB7XG4gICAgaWYgKHJlZ2V4IGluc3RhbmNlb2YgUmVnRXhwID09PSBmYWxzZSkge1xuICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZ2V4LnRlc3QoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkpO1xuICB9XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/clarifai/dist/helpers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/clarifai/dist/index.js":
/*!*********************************************!*\
  !*** ./node_modules/clarifai/dist/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar App = __webpack_require__(/*! ./App */ \"(rsc)/./node_modules/clarifai/dist/App.js\");\n\nvar _require = __webpack_require__(/*! ./../package.json */ \"(rsc)/./node_modules/clarifai/package.json\"),\n    version = _require.version;\n\nmodule.exports = global.Clarifai = {\n  version: version,\n  App: App,\n  GENERAL_MODEL: 'aaa03c23b3724a16a56b629203edc62c',\n  FOOD_MODEL: 'bd367be194cf45149e75f01d59f77ba7',\n  TRAVEL_MODEL: 'eee28c313d69466f836ab83287a54ed9',\n  NSFW_MODEL: 'e9576d86d2004ed1a38ba0cf39ecb4b1',\n  WEDDINGS_MODEL: 'c386b7a870114f4a87477c0824499348',\n  WEDDING_MODEL: 'c386b7a870114f4a87477c0824499348',\n  COLOR_MODEL: 'eeed0b6733a644cea07cf4c60f87ebb7',\n  CLUSTER_MODEL: 'cccbe437d6e54e2bb911c6aa292fb072',\n  FACE_DETECT_MODEL: 'a403429f2ddf4b49b307e318f00e528b',\n  FOCUS_MODEL: 'c2cf7cecd8a6427da375b9f35fcd2381',\n  LOGO_MODEL: 'c443119bf2ed4da98487520d01a0b1e3',\n  DEMOGRAPHICS_MODEL: 'c0c0ac362b03416da06ab3fa36fb58e3',\n  GENERAL_EMBED_MODEL: 'bbb5f41425b8468d9b7a554ff10f8581',\n  FACE_EMBED_MODEL: 'd02b4508df58432fbb84e800597b8959',\n  APPAREL_MODEL: 'e0be3b9d6a454f0493ac3a30784001ff',\n  MODERATION_MODEL: 'd16f390eb32cad478c7ae150069bd2c6',\n  TEXTURES_AND_PATTERNS: 'fbefb47f9fdb410e8ce14f24f54b47ff',\n  LANDSCAPE_QUALITY: 'bec14810deb94c40a05f1f0eb3c91403',\n  PORTRAIT_QUALITY: 'de9bd05cfdbf4534af151beb2a5d0953',\n  CELEBRITY_MODEL: 'e466caa0619f444ab97497640cefc4dc'\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2xhcmlmYWkvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixVQUFVLG1CQUFPLENBQUMsd0RBQU87O0FBRXpCLGVBQWUsbUJBQU8sQ0FBQyxxRUFBbUI7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVmcmlnZXJhdG9yX2FwcC8uL25vZGVfbW9kdWxlcy9jbGFyaWZhaS9kaXN0L2luZGV4LmpzPzRhYjUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQXBwID0gcmVxdWlyZSgnLi9BcHAnKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi8uLi9wYWNrYWdlLmpzb24nKSxcbiAgICB2ZXJzaW9uID0gX3JlcXVpcmUudmVyc2lvbjtcblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuQ2xhcmlmYWkgPSB7XG4gIHZlcnNpb246IHZlcnNpb24sXG4gIEFwcDogQXBwLFxuICBHRU5FUkFMX01PREVMOiAnYWFhMDNjMjNiMzcyNGExNmE1NmI2MjkyMDNlZGM2MmMnLFxuICBGT09EX01PREVMOiAnYmQzNjdiZTE5NGNmNDUxNDllNzVmMDFkNTlmNzdiYTcnLFxuICBUUkFWRUxfTU9ERUw6ICdlZWUyOGMzMTNkNjk0NjZmODM2YWI4MzI4N2E1NGVkOScsXG4gIE5TRldfTU9ERUw6ICdlOTU3NmQ4NmQyMDA0ZWQxYTM4YmEwY2YzOWVjYjRiMScsXG4gIFdFRERJTkdTX01PREVMOiAnYzM4NmI3YTg3MDExNGY0YTg3NDc3YzA4MjQ0OTkzNDgnLFxuICBXRURESU5HX01PREVMOiAnYzM4NmI3YTg3MDExNGY0YTg3NDc3YzA4MjQ0OTkzNDgnLFxuICBDT0xPUl9NT0RFTDogJ2VlZWQwYjY3MzNhNjQ0Y2VhMDdjZjRjNjBmODdlYmI3JyxcbiAgQ0xVU1RFUl9NT0RFTDogJ2NjY2JlNDM3ZDZlNTRlMmJiOTExYzZhYTI5MmZiMDcyJyxcbiAgRkFDRV9ERVRFQ1RfTU9ERUw6ICdhNDAzNDI5ZjJkZGY0YjQ5YjMwN2UzMThmMDBlNTI4YicsXG4gIEZPQ1VTX01PREVMOiAnYzJjZjdjZWNkOGE2NDI3ZGEzNzViOWYzNWZjZDIzODEnLFxuICBMT0dPX01PREVMOiAnYzQ0MzExOWJmMmVkNGRhOTg0ODc1MjBkMDFhMGIxZTMnLFxuICBERU1PR1JBUEhJQ1NfTU9ERUw6ICdjMGMwYWMzNjJiMDM0MTZkYTA2YWIzZmEzNmZiNThlMycsXG4gIEdFTkVSQUxfRU1CRURfTU9ERUw6ICdiYmI1ZjQxNDI1Yjg0NjhkOWI3YTU1NGZmMTBmODU4MScsXG4gIEZBQ0VfRU1CRURfTU9ERUw6ICdkMDJiNDUwOGRmNTg0MzJmYmI4NGU4MDA1OTdiODk1OScsXG4gIEFQUEFSRUxfTU9ERUw6ICdlMGJlM2I5ZDZhNDU0ZjA0OTNhYzNhMzA3ODQwMDFmZicsXG4gIE1PREVSQVRJT05fTU9ERUw6ICdkMTZmMzkwZWIzMmNhZDQ3OGM3YWUxNTAwNjliZDJjNicsXG4gIFRFWFRVUkVTX0FORF9QQVRURVJOUzogJ2ZiZWZiNDdmOWZkYjQxMGU4Y2UxNGYyNGY1NGI0N2ZmJyxcbiAgTEFORFNDQVBFX1FVQUxJVFk6ICdiZWMxNDgxMGRlYjk0YzQwYTA1ZjFmMGViM2M5MTQwMycsXG4gIFBPUlRSQUlUX1FVQUxJVFk6ICdkZTliZDA1Y2ZkYmY0NTM0YWYxNTFiZWIyYTVkMDk1MycsXG4gIENFTEVCUklUWV9NT0RFTDogJ2U0NjZjYWEwNjE5ZjQ0NGFiOTc0OTc2NDBjZWZjNGRjJ1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/clarifai/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/clarifai/dist/solutions/Moderation.js":
/*!************************************************************!*\
  !*** ./node_modules/clarifai/dist/solutions/Moderation.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar axios = __webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\");\n\nvar _require = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/clarifai/dist/utils.js\"),\n    wrapToken = _require.wrapToken;\n\nvar _require2 = __webpack_require__(/*! ../helpers */ \"(rsc)/./node_modules/clarifai/dist/helpers.js\"),\n    isSuccess = _require2.isSuccess,\n    clone = _require2.clone;\n\nvar BASE_URL = 'https://api.clarifai-moderation.com';\n\nvar Moderation = function () {\n  function Moderation(_config) {\n    _classCallCheck(this, Moderation);\n\n    this._config = _config;\n  }\n\n  _createClass(Moderation, [{\n    key: 'predict',\n    value: function predict(modelID, imageURL) {\n      return wrapToken(this._config, function (headers) {\n        var url = BASE_URL + '/v2/models/' + modelID + '/outputs';\n        var params = {\n          inputs: [{\n            data: {\n              image: {\n                url: imageURL\n              }\n            }\n          }]\n        };\n\n        return new Promise(function (resolve, reject) {\n          return axios.post(url, params, { headers: headers }).then(function (response) {\n            if (isSuccess(response)) {\n              var data = clone(response.data);\n              resolve(data);\n            } else {\n              reject(response);\n            }\n          }, reject);\n        });\n      });\n    }\n  }, {\n    key: 'getModerationStatus',\n    value: function getModerationStatus(imageID) {\n      return wrapToken(this._config, function (headers) {\n        var url = BASE_URL + '/v2/inputs/' + imageID + '/outputs';\n        return new Promise(function (resolve, reject) {\n          return axios.get(url, { headers: headers }).then(function (response) {\n            var data = clone(response.data);\n            resolve(data);\n          }, reject);\n        });\n      });\n    }\n  }]);\n\n  return Moderation;\n}();\n\nmodule.exports = Moderation;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2xhcmlmYWkvZGlzdC9zb2x1dGlvbnMvTW9kZXJhdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixpQ0FBaUMsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsK0RBQStELHlEQUF5RCxxRUFBcUUsNkRBQTZELHdCQUF3Qjs7QUFFampCLGtEQUFrRCwwQ0FBMEM7O0FBRTVGLFlBQVksbUJBQU8sQ0FBQyw2REFBTzs7QUFFM0IsZUFBZSxtQkFBTyxDQUFDLDZEQUFVO0FBQ2pDOztBQUVBLGdCQUFnQixtQkFBTyxDQUFDLGlFQUFZO0FBQ3BDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0EsMkNBQTJDLGtCQUFrQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msa0JBQWtCO0FBQ3BEO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVmcmlnZXJhdG9yX2FwcC8uL25vZGVfbW9kdWxlcy9jbGFyaWZhaS9kaXN0L3NvbHV0aW9ucy9Nb2RlcmF0aW9uLmpzP2QzMzgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgYXhpb3MgPSByZXF1aXJlKCdheGlvcycpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuLi91dGlscycpLFxuICAgIHdyYXBUb2tlbiA9IF9yZXF1aXJlLndyYXBUb2tlbjtcblxudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoJy4uL2hlbHBlcnMnKSxcbiAgICBpc1N1Y2Nlc3MgPSBfcmVxdWlyZTIuaXNTdWNjZXNzLFxuICAgIGNsb25lID0gX3JlcXVpcmUyLmNsb25lO1xuXG52YXIgQkFTRV9VUkwgPSAnaHR0cHM6Ly9hcGkuY2xhcmlmYWktbW9kZXJhdGlvbi5jb20nO1xuXG52YXIgTW9kZXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTW9kZXJhdGlvbihfY29uZmlnKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1vZGVyYXRpb24pO1xuXG4gICAgdGhpcy5fY29uZmlnID0gX2NvbmZpZztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNb2RlcmF0aW9uLCBbe1xuICAgIGtleTogJ3ByZWRpY3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVkaWN0KG1vZGVsSUQsIGltYWdlVVJMKSB7XG4gICAgICByZXR1cm4gd3JhcFRva2VuKHRoaXMuX2NvbmZpZywgZnVuY3Rpb24gKGhlYWRlcnMpIHtcbiAgICAgICAgdmFyIHVybCA9IEJBU0VfVVJMICsgJy92Mi9tb2RlbHMvJyArIG1vZGVsSUQgKyAnL291dHB1dHMnO1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgIGlucHV0czogW3tcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgaW1hZ2U6IHtcbiAgICAgICAgICAgICAgICB1cmw6IGltYWdlVVJMXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIGF4aW9zLnBvc3QodXJsLCBwYXJhbXMsIHsgaGVhZGVyczogaGVhZGVycyB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKGlzU3VjY2VzcyhyZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgdmFyIGRhdGEgPSBjbG9uZShyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlamVjdChyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRNb2RlcmF0aW9uU3RhdHVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TW9kZXJhdGlvblN0YXR1cyhpbWFnZUlEKSB7XG4gICAgICByZXR1cm4gd3JhcFRva2VuKHRoaXMuX2NvbmZpZywgZnVuY3Rpb24gKGhlYWRlcnMpIHtcbiAgICAgICAgdmFyIHVybCA9IEJBU0VfVVJMICsgJy92Mi9pbnB1dHMvJyArIGltYWdlSUQgKyAnL291dHB1dHMnO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHJldHVybiBheGlvcy5nZXQodXJsLCB7IGhlYWRlcnM6IGhlYWRlcnMgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gY2xvbmUocmVzcG9uc2UuZGF0YSk7XG4gICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1vZGVyYXRpb247XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gTW9kZXJhdGlvbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/clarifai/dist/solutions/Moderation.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/clarifai/dist/solutions/Solutions.js":
/*!***********************************************************!*\
  !*** ./node_modules/clarifai/dist/solutions/Solutions.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Moderation = __webpack_require__(/*! ./Moderation */ \"(rsc)/./node_modules/clarifai/dist/solutions/Moderation.js\");\n\nvar Solutions = function Solutions(_config) {\n  _classCallCheck(this, Solutions);\n\n  this.moderation = new Moderation(_config);\n};\n\nmodule.exports = Solutions;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2xhcmlmYWkvZGlzdC9zb2x1dGlvbnMvU29sdXRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGtEQUFrRCwwQ0FBMEM7O0FBRTVGLGlCQUFpQixtQkFBTyxDQUFDLGdGQUFjOztBQUV2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWZyaWdlcmF0b3JfYXBwLy4vbm9kZV9tb2R1bGVzL2NsYXJpZmFpL2Rpc3Qvc29sdXRpb25zL1NvbHV0aW9ucy5qcz9mMzhlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIE1vZGVyYXRpb24gPSByZXF1aXJlKCcuL01vZGVyYXRpb24nKTtcblxudmFyIFNvbHV0aW9ucyA9IGZ1bmN0aW9uIFNvbHV0aW9ucyhfY29uZmlnKSB7XG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTb2x1dGlvbnMpO1xuXG4gIHRoaXMubW9kZXJhdGlvbiA9IG5ldyBNb2RlcmF0aW9uKF9jb25maWcpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb2x1dGlvbnM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/clarifai/dist/solutions/Solutions.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/clarifai/dist/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/clarifai/dist/utils.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar Promise = __webpack_require__(/*! promise */ \"(rsc)/./node_modules/promise/index.js\");\nvar validUrl = __webpack_require__(/*! valid-url */ \"(rsc)/./node_modules/valid-url/index.js\");\n\nvar _require = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/clarifai/dist/constants.js\"),\n    GEO_LIMIT_TYPES = _require.GEO_LIMIT_TYPES,\n    ERRORS = _require.ERRORS;\n\nvar _require2 = __webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/clarifai/dist/helpers.js\"),\n    checkType = _require2.checkType,\n    clone = _require2.clone;\n\nvar _require3 = __webpack_require__(/*! ./../package.json */ \"(rsc)/./node_modules/clarifai/package.json\"),\n    VERSION = _require3.version;\n\nmodule.exports = {\n  wrapToken: function wrapToken(_config, requestFn) {\n    return new Promise(function (resolve, reject) {\n      if (_config.apiKey) {\n        var headers = {\n          Authorization: 'Key ' + _config.apiKey,\n          'X-Clarifai-Client': 'js:' + VERSION\n        };\n        return requestFn(headers).then(resolve, reject);\n      }\n      if (_config.sessionToken) {\n        var _headers = {\n          'X-Clarifai-Session-Token': _config.sessionToken,\n          'X-Clarifai-Client': 'js:' + VERSION\n        };\n        return requestFn(_headers).then(resolve, reject);\n      }\n      _config.token().then(function (token) {\n        var headers = {\n          Authorization: 'Bearer ' + token.accessToken,\n          'X-Clarifai-Client': 'js:' + VERSION\n        };\n        requestFn(headers).then(resolve, reject);\n      }, reject);\n    });\n  },\n  formatModel: function formatModel() {\n    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var formatted = {};\n    if (data.id === null || data.id === undefined) {\n      throw ERRORS.paramsRequired('Model ID');\n    }\n    formatted.id = data.id;\n    if (data.name) {\n      formatted.name = data.name;\n    }\n    formatted.output_info = {};\n    if (data.conceptsMutuallyExclusive !== undefined) {\n      formatted.output_info.output_config = formatted.output_info.output_config || {};\n      formatted.output_info.output_config.concepts_mutually_exclusive = !!data.conceptsMutuallyExclusive;\n    }\n    if (data.closedEnvironment !== undefined) {\n      formatted.output_info.output_config = formatted.output_info.output_config || {};\n      formatted.output_info.output_config.closed_environment = !!data.closedEnvironment;\n    }\n    if (data.concepts) {\n      formatted.output_info.data = {\n        concepts: data.concepts.map(module.exports.formatConcept)\n      };\n    }\n    return formatted;\n  },\n  formatInput: function formatInput(data, includeImage) {\n    var input = checkType(/String/, data) ? { url: data } : data;\n    var formatted = {\n      id: input.id || null,\n      data: {}\n    };\n    if (input.concepts) {\n      formatted.data.concepts = input.concepts;\n    }\n    if (input.metadata) {\n      formatted.data.metadata = input.metadata;\n    }\n    if (input.geo) {\n      formatted.data.geo = { geo_point: input.geo };\n    }\n    if (input.regions) {\n      formatted.data.regions = input.regions;\n    }\n    if (includeImage !== false) {\n      formatted.data.image = {\n        url: input.url,\n        base64: input.base64,\n        crop: input.crop\n      };\n      if (data.allowDuplicateUrl) {\n        formatted.data.image.allow_duplicate_url = true;\n      }\n    }\n    return formatted;\n  },\n  formatMediaPredict: function formatMediaPredict(data) {\n    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'image';\n\n    var media = void 0;\n    if (checkType(/String/, data)) {\n      if (validUrl.isWebUri(data)) {\n        media = {\n          url: data\n        };\n      } else {\n        media = {\n          base64: data\n        };\n      }\n    } else {\n      media = Object.assign({}, data);\n    }\n\n    // Users can specify their own id to distinguish batch results\n    var id = void 0;\n    if (media.id) {\n      id = media.id;\n      delete media.id;\n    }\n\n    var object = {\n      data: _defineProperty({}, type, media)\n    };\n\n    if (id) {\n      object.id = id;\n    }\n\n    return object;\n  },\n  formatImagesSearch: function formatImagesSearch(image) {\n    var imageQuery = void 0;\n    var input = { input: { data: {} } };\n    var formatted = [];\n    if (checkType(/String/, image)) {\n      imageQuery = { url: image };\n    } else {\n      imageQuery = image.url || image.base64 ? {\n        image: {\n          url: image.url,\n          base64: image.base64,\n          crop: image.crop\n        }\n      } : {};\n    }\n\n    input.input.data = imageQuery;\n    if (image.id) {\n      input.input.id = image.id;\n      input.input.data = { image: {} };\n      if (image.crop) {\n        input.input.data.image.crop = image.crop;\n      }\n    }\n    if (image.metadata !== undefined) {\n      input.input.data.metadata = image.metadata;\n    }\n    if (image.geo !== undefined) {\n      if (checkType(/Array/, image.geo)) {\n        input.input.data.geo = {\n          geo_box: image.geo.map(function (p) {\n            return { geo_point: p };\n          })\n        };\n      } else if (checkType(/Object/, image.geo)) {\n        if (GEO_LIMIT_TYPES.indexOf(image.geo.type) === -1) {\n          throw ERRORS.INVALID_GEOLIMIT_TYPE;\n        }\n        input.input.data.geo = {\n          geo_point: {\n            latitude: image.geo.latitude,\n            longitude: image.geo.longitude\n          },\n          geo_limit: {\n            type: image.geo.type,\n            value: image.geo.value\n          }\n        };\n      }\n    }\n    if (image.type !== 'input' && input.input.data.image) {\n      if (input.input.data.metadata || input.input.data.geo) {\n        var dataCopy = { input: { data: clone(input.input.data) } };\n        var imageCopy = { input: { data: clone(input.input.data) } };\n        delete dataCopy.input.data.image;\n        delete imageCopy.input.data.metadata;\n        delete imageCopy.input.data.geo;\n        input = [{ output: imageCopy }, dataCopy];\n      } else {\n        input = [{ output: input }];\n      }\n    }\n    formatted = formatted.concat(input);\n    return formatted;\n  },\n  formatConcept: function formatConcept(concept) {\n    var formatted = concept;\n    if (checkType(/String/, concept)) {\n      formatted = {\n        id: concept\n      };\n    }\n    return formatted;\n  },\n  formatConceptsSearch: function formatConceptsSearch(query) {\n    if (checkType(/String/, query)) {\n      query = { id: query };\n    }\n    var v = {};\n    var type = query.type === 'input' ? 'input' : 'output';\n    delete query.type;\n    v[type] = {\n      data: {\n        concepts: [query]\n      }\n    };\n    return v;\n  },\n  formatObjectForSnakeCase: function formatObjectForSnakeCase(obj) {\n    return Object.keys(obj).reduce(function (o, k) {\n      o[k.replace(/([A-Z])/g, function (r) {\n        return '_' + r.toLowerCase();\n      })] = obj[k];\n      return o;\n    }, {});\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2xhcmlmYWkvZGlzdC91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw0Q0FBNEMsa0JBQWtCLGtDQUFrQyxvRUFBb0UsS0FBSyxPQUFPLG9CQUFvQjs7QUFFcE0sY0FBYyxtQkFBTyxDQUFDLHNEQUFTO0FBQy9CLGVBQWUsbUJBQU8sQ0FBQywwREFBVzs7QUFFbEMsZUFBZSxtQkFBTyxDQUFDLG9FQUFhO0FBQ3BDO0FBQ0E7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsZ0VBQVc7QUFDbkM7QUFDQTs7QUFFQSxnQkFBZ0IsbUJBQU8sQ0FBQyxxRUFBbUI7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDhDQUE4QyxZQUFZO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixTQUFTO0FBQ2xDLDBCQUEwQixTQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEMsUUFBUTtBQUNSLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWZyaWdlcmF0b3JfYXBwLy4vbm9kZV9tb2R1bGVzL2NsYXJpZmFpL2Rpc3QvdXRpbHMuanM/YjEyYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbnZhciBQcm9taXNlID0gcmVxdWlyZSgncHJvbWlzZScpO1xudmFyIHZhbGlkVXJsID0gcmVxdWlyZSgndmFsaWQtdXJsJyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyksXG4gICAgR0VPX0xJTUlUX1RZUEVTID0gX3JlcXVpcmUuR0VPX0xJTUlUX1RZUEVTLFxuICAgIEVSUk9SUyA9IF9yZXF1aXJlLkVSUk9SUztcblxudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoJy4vaGVscGVycycpLFxuICAgIGNoZWNrVHlwZSA9IF9yZXF1aXJlMi5jaGVja1R5cGUsXG4gICAgY2xvbmUgPSBfcmVxdWlyZTIuY2xvbmU7XG5cbnZhciBfcmVxdWlyZTMgPSByZXF1aXJlKCcuLy4uL3BhY2thZ2UuanNvbicpLFxuICAgIFZFUlNJT04gPSBfcmVxdWlyZTMudmVyc2lvbjtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHdyYXBUb2tlbjogZnVuY3Rpb24gd3JhcFRva2VuKF9jb25maWcsIHJlcXVlc3RGbikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBpZiAoX2NvbmZpZy5hcGlLZXkpIHtcbiAgICAgICAgdmFyIGhlYWRlcnMgPSB7XG4gICAgICAgICAgQXV0aG9yaXphdGlvbjogJ0tleSAnICsgX2NvbmZpZy5hcGlLZXksXG4gICAgICAgICAgJ1gtQ2xhcmlmYWktQ2xpZW50JzogJ2pzOicgKyBWRVJTSU9OXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXF1ZXN0Rm4oaGVhZGVycykudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgfVxuICAgICAgaWYgKF9jb25maWcuc2Vzc2lvblRva2VuKSB7XG4gICAgICAgIHZhciBfaGVhZGVycyA9IHtcbiAgICAgICAgICAnWC1DbGFyaWZhaS1TZXNzaW9uLVRva2VuJzogX2NvbmZpZy5zZXNzaW9uVG9rZW4sXG4gICAgICAgICAgJ1gtQ2xhcmlmYWktQ2xpZW50JzogJ2pzOicgKyBWRVJTSU9OXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXF1ZXN0Rm4oX2hlYWRlcnMpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICAgIF9jb25maWcudG9rZW4oKS50aGVuKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICB2YXIgaGVhZGVycyA9IHtcbiAgICAgICAgICBBdXRob3JpemF0aW9uOiAnQmVhcmVyICcgKyB0b2tlbi5hY2Nlc3NUb2tlbixcbiAgICAgICAgICAnWC1DbGFyaWZhaS1DbGllbnQnOiAnanM6JyArIFZFUlNJT05cbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdEZuKGhlYWRlcnMpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0sIHJlamVjdCk7XG4gICAgfSk7XG4gIH0sXG4gIGZvcm1hdE1vZGVsOiBmdW5jdGlvbiBmb3JtYXRNb2RlbCgpIHtcbiAgICB2YXIgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICB2YXIgZm9ybWF0dGVkID0ge307XG4gICAgaWYgKGRhdGEuaWQgPT09IG51bGwgfHwgZGF0YS5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBFUlJPUlMucGFyYW1zUmVxdWlyZWQoJ01vZGVsIElEJyk7XG4gICAgfVxuICAgIGZvcm1hdHRlZC5pZCA9IGRhdGEuaWQ7XG4gICAgaWYgKGRhdGEubmFtZSkge1xuICAgICAgZm9ybWF0dGVkLm5hbWUgPSBkYXRhLm5hbWU7XG4gICAgfVxuICAgIGZvcm1hdHRlZC5vdXRwdXRfaW5mbyA9IHt9O1xuICAgIGlmIChkYXRhLmNvbmNlcHRzTXV0dWFsbHlFeGNsdXNpdmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9ybWF0dGVkLm91dHB1dF9pbmZvLm91dHB1dF9jb25maWcgPSBmb3JtYXR0ZWQub3V0cHV0X2luZm8ub3V0cHV0X2NvbmZpZyB8fCB7fTtcbiAgICAgIGZvcm1hdHRlZC5vdXRwdXRfaW5mby5vdXRwdXRfY29uZmlnLmNvbmNlcHRzX211dHVhbGx5X2V4Y2x1c2l2ZSA9ICEhZGF0YS5jb25jZXB0c011dHVhbGx5RXhjbHVzaXZlO1xuICAgIH1cbiAgICBpZiAoZGF0YS5jbG9zZWRFbnZpcm9ubWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3JtYXR0ZWQub3V0cHV0X2luZm8ub3V0cHV0X2NvbmZpZyA9IGZvcm1hdHRlZC5vdXRwdXRfaW5mby5vdXRwdXRfY29uZmlnIHx8IHt9O1xuICAgICAgZm9ybWF0dGVkLm91dHB1dF9pbmZvLm91dHB1dF9jb25maWcuY2xvc2VkX2Vudmlyb25tZW50ID0gISFkYXRhLmNsb3NlZEVudmlyb25tZW50O1xuICAgIH1cbiAgICBpZiAoZGF0YS5jb25jZXB0cykge1xuICAgICAgZm9ybWF0dGVkLm91dHB1dF9pbmZvLmRhdGEgPSB7XG4gICAgICAgIGNvbmNlcHRzOiBkYXRhLmNvbmNlcHRzLm1hcChtb2R1bGUuZXhwb3J0cy5mb3JtYXRDb25jZXB0KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZvcm1hdHRlZDtcbiAgfSxcbiAgZm9ybWF0SW5wdXQ6IGZ1bmN0aW9uIGZvcm1hdElucHV0KGRhdGEsIGluY2x1ZGVJbWFnZSkge1xuICAgIHZhciBpbnB1dCA9IGNoZWNrVHlwZSgvU3RyaW5nLywgZGF0YSkgPyB7IHVybDogZGF0YSB9IDogZGF0YTtcbiAgICB2YXIgZm9ybWF0dGVkID0ge1xuICAgICAgaWQ6IGlucHV0LmlkIHx8IG51bGwsXG4gICAgICBkYXRhOiB7fVxuICAgIH07XG4gICAgaWYgKGlucHV0LmNvbmNlcHRzKSB7XG4gICAgICBmb3JtYXR0ZWQuZGF0YS5jb25jZXB0cyA9IGlucHV0LmNvbmNlcHRzO1xuICAgIH1cbiAgICBpZiAoaW5wdXQubWV0YWRhdGEpIHtcbiAgICAgIGZvcm1hdHRlZC5kYXRhLm1ldGFkYXRhID0gaW5wdXQubWV0YWRhdGE7XG4gICAgfVxuICAgIGlmIChpbnB1dC5nZW8pIHtcbiAgICAgIGZvcm1hdHRlZC5kYXRhLmdlbyA9IHsgZ2VvX3BvaW50OiBpbnB1dC5nZW8gfTtcbiAgICB9XG4gICAgaWYgKGlucHV0LnJlZ2lvbnMpIHtcbiAgICAgIGZvcm1hdHRlZC5kYXRhLnJlZ2lvbnMgPSBpbnB1dC5yZWdpb25zO1xuICAgIH1cbiAgICBpZiAoaW5jbHVkZUltYWdlICE9PSBmYWxzZSkge1xuICAgICAgZm9ybWF0dGVkLmRhdGEuaW1hZ2UgPSB7XG4gICAgICAgIHVybDogaW5wdXQudXJsLFxuICAgICAgICBiYXNlNjQ6IGlucHV0LmJhc2U2NCxcbiAgICAgICAgY3JvcDogaW5wdXQuY3JvcFxuICAgICAgfTtcbiAgICAgIGlmIChkYXRhLmFsbG93RHVwbGljYXRlVXJsKSB7XG4gICAgICAgIGZvcm1hdHRlZC5kYXRhLmltYWdlLmFsbG93X2R1cGxpY2F0ZV91cmwgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm9ybWF0dGVkO1xuICB9LFxuICBmb3JtYXRNZWRpYVByZWRpY3Q6IGZ1bmN0aW9uIGZvcm1hdE1lZGlhUHJlZGljdChkYXRhKSB7XG4gICAgdmFyIHR5cGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdpbWFnZSc7XG5cbiAgICB2YXIgbWVkaWEgPSB2b2lkIDA7XG4gICAgaWYgKGNoZWNrVHlwZSgvU3RyaW5nLywgZGF0YSkpIHtcbiAgICAgIGlmICh2YWxpZFVybC5pc1dlYlVyaShkYXRhKSkge1xuICAgICAgICBtZWRpYSA9IHtcbiAgICAgICAgICB1cmw6IGRhdGFcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lZGlhID0ge1xuICAgICAgICAgIGJhc2U2NDogZGF0YVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtZWRpYSA9IE9iamVjdC5hc3NpZ24oe30sIGRhdGEpO1xuICAgIH1cblxuICAgIC8vIFVzZXJzIGNhbiBzcGVjaWZ5IHRoZWlyIG93biBpZCB0byBkaXN0aW5ndWlzaCBiYXRjaCByZXN1bHRzXG4gICAgdmFyIGlkID0gdm9pZCAwO1xuICAgIGlmIChtZWRpYS5pZCkge1xuICAgICAgaWQgPSBtZWRpYS5pZDtcbiAgICAgIGRlbGV0ZSBtZWRpYS5pZDtcbiAgICB9XG5cbiAgICB2YXIgb2JqZWN0ID0ge1xuICAgICAgZGF0YTogX2RlZmluZVByb3BlcnR5KHt9LCB0eXBlLCBtZWRpYSlcbiAgICB9O1xuXG4gICAgaWYgKGlkKSB7XG4gICAgICBvYmplY3QuaWQgPSBpZDtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9LFxuICBmb3JtYXRJbWFnZXNTZWFyY2g6IGZ1bmN0aW9uIGZvcm1hdEltYWdlc1NlYXJjaChpbWFnZSkge1xuICAgIHZhciBpbWFnZVF1ZXJ5ID0gdm9pZCAwO1xuICAgIHZhciBpbnB1dCA9IHsgaW5wdXQ6IHsgZGF0YToge30gfSB9O1xuICAgIHZhciBmb3JtYXR0ZWQgPSBbXTtcbiAgICBpZiAoY2hlY2tUeXBlKC9TdHJpbmcvLCBpbWFnZSkpIHtcbiAgICAgIGltYWdlUXVlcnkgPSB7IHVybDogaW1hZ2UgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW1hZ2VRdWVyeSA9IGltYWdlLnVybCB8fCBpbWFnZS5iYXNlNjQgPyB7XG4gICAgICAgIGltYWdlOiB7XG4gICAgICAgICAgdXJsOiBpbWFnZS51cmwsXG4gICAgICAgICAgYmFzZTY0OiBpbWFnZS5iYXNlNjQsXG4gICAgICAgICAgY3JvcDogaW1hZ2UuY3JvcFxuICAgICAgICB9XG4gICAgICB9IDoge307XG4gICAgfVxuXG4gICAgaW5wdXQuaW5wdXQuZGF0YSA9IGltYWdlUXVlcnk7XG4gICAgaWYgKGltYWdlLmlkKSB7XG4gICAgICBpbnB1dC5pbnB1dC5pZCA9IGltYWdlLmlkO1xuICAgICAgaW5wdXQuaW5wdXQuZGF0YSA9IHsgaW1hZ2U6IHt9IH07XG4gICAgICBpZiAoaW1hZ2UuY3JvcCkge1xuICAgICAgICBpbnB1dC5pbnB1dC5kYXRhLmltYWdlLmNyb3AgPSBpbWFnZS5jcm9wO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW1hZ2UubWV0YWRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5wdXQuaW5wdXQuZGF0YS5tZXRhZGF0YSA9IGltYWdlLm1ldGFkYXRhO1xuICAgIH1cbiAgICBpZiAoaW1hZ2UuZ2VvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjaGVja1R5cGUoL0FycmF5LywgaW1hZ2UuZ2VvKSkge1xuICAgICAgICBpbnB1dC5pbnB1dC5kYXRhLmdlbyA9IHtcbiAgICAgICAgICBnZW9fYm94OiBpbWFnZS5nZW8ubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICByZXR1cm4geyBnZW9fcG9pbnQ6IHAgfTtcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChjaGVja1R5cGUoL09iamVjdC8sIGltYWdlLmdlbykpIHtcbiAgICAgICAgaWYgKEdFT19MSU1JVF9UWVBFUy5pbmRleE9mKGltYWdlLmdlby50eXBlKSA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBFUlJPUlMuSU5WQUxJRF9HRU9MSU1JVF9UWVBFO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0LmlucHV0LmRhdGEuZ2VvID0ge1xuICAgICAgICAgIGdlb19wb2ludDoge1xuICAgICAgICAgICAgbGF0aXR1ZGU6IGltYWdlLmdlby5sYXRpdHVkZSxcbiAgICAgICAgICAgIGxvbmdpdHVkZTogaW1hZ2UuZ2VvLmxvbmdpdHVkZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2VvX2xpbWl0OiB7XG4gICAgICAgICAgICB0eXBlOiBpbWFnZS5nZW8udHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiBpbWFnZS5nZW8udmFsdWVcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbWFnZS50eXBlICE9PSAnaW5wdXQnICYmIGlucHV0LmlucHV0LmRhdGEuaW1hZ2UpIHtcbiAgICAgIGlmIChpbnB1dC5pbnB1dC5kYXRhLm1ldGFkYXRhIHx8IGlucHV0LmlucHV0LmRhdGEuZ2VvKSB7XG4gICAgICAgIHZhciBkYXRhQ29weSA9IHsgaW5wdXQ6IHsgZGF0YTogY2xvbmUoaW5wdXQuaW5wdXQuZGF0YSkgfSB9O1xuICAgICAgICB2YXIgaW1hZ2VDb3B5ID0geyBpbnB1dDogeyBkYXRhOiBjbG9uZShpbnB1dC5pbnB1dC5kYXRhKSB9IH07XG4gICAgICAgIGRlbGV0ZSBkYXRhQ29weS5pbnB1dC5kYXRhLmltYWdlO1xuICAgICAgICBkZWxldGUgaW1hZ2VDb3B5LmlucHV0LmRhdGEubWV0YWRhdGE7XG4gICAgICAgIGRlbGV0ZSBpbWFnZUNvcHkuaW5wdXQuZGF0YS5nZW87XG4gICAgICAgIGlucHV0ID0gW3sgb3V0cHV0OiBpbWFnZUNvcHkgfSwgZGF0YUNvcHldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXQgPSBbeyBvdXRwdXQ6IGlucHV0IH1dO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3JtYXR0ZWQgPSBmb3JtYXR0ZWQuY29uY2F0KGlucHV0KTtcbiAgICByZXR1cm4gZm9ybWF0dGVkO1xuICB9LFxuICBmb3JtYXRDb25jZXB0OiBmdW5jdGlvbiBmb3JtYXRDb25jZXB0KGNvbmNlcHQpIHtcbiAgICB2YXIgZm9ybWF0dGVkID0gY29uY2VwdDtcbiAgICBpZiAoY2hlY2tUeXBlKC9TdHJpbmcvLCBjb25jZXB0KSkge1xuICAgICAgZm9ybWF0dGVkID0ge1xuICAgICAgICBpZDogY29uY2VwdFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZvcm1hdHRlZDtcbiAgfSxcbiAgZm9ybWF0Q29uY2VwdHNTZWFyY2g6IGZ1bmN0aW9uIGZvcm1hdENvbmNlcHRzU2VhcmNoKHF1ZXJ5KSB7XG4gICAgaWYgKGNoZWNrVHlwZSgvU3RyaW5nLywgcXVlcnkpKSB7XG4gICAgICBxdWVyeSA9IHsgaWQ6IHF1ZXJ5IH07XG4gICAgfVxuICAgIHZhciB2ID0ge307XG4gICAgdmFyIHR5cGUgPSBxdWVyeS50eXBlID09PSAnaW5wdXQnID8gJ2lucHV0JyA6ICdvdXRwdXQnO1xuICAgIGRlbGV0ZSBxdWVyeS50eXBlO1xuICAgIHZbdHlwZV0gPSB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIGNvbmNlcHRzOiBbcXVlcnldXG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gdjtcbiAgfSxcbiAgZm9ybWF0T2JqZWN0Rm9yU25ha2VDYXNlOiBmdW5jdGlvbiBmb3JtYXRPYmplY3RGb3JTbmFrZUNhc2Uob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikucmVkdWNlKGZ1bmN0aW9uIChvLCBrKSB7XG4gICAgICBvW2sucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbiAocikge1xuICAgICAgICByZXR1cm4gJ18nICsgci50b0xvd2VyQ2FzZSgpO1xuICAgICAgfSldID0gb2JqW2tdO1xuICAgICAgcmV0dXJuIG87XG4gICAgfSwge30pO1xuICB9XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/clarifai/dist/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/clarifai/package.json":
/*!********************************************!*\
  !*** ./node_modules/clarifai/package.json ***!
  \********************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"name":"clarifai","version":"2.9.1","description":"Official Clarifai Javascript SDK","main":"dist/index.js","repository":"https://github.com/Clarifai/clarifai-javascript","author":"Clarifai Inc.","license":"Apache-2.0","scripts":{"jsdoc":"jsdoc src/* -t node_modules/minami -d docs/$npm_package_version && jsdoc src/* -t node_modules/minami -d docs/latest","test":"gulp test","unittest":"gulp unittest","watch":"gulp watch","build":"npm run clean && gulp build && npm run jsdoc","release":"release-it","clean":"gulp cleanbuild"},"dependencies":{"axios":">=0.11.1 <2","promise":"^7.1.1","valid-url":"^1.0.9"},"devDependencies":{"axios-mock-adapter":"^1.16.0","babel-eslint":"^6.1.2","babel-preset-es2015":"^6.14.0","babel-register":"^6.14.0","babelify":"^7.3.0","del":"^2.0.2","envify":"^3.4.0","gulp":"^3.9.1","gulp-babel":"^6.1.2","gulp-browserify":"^0.5.1","gulp-eslint":"^2.0.0","gulp-insert":"^0.5.0","gulp-jasmine":"^4.0.0","gulp-notify":"2.2.0","gulp-rename":"^1.2.2","gulp-replace-task":"^0.11.0","gulp-uglify":"^1.4.1","gulp-util":"^3.0.6","jsdoc":"^3.4.1","minami":"^1.1.1","release-it":"^2.9.0"}}');

/***/ })

};
;